<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C 函数</title>
    <url>/2019/11/C-functions/</url>
    <content><![CDATA[<p>C 语言提供了子程序，它可以将我们的程序分割成不同的部分。为了编写函数，我们至少给出函数的定义。通常，我们还需要给出函数的声明；但是，函数的声明不是必须的，如果不给出函数声明，那么编译器将给出一个匹配该函数的隐式声明，而且我们将得到编译时警告。</p>
<p>每个程序都至少需要一个名为 <code>main</code> 的函数，这是程序执行的入口函数。本文主要分为以下几部分：</p>
<ul>
<li>函数声明</li>
<li>函数定义</li>
<li>函数调用</li>
<li>函数参数</li>
<li>变长参数列表</li>
<li>函数指针调用</li>
<li><code>main</code> 函数</li>
<li>递归函数</li>
<li>静态函数</li>
<li>嵌套函数</li>
</ul>
<a id="more"></a>

<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>我们编写函数声明时需要指定函数名称、参数列表以及函数返回类型。函数声明以分号结尾，其形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return-type function-name(parameter-list);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>return-type</code> 表明了函数返回值的数据类型。通过给定 <code>void</code> 的返回类型，我们可以声明函数不返回任何值。</li>
<li><code>function-name</code> 可以是任何有效的标识符（见<a href="/2019/06/C-lexical-elements/" title="标示符">标示符</a>）。</li>
<li><code>parameter-list</code> 由零个或多个参数组成，通过逗号隔开。参数由数据类型和可选的参数名组成。我们可以声明变长的参数，或者无参数（<code>void</code>）。如果不给定参数列表，那么就意味着该函数没有参数，但是最好显示的使用 <code>void</code> 给出。</li>
</ul>
<p>例如，下面是一个包含两个参数的函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果我们需要包含参数名称，我们可以在参数类型后给出，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数名同样可以为任何标识符，如果我们包含多个参数，那么在同一个声明中参数名不能重复。函数声明中的参数名称可以不必与函数定义时的参数名称一致。</p>
<p>我们应当在第一次使用函数之前声明该函数。我们可以将其放在头文件中，随后我们便可以在任何 C 源文件中通过 <code>#include</code> 指令来包含函数声明，从而使用该函数。</p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>函数定义给出了函数实际执行的操作。函数定义包含函数名称、返回类型、参数列表（数据类型和参数名）以及函数主体。函数主体由一系列包含在大括号内的语句组成；实际上它就是一个块语句（见 <a href="/2019/10/C-statements/" title="块语句">块语句</a>）。下面是函数定义的通用形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return-type</span><br><span class="line">function-name(parameter-list)</span><br><span class="line">&#123;</span><br><span class="line">    function-body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>return-type</code> 和 <code>function-name</code> 与函数声明中的相同（见函数声明）。</p>
</li>
<li><p><code>parameter-list</code> 与函数声明中的参数列表相同（见函数声明），但是，在函数定义时我们必须显示的给出参数名。</p>
</li>
</ul>
<p>例如，下面的函数定义包含两个整型参数并且返回它们的和作为返回值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">add_values(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了兼容最初的 C 语言设计，我们还可以在参数列表的右括号后指定函数参数的类型，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">add_values(x, y)</span><br><span class="line">    <span class="keyword">int</span> x, <span class="keyword">int</span> y;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，我们强烈建议不要采用这种编码格式；它可能导致类型转换的细微问题，以及其他问题。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>我们可以通过函数名称以及提供该函数必要的参数来调用函数，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">function-name(parameters)</span><br></pre></td></tr></table></figure>

<p>函数调用可以是独立的语句，也可被用作子表达式。例如，下面是一个独立的函数调用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">foo(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>在上述的示例中，函数 <code>foo</code> 的参数为 <code>5</code>。</p>
<p>下面是用作子表达式的函数调用的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = square(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>假设函数 <code>square</code> 将其参数平方，则上面的示例将值 <code>25</code> 赋值给 <code>a</code>。</p>
<p>如果一个函数接受多个参数，我们需要使用逗号将其分隔开。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = quux(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数参数可以是任何表达式 – 字面值、变量存储的值、内存地址或者通过组合这些值而构建的更复杂的表达式。</p>
<p>在函数体内，参数是传递给函数的值的本地副本；您不能通过更改本地副本来更改传入的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">23</span>;</span><br><span class="line">foo(x);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 定义函数 foo */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">2</span> * a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例总，即使传递给函数 <code>foo</code> 得到参数被修改了，传递给函数的变量 <code>x</code> 也不会发生改变。如果希望使用该函数来更改 <code>x</code> 的原始值，则必须将函数调用合并到赋值语句中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = foo(x);</span><br></pre></td></tr></table></figure>

<p>如果传递给函数的值是内存地址（即指针），则可以访问（并更改）存储在该内存地址的数据。这样可以达到与其他语言中的按引用传递相似的效果，但是效果不一样：内存地址只是一个值，就像其他任何值一样，并且本身不能更改。传递指针和传递整数之间的区别在于您可以使用函数中的值进行何种操作。</p>
<p>下面是使用指针参数的函数调用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *x = *x + <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">15</span>;</span><br><span class="line">foo(&amp;a);</span><br></pre></td></tr></table></figure>

<p>该函数的形式参数是 <code>int</code> 类型的指针，我们通过向其传递 <code>int</code> 类型变量的地址来调用该函数。通过在函数体内对指针进行解引用操作，我们可以获取内存地址中的值并对其进行修改。上述示例将修改变量 <code>a</code> 的值为 <code>57</code>。</p>
<p>即使您不想改变存储在地址中的值，如果变量类型很大并且您需要节省内存空间或限制参数复制对性能的影响，则传递变量的地址而不是变量本身可能会很有用。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">const</span> struct foo *a)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，除非您在内存地址非常大的计算机上工作，否则传递结构体的指针要比传递结构实例花费更少的内存。</p>
<p>任何类型的数组总是以指针的形式进行传递：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">100</span>];</span><br><span class="line">foo(x);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，使用参数 <code>a</code> 调用函数 <code>foo</code> 不会将整个数组复制到 <code>foo</code> 函数的新局部参数中；而是将 <code>x</code> 作为指针传递给 <code>foo</code> 函数的第一个参数。但是要小心：在函数内，您不能使用 <code>sizeof</code> 来确定数组 <code>x</code> 的大小，而 <code>sizeof</code> 却告诉您指针 <code>x</code> 的大小。实际上，以上代码等效于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *a)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">100</span>];</span><br><span class="line">foo(x);</span><br></pre></td></tr></table></figure>

<p>在参数声明中明确指定数组的长度无济于事。如果您确实需要按值传递数组，则可以将其包装在结构中，尽管这样做几乎没有用（传递 <code>const</code> 限定的指针通常足以表明调用者不应该修改数组）。</p>
<h2 id="变长参数列表"><a href="#变长参数列表" class="headerlink" title="变长参数列表"></a>变长参数列表</h2><p>我们可以编写一个带有可变数量参数的函数。这些称为可变函数（_variadic functions_）。为此，该函数至少需要具有一个已知数据类型的参数，但是其余参数是可选的，并且在数量和数据类型上都可以不同。</p>
<p>您可以像平常一样列出初始参数，但之后再使用省略号：<code>...</code>。下面是一个示例函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_multiple_values</span><span class="params">(<span class="keyword">int</span> number, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>要使用函数定义中的可变参数，我们需要使用库头文件 <code>&lt;stdarg.h&gt;</code> 中定义的宏，因此必须使用 <code>#include</code> 包含该文件。有关这些宏的详细说明，请参见 GNU C 库手册中有关可变参数功能的部分。</p>
<p>下面是一个可变参数函数的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">add_multiple_values (<span class="keyword">int</span> number, ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> counter, total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 声明 &#x27;va_list&#x27; 类型变量 */</span></span><br><span class="line">    va_list parameters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用 &#x27;va_start&#x27; 函数 */</span></span><br><span class="line">    va_start(parameters, number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (counter = <span class="number">0</span>; counter &lt; number; counter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 获取可选参数的值 */</span></span><br><span class="line">        total += va_arg(parameters, <span class="keyword">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 结束 &#x27;parameters&#x27; 变量的使用，释放资源 */</span></span><br><span class="line">    va_end(parameters);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用可选参数，您需要一种方法来知道有多少个参数。这可能会有所不同，因此无法进行硬编码，但是如果您不知道有多少个可选参数，则可能很难知道何时停止使用 <code>va_arg</code> 函数。在上面的示例中，函数 <code>add_multiple_values</code> 的第一个参数 <code>number</code> 是实际传递的可选参数的数量。因此，我们可以这样调用函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sum = add_multiple_values(<span class="number">3</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">190</span>);</span><br></pre></td></tr></table></figure>

<p>第一个参数指示跟随多少个可选参数。另外，请注意，您实际上并不需要使用 <code>va_end</code> 功能。实际上，对于GCC 而言，它什么也没做。但是，您可能要包括它以最大程度地与其他编译器兼容。</p>
<h2 id="函数指针调用"><a href="#函数指针调用" class="headerlink" title="函数指针调用"></a>函数指针调用</h2><p>我们也可以调用由指针标识的函数。间接操作符 <code>*</code> 在执行此操作时是可选的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;foo %d!\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d bar!\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">message</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">int</span>), <span class="keyword">int</span> times)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; times; ++j)</span><br><span class="line">        func(j);  <span class="comment">/* 与 (*func) (j); 作用相同 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">int</span> want_foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*pf)(<span class="keyword">int</span>) = &amp;bar; <span class="comment">/* 运算符 &amp; 是可选的 */</span></span><br><span class="line">    <span class="keyword">if</span> (want_foo)</span><br><span class="line">        pf = foo;</span><br><span class="line">    message (pf, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a><code>main</code> 函数</h2><p>每个程序都至少需要一个名为 <code>main</code> 的函数。这是程序开始执行的地方。我们不需要为 <code>main</code> 函数提供声明或原型，我们只需要定义它即可。</p>
<p><code>main</code> 函数的返回值总是 <code>int</code> 类型。我们不必为 <code>main</code> 函数指定返回类型，但是我们可以这样做。需要注意的是，我们不能指定它的返回类型不是 <code>int</code>。</p>
<p>通常，<code>main</code> 函数的返回值表明了程序退出状态。返回 <code>0</code> 或者 <code>EXIT_SUCCESS</code> 表明成功，<code>EXIT_FAILURE</code> 则表示错误。否则，返回的值由实现定义。</p>
<p>在 <code>main</code> 函数的末尾到达 <code>&#125;</code> 而没有返回值，或者执行没有值的 <code>return</code> 语句（即 <code>return;</code>）都是等效的。在 C89 标准中，这是未定义的，然而在 C99 中明确定义这种情况返回 <code>0</code>。</p>
<p>我们可以编写没有任何参数的 <code>main</code> 函数（也就是 <code>int main(void)</code>），或者从命令行接受参数。这是一个非常简单的没有参数的主函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;Hi there!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了接受来自命令行的参数，我们需要 <code>main</code> 函数提供两个参数，<code>argc</code> 和 <code>*argv[]</code>。我们可以改变参数的名称，但是它们数据类型不能改变 – <code>int</code> 类型和 <code>char</code> 类型的数组指针。<code>argc</code> 是命令行参数的数量，包括程序本身的名称。<code>argv</code> 是参数的数组，以字符串的形式给出。<code>argv[0]</code> 数组的第一个元素是在命令行中键入的程序名称；之后任何数组元素都是程序名称的参数。</p>
<p>下面的示例定义了 <code>main</code> 函数接受命名行参数，并且将其打印出来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (counter = <span class="number">0</span>; counter &lt; argc; counter++)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%s\n&quot;</span>, argv[counter]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>我们可以编写一个递归函数 – 调用自身的函数。如一个计算整数的阶乘的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">factorial(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (x * factorial(x - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意不要编写无限递归的函数。在上面的示例中，一旦 <code>x</code> 为 <code>1</code>，则递归停止。但是，在以下示例中，递归不会停止，直到程序被中断或内存不足为止：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">watermelon(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (watermelon(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，函数也可以是间接递归的。</p>
<h2 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h2><p>如果希望仅可在定义该函数的源文件中调用该函数，则可以将其定义为静态函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">foo(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您正在构建可重用的函数库，并且需要包含一些最终用户不应该调用的子函数，则这很有用。</p>
<p>以这种方式定义的函数被称为具有静态链接；不幸的是 <code>static</code> 关键字具有多重含义，见 <a href="/2019/06/C-type-and-storage-class-specifiers/" title="存储类型说明符">存储类型说明符</a>。</p>
<h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><p>作为 GNU C 扩展，我们可以在其他函数中定义函数，这种技术称为嵌套函数。</p>
<p>下面是使用嵌套函数定义的尾递归阶乘函数的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">factorial(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">    factorial_helper(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span> factorial_helper((a - <span class="number">1</span>), (a * b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factorial_helper(x, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，必须在函数的开头定义嵌套函数以及变量声明，然后再声明所有其他语句。</p>
<p>实际上，我在 <code>gcc -std=c99</code> 的时候也能通过编译，我使用的是 <code>GCC 7.4</code>，而使用 <code>clang -std=gnu99</code> 不能通过编译（<code>clang-1001.0.46.4</code>），具体的可能是编译器实现的问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Functions">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Functions</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言词法元素</title>
    <url>/2019/06/C-lexical-elements/</url>
    <content><![CDATA[<p>本文主要介绍 C 语言的词法元素，包括标识符、关键字、常量、操作符以及分隔符。其中关于操作符的一些更为详细的信息将在后续进行介绍。</p>
<img src="/2019/06/C-lexical-elements/C_lexical_elements.png" class="">

<a id="more"></a>

<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符在 C 语言中由于命令变量、函数、新的数据类型以及预处理的字符序列（例如，宏定义）。它可以包含字符、数字以及下划线（<code>_</code>)，标识符是区分大小写的，并且不能以数字开始。需要注意的是，GNU 扩展可以在标识符中使用美元符号（<code>$</code>）。</p>
<p>例如，下面的标识符是正确的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool ok;</span><br><span class="line">int my_id;</span><br><span class="line">char *_name;</span><br></pre></td></tr></table></figure>

<p>而下面的标识符则错误的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int 2id;</span><br><span class="line">char *#a;</span><br></pre></td></tr></table></figure>

<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字是 C 语言保留的特殊标识符，这些标识符有特定的用处，因此不能用于其它用途。不同的标准下，C 语言支持的关键字有所不同。下表给出了不同标准下的关键字。</p>
<table>
<thead>
<tr>
<th>标准</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>ANSI C89</td>
<td>auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, int, long, register, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while</td>
</tr>
<tr>
<td>ISO C99</td>
<td>inline, _Bool, _Complex, _Imaginary, restrict</td>
</tr>
<tr>
<td>GUN 扩展</td>
<td>__FUNCTION__, __PRETTY_FUNCTION__, __alignof, __alignof__, __asm, __asm__, __attribute, __attribute__, __builtin_offsetof, __builtin_va_arg, __complex, __complex__, __const, __extension__, __func__, __imag, __imag__, __inline, __inline__, __label__, __null, __real, __real__, __restrict, __restrict__, __signed, __signed__, __thread, __typeof, __volatile, __volatile__, restrict</td>
</tr>
</tbody></table>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是一个数值或者字符值，例如，<code>5</code> 或者 <code>&#39;m&#39;</code>。所有的常量都有一个特定的数据类型，你可以显示地将其强制转换为某个特定类型或者你也可以让编译器选择默认的数据类型。C 语言包含四类常量：a. 整型常量；b. 字符常量；c. 浮点数常量；d. 字符串常量。</p>
<h3 id="整型常量"><a href="#整型常量" class="headerlink" title="整型常量"></a>整型常量</h3><p>整型常量是一个数字组成的序列，它可以伴随一个前缀用于表示常量的基数，同时也可以带有一个后缀用以表示数据类型。C 语言提供了三种基数的表示方式：</p>
<table>
<thead>
<tr>
<th>基数</th>
<th>前缀</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>十六进制</td>
<td><code>0x</code> 或 <code>0X</code></td>
<td><code>0x2f</code>, <code>0x88</code>, <code>0XAB43</code></td>
</tr>
<tr>
<td>十进制</td>
<td>无</td>
<td><code>459</code>, <code>12</code>, <code>1293</code></td>
</tr>
<tr>
<td>八进制</td>
<td><code>0</code></td>
<td><code>057</code>, <code>03</code>, <code>012</code></td>
</tr>
</tbody></table>
<p>数据类型则可以通过字符 <code>u</code> 和 <code>l</code> 来表示：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>后缀</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>无符号整型 （<code>unsigned</code>）</td>
<td><code>u</code> 或 <code>U</code></td>
<td><code>45U</code></td>
</tr>
<tr>
<td>长整型（<code>long int</code>）</td>
<td><code>l</code> 或 <code>L</code></td>
<td><code>45L</code></td>
</tr>
<tr>
<td>长长整型 （<code>long long int</code>）</td>
<td><code>ll</code> 或 <code>LL</code></td>
<td><code>45LL</code></td>
</tr>
</tbody></table>
<p>长长整型（<code>long long int</code>）是在 ISO 99 和 GNU C 扩展中新加的数据类型。此外，我们可以通过将 <code>u</code> 和 <code>l</code> 组合起来形成无符号长整型数据类型。例如 <code>45ULL</code>。</p>
<p><strong>备注：</strong> <code>u</code> 和 <code>l</code> 的顺序没有多大关系。</p>
<h3 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h3><p>字符常量通常是有单引号包含起来的单个字符，例如，<code>A</code>。字符常量的默认数据类型为整型（<code>int</code> 类型）。一些字符无法用单个字符表示，因此需要进行转义。常见的转义字符如下所示：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\\</code></td>
<td>反斜杆字符</td>
</tr>
<tr>
<td><code>\?</code></td>
<td>问号字符</td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>单引号</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号</td>
</tr>
<tr>
<td><code>\a</code></td>
<td>警报</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>退格字符</td>
</tr>
<tr>
<td><code>\e</code></td>
<td><ESC> 字符（GNU 扩展）</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>表格填充</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行符</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车符</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>水平制表符</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>垂直制表符号</td>
</tr>
<tr>
<td><code>\o</code>,<code>\oo</code>,<code>\ooo</code></td>
<td>八进制数</td>
</tr>
<tr>
<td><code>xh</code>,<code>\xhh</code>,<code>\xhhh</code>, <code>...</code></td>
<td>十六进制数</td>
</tr>
</tbody></table>
<p>虽然十六进制的表示方式后面可以跟任意多个数字，但是给定的字符集的字符数量是有限的。例如，常用扩展的 ASCII 字符集只有 256 个字符。如果你尝试给出一个超出字符集范围的十六进制字符表示，那么编译时将出错。（我测试过后发现其实有一个警告。）</p>
<h3 id="浮点数常量"><a href="#浮点数常量" class="headerlink" title="浮点数常量"></a>浮点数常量</h3><p>浮点数常量（实数常量）由整数部分，小数点和小数部分组成，同样它可以有一个可选的数据类型后缀。在表示浮点数常量时，我们可以省略整数部分或小数部分，但不能同时省略。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a, b, c, d, e, f;</span><br><span class="line"></span><br><span class="line">a = <span class="number">4.7</span>;</span><br><span class="line">b = <span class="number">4.</span>;</span><br><span class="line">c = <span class="number">4</span>;</span><br><span class="line">d = <span class="number">.7</span>;</span><br><span class="line">e = <span class="number">0.7</span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是在 <code>c = 4;</code> 的赋值语句中，整型常量 <code>4</code> 将自动的由整型转换为浮点型（<code>double</code> 类型）。此外，我们还可以用科学计数的方式来表示浮点数，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line"></span><br><span class="line">x = <span class="number">5e2</span>;    <span class="comment">/* x 为 5 * 100，即 500.0 */</span></span><br><span class="line">y = <span class="number">5e-2</span>;   <span class="comment">/* y 为 5 * (1/100), 即 0.05 */</span></span><br></pre></td></tr></table></figure>

<p>你可以在浮点数后面添加 <code>F</code> 或 <code>f</code> 来表示单精度浮点数（<code>float</code> 类型），如果在浮点数后面添加 <code>L</code> 或 <code>l</code> 则表示该常量的数据类型为 <code>long double</code>。默认情况下，浮点数的类型为 <code>double</code>。</p>
<h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>字符串常量是由双引号包裹的零个或多个字符、数字以及转义字符序列。字符串常量的数据类型为字符数组。所有的字符串都包含一个空字符（<code>\0</code>）用来表示字符串结尾。字符串以字符数组的方式存储，它没有字符串长度的属性。字符串以末尾的空字符作为结束标志。两个相邻的字符串常量将会被连接为一个字符串常量，并且只保留最后一个字符串的空字符。</p>
<p>由于字符串由双引号作为标示，因此我们在字符串中使用双引号时需要对其进行转义。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;\&quot;Hello, world!\&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>如果一个字符串太长以致于不能放在一行中，我们可以使用反斜杠 <code>\</code> 来将其拆分为单独的行。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;This is a long long long long long long long long long \</span><br><span class="line">long long long string.&quot;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 在反斜杠后面不能有任何字符，尤其要注意空白字符，如空格、制表符等。</p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符（运算符）是一个特殊标记，它对一个，两个或三个操作数执行操作，例如加法或减法。后续将给出更为详细的介绍。</p>
<h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><p>分隔符用于分割标记（<code>tokens</code>）。分隔符本身也是一种标记。它们由单个字符组成并代表其自身，C 语言中的分隔符标记包括 <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>&#123;</code>, <code>&#125;</code>, <code>;</code>, <code>,</code>, <code>.</code>, <code>:</code>。空白也是一种分隔符，但它不属于标记。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Lexical-Elements">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Lexical-Elements</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C 程序结构和范围</title>
    <url>/2020/01/C-program-structure-and-scope/</url>
    <content><![CDATA[<p>在之前的几篇关于 C 语言的文章中，我们以及掌握了 C 语言的基本要素，本文主要介绍 C 语言的程序结构和范围。</p>
<a id="more"></a>

<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><p>我们可以将 C 程序写在一个源文件中，然而，更为常见的是将其按照功能模块将其划分到不同的源文件中。</p>
<p>通常，头文件（即以 <code>.h</code> 结尾的文件）包含函数和变量的声明；源文件（即以 <code>.c</code> 结尾的文件）包含相应的定义。如果我们不想某些声明被外部文件访问，那么也可以将声明放在源文件中。</p>
<p>例如，如果我们编写一个求平方根的函数，我们希望可以在定义该函数以外的文件访问，那么我们需要将函数的声明放在头文件中（即以 <code>.h</code> 结尾的文件）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sqrt.h */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span></span><br><span class="line">computeSqrt(<span class="keyword">double</span> x);</span><br></pre></td></tr></table></figure>

<p>该头文件可能包含其它我们需要使用的函数但其定义在不同的源文件中，我们可能不需要知道这些函数的实现。</p>
<p>This header file could be included by other source files which need to use your function, but do not need to know how it was implemented.</p>
<p>上述函数的定义应该在相应的源文件中出现（即以 <code>.c</code> 结尾的文件）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sqrt.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sqrt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span></span><br><span class="line">computeSqrt(<span class="keyword">double</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> result;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>范围是指程序的哪些部分可以“看到”声明的对象。声明的对象可以只在特定的函数中可见、或者是特定的文件、亦或者是包含这个声明的头文件的一系列源文件中（需要使用 <code>extern</code> 声明）。</p>
<p>除非特定说明，在文件的顶层（即不在函数内）进行的声明对整个文件都是可见的，包括从函数内部，但在文件外部不可见；在函数内进行的声明仅在这些函数内可见；此外，声明对之前的声明不可见，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> y = x + <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这样是可以的，但是如下方式则是不行的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = y + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Program-Structure-and-Scope">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Program-Structure-and-Scope</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言类型及存储类限定符</title>
    <url>/2019/06/C-type-and-storage-class-specifiers/</url>
    <content><![CDATA[<p>本文主要介绍 C 语言中的类型及存储类限定符，C 语言中提高了两个类型限定符：<code>const</code> 和 <code>volatile</code>；类型限定符指明了变量的访问方式。存储类限定符则指定了变量在内存中的存储方式，C 语言提供了四种存储类限定符：<code>auto</code>，<code>register</code>，<code>extern</code> 和 <code>static</code>。</p>
<a id="more"></a>

<h2 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h2><p>类型限定符允许您指定变量的访问方式，C 语言提供了两个类型限定符：(a) <code>const</code> 指明变量是只读的，一旦初始化，它的值将不能被改变；(b) <code>volatile</code> 表明变量是显式可变的，并且看似无用的变量访问（例如，通过指针）不应该被优化掉。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.14159f</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">float</span> currentTemperature = <span class="number">40.0</span>;</span><br></pre></td></tr></table></figure>

<p><code>const</code> 限定符除了能防止变量被意外改变之外，它还能辅助编译器进行优化。针对有回调函数或者信号处理函数更新的变量，我们可以将其定义为 <code>volatile</code> 从而避免编译器过度优化导致数据不一致。</p>
<h2 id="存储类限定符"><a href="#存储类限定符" class="headerlink" title="存储类限定符"></a>存储类限定符</h2><p>存储类限定允许您定义变量在内存中的存储方式。<code>auto</code> 关键字用于定义函数内部的局部变量，当函数返回时，这是局部变量（自动变量）将自动被清理掉，这是函数内部的变量默认行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">foo(<span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">int</span> x = value;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>register</code> 关键字定义的变量被称为寄存器变量，它的行为与 <code>auto</code> 定义的变量几乎类似，稍有不同的是，该关键字表明该变量的使用频率极高，如果可能尽量将其放在寄存器中。如果变量被声明为 <code>register</code> 类型，__那么将不能对其进行取地址运算 (<code>&amp;</code>)__。这意味着您不能引用使用存储类寄存器声明的数组的元素。GCC 编译器在优化时可以很好的选择哪些变量使用被保存在寄存器中，因此寄存器变量很少使用。</p>
<p><code>static</code> 限定符与 <code>auto</code> 的作用正好相反：当将 <code>static</code> 应用于函数内部或块内的变量时，即使函数完成或块结束之后，这些变量都将保存其值。这就是所谓的__静态存储持续期 (Static Storage Duration)__。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sum (<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sumSoFar = <span class="number">0</span>;</span><br><span class="line">    sumSoFar = sumSoFar + x;</span><br><span class="line">    <span class="keyword">return</span> sumSoFar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，您还可以在顶层（即不在函数内）将变量（或函数）声明为 <code>static</code>。这些变量（全局变量）仅在当前源文件可见，其它源文件则不可见。这就给 <code>static</code> 带来了双重含义；第二种意义则是__静态链接 (Static Linkage)__。在单独的文件中具有静态链接的两个函数或变量是完全独立的；在声明它的文件之外都不可见。</p>
<p>声明为 <code>extern</code> 的未初始化变量的默认值为 <code>0</code>，<code>0.0</code> 或 <code>NULL</code>，具体值则取决于其类型。声明为 <code>auto</code> 和 <code>register</code> 的未初始化变量保留为初始化状态，因此不应假设这些变量保存特定的值。</p>
<p><code>extern</code> 对于声明要链接到项目的所有源文件可见的变量很有用。变量声明时并不会为其分配存储空间，所以你无法在 <code>extern</code> 声明语句中进行初始化操作。您必须同时进行 <code>extern</code> 声明和非 <code>extern</code> 声明，实际上后者是变量的定义，它将为期分配存储空间。<code>extern</code> 声明语句可以重复多次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> numberOfClients;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> numberOfClients = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Type-Qualifiers">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Type-Qualifiers</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS Mojave 上 GDB 调试配置</title>
    <url>/2019/06/GDB-on-MacOS-Mojave/</url>
    <content><![CDATA[<p>最近在 MacOS 上写代码，需要使用 gdb 进行调试，踩了一些坑，因此在这里做一个简要记录。稍微搜索一下我们就可以知道要在 MacOS 上使用 gdb 需要先创建一个自签名证书（<a href="https://gist.github.com/gravitylow/fb595186ce6068537a6e9da6d8b5b96d">看这里</a>)。</p>
<p>但是我们在 Mojave 上按照文章给出的方式进行，还是出现下面的错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unable to find Mach task port for process-id 432: (os&#x2F;kern) failure (0x5).</span><br><span class="line"> (please check gdb is codesigned - see taskgated(8))</span><br></pre></td></tr></table></figure>

<p>在这个过程中，我还遇到了不能创建系统证书的问题。</p>
<a id="more"></a>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>首先，系统证书的问题可以通过先创建一个登陆证书，然后将其拖拽到系统条目下即可。那么证书的问题就可以解决了，原以为就可以高高兴兴的调试代码了，可是发现还是出现 <code>Unable to find Mach task ...</code> 错误。</p>
<blockquote>
<ol>
<li>Open Keychain Access</li>
<li>In menu, open Keychain Access &gt; Certificate Assistant &gt; Create a certificate</li>
<li>Give it a name (e.g. gdbc)<ul>
<li>Identity type: Self Signed Root</li>
<li>Certificate type: Code Signing</li>
<li>Check: let me override defaults</li>
</ul>
</li>
<li>Continue until “specify a location for…”</li>
<li>Set Keychain location to System</li>
<li>Create certificate and close Certificate Assistant.</li>
<li>Find certificate in System keychain.</li>
<li>Double click certificate</li>
<li>Expand Trust, set Code signing to always trust</li>
<li>Restart taskgated in terminal: <code>killall taskgated</code></li>
</ol>
</blockquote>
<p>实际上我们在上面的步骤 7 是选择的 <code>Login</code> 而非 <code>System</code>，在证书创建成功之后在将其拖拽到 <code>System</code> 类别下的。我只执行到了步骤 10，之后的步骤便没有继续执行。而是使用下面的方式，</p>
<p>原来是代码签署权利的问题。原文如下：</p>
<blockquote>
<p>This is related to codesign entitlements. you must add “com.apple.security.cs.debugger” key in signing process.</p>
<p>for example you must change <code>codesign -fs gdbcert /usr/local/bin/gdb</code> to <code>codesign --entitlements gdb.xml -fs gdbcert /usr/local/bin/gdb</code>.</p>
<p><code>gdb.xml</code> content must something like following code.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">   &lt;key&gt;com.apple.security.cs.debugger&lt;&#x2F;key&gt;</span><br><span class="line">   &lt;true&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>因此，我们在使用 <code>codesign</code> 时采用了如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat gdb.xml</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;com.apple.security.cs.debugger&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;true&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;plist&gt;</span><br><span class="line">$ codesign --entitlements gdb.xml -fs gdbcert &#x2F;usr&#x2F;local&#x2F;bin&#x2F;gdb</span><br></pre></td></tr></table></figure>

<p>按照上面命令执行之后，果然能愉快的使用 gdb 了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://gist.github.com/gravitylow/fb595186ce6068537a6e9da6d8b5b96d">https://gist.github.com/gravitylow/fb595186ce6068537a6e9da6d8b5b96d</a><br>[2] <a href="https://stackoverflow.com/questions/52699661/macos-mojave-how-to-achieve-codesign-to-enable-debugging-gdb">https://stackoverflow.com/questions/52699661/macos-mojave-how-to-achieve-codesign-to-enable-debugging-gdb</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>非超级用户下运行 Solaris SMF 服务</title>
    <url>/2019/10/SMF-on-Solaris-under-non-superuser/</url>
    <content><![CDATA[<p>今天在 Solaris 上遇到一个问题，我需要在非超级用户下运行某个服务。默认情况下，通过 SMF 管理的都是在 root 用户下运行的，但是我们可以通过修改配置文件来使其运行到特定用户下。</p>
<a id="more"></a>

<p>例如，我们有如下一个配置文件（部分）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exec_method</span> <span class="attr">type</span>=<span class="string">&quot;method&quot;</span> <span class="attr">name</span>=<span class="string">&quot;start&quot;</span> <span class="attr">exec</span>=<span class="string">&quot;/path/to/exec_binary <span class="symbol">&amp;amp;</span>&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">method_context</span> <span class="attr">working_directory</span>=<span class="string">&quot;/path/to/work&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">method_environment</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">envar</span> <span class="attr">name</span>=<span class="string">&quot;HOME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/home/path&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">method_environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">method_context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exec_method</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们想要 <code>exec_binary</code> 在 <code>tom</code> 用户下运行，那么我们需要加入 <code>method_credential</code> 元素，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exec_method</span> <span class="attr">type</span>=<span class="string">&quot;method&quot;</span> <span class="attr">name</span>=<span class="string">&quot;start&quot;</span> <span class="attr">exec</span>=<span class="string">&quot;/path/to/exec_binary <span class="symbol">&amp;amp;</span>&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">method_context</span> <span class="attr">working_directory</span>=<span class="string">&quot;/path/to/work&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">method_credential</span> <span class="attr">user</span>=<span class="string">&quot;tom&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">method_environment</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">envar</span> <span class="attr">name</span>=<span class="string">&quot;HOME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/home/path&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">method_environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">method_context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exec_method</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，我们便可以在 <code>tom</code> 用户下运行 <code>exec_binary</code> 的服务了，这里需要注意 <code>method_credential</code> 的位置，它需要位于 <code>method_environment</code> 之前，否则将出现如下问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element method_context: validity error : Element method_context content does not follow the DTD, expecting ((method_profile | method_credential)? , method_environment?), got (method_environment method_credential )</span><br><span class="line">svccfg: Document is not valid.</span><br></pre></td></tr></table></figure>

<p>我们可通过查看 <code>/usr/share/lib/xml/dtd/service_bundle.dtd.1</code> 文件来了解更多的 SMF 配置信息。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.linuxquestions.org/questions/solaris-opensolaris-20/problem-by-validate-a-manefest-file-4175468958/">https://www.linuxquestions.org/questions/solaris-opensolaris-20/problem-by-validate-a-manefest-file-4175468958/</a><br>[2] <a href="https://www.master-tutorial.design/2010/06/credentials-and-projects-for-solaris-10.html">https://www.master-tutorial.design/2010/06/credentials-and-projects-for-solaris-10.html</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Solaris</tag>
      </tags>
  </entry>
  <entry>
    <title>重拾 ARP 协议</title>
    <url>/2019/09/arp-protocol/</url>
    <content><![CDATA[<p>ARP (Address Resolution Protoco)，中文地址解析协议，用来将网络层的 IP 地址转换为数据链路层的物理地址，该协议属于 TCP/IP 协议簇。当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据 48 bit 的以太网地址来确定目的接口的。设备驱动程序从不检查 IP 数据报中的目的 IP 地址。而地址解析为这两种不同的地址形式提供映射: 32 bit 的 IP 地址和数据链路层使用的任何类型的地址。<a href="https://tools.ietf.org/rfc/rfc826.txt">RFC 826</a> 给出了 ARP 协议的规范。ARP 协议为 IP 地址到对应的硬件物理地址提供了动态映射，通常情况下用户或系统管理员不用担心。</p>
<a id="more"></a>

<h2 id="ARP-原理"><a href="#ARP-原理" class="headerlink" title="ARP 原理"></a>ARP 原理</h2><p>我们知道主机之间是通过 IP 地址来进行通信的，而 IP 地址属于网络层，而实际上网络通信需要知道通信设备的硬件地址（即 MAC 地址）。ARP 协议便是做这项工作的。假设我们在局域网中有两台主机 <code>A</code> 和 <code>B</code>，<code>A</code> 想要与 <code>B</code> 进行通信，但是 <code>A</code> 只知道 <code>B</code> 的 IP 地址，其通信的硬件地址查询过程如下：</p>
<ol>
<li>主机 <code>A</code> 首先检测自己的 ARP 缓存中是否包含主机 <code>B</code> 的 IP 与 MAC 地址之间的映射关系。如果存在则可以直接通信；反之，则需要先获取主机 <code>B</code> 的 IP 与 MAC 地址之间的映射关系。</li>
<li>主机 <code>A</code> 的 ARP 缓存中不存在该 IP 地址的映射记录，因此主机 <code>A</code> 需要想局域网广播请求该 IP 对应的 MAC 地址。</li>
<li>局域网内的其它机器在收到该 ARP 请求之后，会获取主机 <code>A</code> 的 IP 地址和 MAC 地址并添加到自己的 ARP 缓存中，若该主机的 IP 地址为 ARP 所请求的 IP 地址，那么它需要发送 ARP 响应包，反之，则忽略该 ARP 请求。</li>
<li>主机 <code>B</code> 在接收到该 ARP 请求之后会将自己的 IP 地址和 MAC 地址填入数据包中并<strong>定向</strong> 发送给主机 <code>A</code>。</li>
<li>主机 <code>A</code> 在接收到主机  <code>B</code> 的 ARP 响应之后使用该包的 IP 和 MAC 地址更新 ARP 缓存。此时，主机 <code>A</code> 和 <code>B</code> 便可以正常通信了。</li>
</ol>
<p>我们可以通过 <code>arp -a</code> 查看当前的 ARP 缓存。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ arp -a</span><br><span class="line">xiaoqiang (192.168.31.1) at 50:64:2b:18:b8:e3 on en0 ifscope [ethernet]</span><br><span class="line">? (192.168.31.29) at e0:6:e6:ca:25:26 on en0 ifscope [ethernet]</span><br><span class="line">? (192.168.31.126) at 40:83:1d:b9:f4:71 on en0 ifscope [ethernet]</span><br><span class="line">? (192.168.31.255) at ff:ff:ff:ff:ff:ff on en0 ifscope [ethernet]</span><br><span class="line">? (224.0.0.251) at 1:0:5e:0:0:fb on en0 ifscope permanent [ethernet]</span><br><span class="line">? (239.255.255.250) at 1:0:5e:7f:ff:fa on en0 ifscope permanent [ethernet]</span><br></pre></td></tr></table></figure>

<h2 id="ARP-报文格式"><a href="#ARP-报文格式" class="headerlink" title="ARP 报文格式"></a>ARP 报文格式</h2><p>在以太网上解析 IP 地址时，ARP 请求和应答的格式如下图所示。</p>
<img src="/2019/09/arp-protocol/arp.png" class="" title="ARP 报文结构">

<ul>
<li>以太网报头中的前两个字段是以太网的目的地址和源地址（即物理地址、MAC 地址）。若目的地址全为 <code>1</code>，这表明其为广播地址。局域网中的所有以太网接口都要接收广播的数据帧。</li>
<li>帧类型则表明后续的数据类型，对于 ARP 请求和应答来说，它为 <code>0x0806</code>。</li>
<li>硬件类型和协议类型用来描述 ARP 分组中的各个字段。 例如，一个 ARP 请求分组询问协议地址（这里是 IP 地址）对应的硬件地址（这里是以太网地址)。硬件类型字段表示硬件地址的类型。它的值为 <code>1</code> 即表示以太网地址。协议类型字段表示要映射的协议地址类型。它的值为 <code>0x0800</code> 即表示 IP 地址。</li>
<li>硬件地址长度和协议地址长度分别指出硬件地址和协议地址的长度，以字节为单位。对于以太网上 IP 地址的 ARP 请求或应答来说，它们的值分别为 <code>6</code> 和 <code>4</code>。</li>
<li>操作字段 <code>op</code> 给出了操作类型，它包含 ARP 请求 （<code>1</code>）、ARP 应答（<code>2</code>）、RARP 请求（<code>3</code>）和 RARP 应答（<code>4</code>）四种操作。</li>
<li>最后四个字段分别是发送端的以太网地址和协议地址以及目的端的以太网地址和协议地址。</li>
</ul>
<h2 id="ARP-请求与响应"><a href="#ARP-请求与响应" class="headerlink" title="ARP 请求与响应"></a>ARP 请求与响应</h2><p>现在我们对 ARP 的工作原理以及报文格式有所了解，接下来就是如何去填充 ARP 报文？当我们请求一个 IP 地址的 MAC 地址时，我们是不知道其 MAC 地址的，即<strong>以太网目的地址__和__目的端以太网地址__，而__以太网源地址__、__发送端以太网地址__、__发送端 IP 地址__以及__目的端 IP 地址__我们是知道的。__op</strong> 字段则是根据 ARP 操作类型进行填充，这里为 ARP 请求，故值为 <code>1</code>。其它五个字段则是固定的，__帧类型__为 <code>0x0806</code>；__硬件类型__为 <code>0x01</code>；__协议类型__为 <code>0x0800</code>；__硬件地址长度__为 <code>6</code>；__协议地址长度__为 <code>4</code>。那么我们该如何填充__以太网目的地址__和__目的端以太网地址__呢？其实它们是相同的。我们需要将其设置为广播地址（<code>0xFF,0xFF, 0xFF,0xFF,0xFF, 0xFF</code>），这样局域网中的每个网络接口都会接收这个数据包并进行处理。</p>
<p>如下图所示，我在主机 <code>lenovo</code> 上通过 <code>arping -I interface 192.168.31.138</code> 向局域网查询 IP 地址为 <code>192.168.31.138</code> 的 MAC 地址，同时在该主机上通过 <code>tcpdum</code> 捕获 ARP 数据包。</p>
<img src="/2019/09/arp-protocol/tcpdump_arp.png" class="" title="ARP 请求响应">

<p>ARP 响应报文则是将 ARP 请求包中的<strong>以太网源地址__设置为响应主机的以太网地址，同时将 ARP 请求报文中的__以太网源地址__设置为响应报文中的__以太网目的地址__，同时需要将 ARP 请求报文中的 __发送端以太网地址__和__发送端 IP 地址__分别设置为 ARP 响应报文中的 __目的端以太网地址__和__目的端 IP 地址__，ARP 请求报文中的 __目的端 IP 地址__设置为 ARP 响应报文的__发送端 IP 地址__，并将该 IP 地址所在网卡的 MAC 地址设置为 ARP 响应报文中的 __发送端以太网地址__，最后更新 __op</strong> 为 <code>2</code>，即 ARP 响应。</p>
<h2 id="免费-ARP"><a href="#免费-ARP" class="headerlink" title="免费 ARP"></a>免费 ARP</h2><p>如果在 ARP 请求报文中的__目的端 IP 地址__和__发送端 IP 地址__相同时会出现什么情况呢？这种情况属于 ARP 的一种特性，即免费 ARP （Gratuitous ARP）。</p>
<p>免费ARP可以有两个方面的作用：</p>
<ol>
<li>一个主机可以通过它来确定另一个主机是否设置了相同的IP地址。</li>
<li>通过发送免费 ARP 来更新局域网中该 IP 地址对应的 MAC 地址，即刷新局域网主机的 ARP 缓存。</li>
</ol>
<p>我们可以通过 <code>arping -I interface -U ipaddress</code> 来发送免费 ARP。</p>
<h2 id="关于-ARP-的编程"><a href="#关于-ARP-的编程" class="headerlink" title="关于 ARP 的编程"></a>关于 ARP 的编程</h2><p>在 Linux 平台上，<code>&lt;netinet/if_ether.h&gt;</code> 头文件中定义了 ARP 地址解析协议的数据结构，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ethernet Address Resolution Protocol.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See RFC 826 for protocol description.  Structure below is adapted</span></span><br><span class="line"><span class="comment"> * to resolving internet addresses.  Field names used correspond to</span></span><br><span class="line"><span class="comment"> * RFC 826.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">ether_arp</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">arphdr</span> <span class="title">ea_hdr</span>;</span>          <span class="comment">/* fixed-size header */</span></span><br><span class="line">        <span class="keyword">uint8_t</span> arp_sha[ETH_ALEN];      <span class="comment">/* sender hardware address */</span></span><br><span class="line">        <span class="keyword">uint8_t</span> arp_spa[<span class="number">4</span>];             <span class="comment">/* sender protocol address */</span></span><br><span class="line">        <span class="keyword">uint8_t</span> arp_tha[ETH_ALEN];      <span class="comment">/* target hardware address */</span></span><br><span class="line">        <span class="keyword">uint8_t</span> arp_tpa[<span class="number">4</span>];             <span class="comment">/* target protocol address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arp_hrd ea_hdr.ar_hrd</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arp_pro ea_hdr.ar_pro</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arp_hln ea_hdr.ar_hln</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arp_pln ea_hdr.ar_pln</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arp_op  ea_hdr.ar_op</span></span><br></pre></td></tr></table></figure>

<p><code>struct arphdr</code> 则定义在 <code>&lt;net/if_arp.h&gt;</code> 头文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ARP protocol opcodes. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARPOP_REQUEST   1               <span class="comment">/* ARP request.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARPOP_REPLY     2               <span class="comment">/* ARP reply.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARPOP_RREQUEST  3               <span class="comment">/* RARP request.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARPOP_RREPLY    4               <span class="comment">/* RARP reply.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARPOP_InREQUEST 8               <span class="comment">/* InARP request.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARPOP_InREPLY   9               <span class="comment">/* InARP reply.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARPOP_NAK       10              <span class="comment">/* (ATM)ARP NAK.  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* See RFC 826 for protocol description.  ARP packets are variable</span></span><br><span class="line"><span class="comment">   in size; the arphdr structure defines the fixed-length portion.</span></span><br><span class="line"><span class="comment">   Protocol type values are the same as those for 10 Mb/s Ethernet.</span></span><br><span class="line"><span class="comment">   It is followed by the variable-sized fields ar_sha, arp_spa,</span></span><br><span class="line"><span class="comment">   arp_tha and arp_tpa in that order, according to the lengths</span></span><br><span class="line"><span class="comment">   specified.  Field names used correspond to RFC 826.  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arphdr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> ar_hrd;          <span class="comment">/* Format of hardware address.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> ar_pro;          <span class="comment">/* Format of protocol address.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ar_hln;               <span class="comment">/* Length of hardware address.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ar_pln;               <span class="comment">/* Length of protocol address.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> ar_op;           <span class="comment">/* ARP opcode (command).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">/* Ethernet looks like this : This bit is variable sized</span></span><br><span class="line"><span class="comment">       however...  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> __ar_sha[ETH_ALEN];   <span class="comment">/* Sender hardware address.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> __ar_sip[<span class="number">4</span>];          <span class="comment">/* Sender IP address.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> __ar_tha[ETH_ALEN];   <span class="comment">/* Target hardware address.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> __ar_tip[<span class="number">4</span>];          <span class="comment">/* Target IP address.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>而以太网首都则定义在 <code>&lt;net/ethernet.h&gt;</code> 头文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is a name for the 48 bit ethernet address available on many</span></span><br><span class="line"><span class="comment">   systems.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ether_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span> ether_addr_octet[ETH_ALEN];</span><br><span class="line">&#125; __attribute__ ((__packed__));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 10Mb/s ethernet header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ether_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span>  ether_dhost[ETH_ALEN];       <span class="comment">/* destination eth addr */</span></span><br><span class="line">  <span class="keyword">uint8_t</span>  ether_shost[ETH_ALEN];       <span class="comment">/* source ether addr    */</span></span><br><span class="line">  <span class="keyword">uint16_t</span> ether_type;                  <span class="comment">/* packet type ID field */</span></span><br><span class="line">&#125; __attribute__ ((__packed__));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ethernet protocol ID&#x27;s */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_PUP           0x0200          <span class="comment">/* Xerox PUP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_SPRITE        0x0500          <span class="comment">/* Sprite */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_IP            0x0800          <span class="comment">/* IP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_ARP           0x0806          <span class="comment">/* Address resolution */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_REVARP        0x8035          <span class="comment">/* Reverse ARP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_AT            0x809B          <span class="comment">/* AppleTalk protocol */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_AARP          0x80F3          <span class="comment">/* AppleTalk ARP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_VLAN          0x8100          <span class="comment">/* IEEE 802.1Q VLAN tagging */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_IPX           0x8137          <span class="comment">/* IPX */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_IPV6          0x86dd          <span class="comment">/* IP protocol version 6 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_LOOPBACK      0x9000          <span class="comment">/* used to test interfaces */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_ADDR_LEN  ETH_ALEN                 <span class="comment">/* size of ethernet addr */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_TYPE_LEN  2                        <span class="comment">/* bytes in type field */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_CRC_LEN   4                        <span class="comment">/* bytes in CRC field */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_HDR_LEN   ETH_HLEN                 <span class="comment">/* total octets in header */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_MIN_LEN   (ETH_ZLEN + ETHER_CRC_LEN) <span class="comment">/* min packet length */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_MAX_LEN   (ETH_FRAME_LEN + ETHER_CRC_LEN) <span class="comment">/* max packet length */</span></span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://tools.ietf.org/rfc/rfc826.txt">https://tools.ietf.org/rfc/rfc826.txt</a><br>[2] <a href="http://docs.52im.net/extend/docs/book/tcpip/vol1/4/">TCP/IP 详解，卷 1： 协议 - 第 4 章 ARP 地址解析协议</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>ARP</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 系统 DNS 服务器配置</title>
    <url>/2018/09/configure-dns-on-ubuntu/</url>
    <content><![CDATA[<p>域名系统 (Domain Name System, DNS) 是为连接到互联网或专用网络的计算机、服务或其他资源提供的一个分散且分级的命名系统。他可以理解为域名和 IP 地址相互映射的一个分布式数据库，通过域名系统，用户可以使用相对容易记忆的域名来访问互联网，而不用去记忆难以理解的 IP 字符串，由域名到 IP 地址转换的过程则被叫做域名解析。下图给出了一个典型的域名分级系统 (图片来源于维基百科)。</p>
<img src="/2018/09/configure-dns-on-ubuntu/Domain_name_space.png" class="" title="Domain name space">

<a id="more"></a>

<p>在 Ubuntu 平台，我目前所了解到的 DNS 的配置主要有两种方式 (配置文件修改)：网络配置文件 interfaces 和域名解析配置文件 resolvconf。</p>
<h3 id="网络配置文件"><a href="#网络配置文件" class="headerlink" title="网络配置文件"></a>网络配置文件</h3><p>若是通过网络配置文件修改 DNS，那么我们只需要在 /etc/network/interfaces 文件中加入 nameserver 即可，如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dns-nameserver 114.114.114.114</span><br><span class="line">dns-nameservers 8.8.8.8 8.8.4.4</span><br></pre></td></tr></table></figure>

<p>dns-nameserver: 用于添加一个域名服务器，如果需要指定多个域名服务器则需要使用添加多行。<br>dns-nameservers: 用于同时指定多个域名服务器地址，用空格隔开。</p>
<p>通过这种方式修改 DNS 后需要重启电脑方可生效。</p>
<h3 id="域名解析配置文件"><a href="#域名解析配置文件" class="headerlink" title="域名解析配置文件"></a>域名解析配置文件</h3><p>Ubuntu 系统提供了 resolvconf 工具来管理其域名信息，其配置文件为在 /etc/resolvconf/resolv.conf.d/ 目录下，通过修改该目录下的 head 文件，我们可以添加特定的域名服务器。例如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 8.8.4.4</span><br></pre></td></tr></table></figure>

<p>在该文件中，每个域名服务器的地址单独一行，不能同时在一行上指定多个域名服务器。修改成功后，我们只需要运行 <code>sudo resolvconf -u</code> 更新 /etc/resolv.conf 文件即可。这种方式不需要重启电脑。此外，我们也可以直接在 /etc/resolv.conf 文件中添加域名服务器，但是这种方式添加的域名服务器在系统重启之后将失效，这是因为 /etc/resolv.conf 文件是由 resolvconf 命令生成的，重启后该文件将被重写。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS 上创建 U 盘启动器</title>
    <url>/2020/07/create-u-bootloader-on-macos/</url>
    <content><![CDATA[<p>本文记载了如何在 MacOS 平台制作 U 盘安装镜像，这里主要使用到了 hdiutil，diskutil 和 dd 三个命令。</p>
<a id="more"></a>

<p>我们在官网现在的镜像大都是以 iso 结尾的文件，例如，本文中使用的 ubuntu-16.04-server-amd64.iso 镜像，在 Linux 平台，我们可以直接使用 dd 将这个镜像写到 U 盘上即可作为启动盘，但是在 MacOS 平台上，则需要将 iso 文件转换为 dmg 格式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hdiutil convert -format UDRW ubuntu-16.04-server-amd64.iso -o ubuntu-16.04-server-amd64.img</span></span><br><span class="line">Reading Master Boot Record (MBR : 0)…</span><br><span class="line">Reading Ubuntu-Server 18.04.4 LTS arm64  (Apple_ISO : 1)…</span><br><span class="line">Reading  (Type CD : 2)…</span><br><span class="line">....................................................................................................</span><br><span class="line">Reading  (Type EF : 3)…</span><br><span class="line">....................................................................................................</span><br><span class="line">Elapsed Time:  2.094s</span><br><span class="line">Speed: 454.9Mbytes/sec</span><br><span class="line">Savings: 0.0%</span><br><span class="line">created: /Users/japin/Downloads/ubuntu-18.04.4-server-arm64.img.dmg</span><br></pre></td></tr></table></figure>

<p>从上面的命令我们可以看到，文件将自动加上 dmg 后缀。上面的命令将 ubuntu-16.04-server-amd64.iso 镜像转换为 UDRW 格式并存储到 ubuntu-16.04-server-amd64.img.dmg 文件中。</p>
<p>接下来我们通过 diskutil 命令查看当前 U 盘的位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> diskutil list</span></span><br><span class="line">/dev/disk0 (internal, physical):</span><br><span class="line"><span class="meta">   #</span><span class="bash">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class="line">   0:      GUID_partition_scheme                        *251.0 GB   disk0</span><br><span class="line">   1:                        EFI EFI                     314.6 MB   disk0s1</span><br><span class="line">   2:                 Apple_APFS Container disk1         250.7 GB   disk0s2</span><br><span class="line"></span><br><span class="line">/dev/disk1 (synthesized):</span><br><span class="line"><span class="meta">   #</span><span class="bash">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class="line">   0:      APFS Container Scheme -                      +250.7 GB   disk1</span><br><span class="line">                                 Physical Store disk0s2</span><br><span class="line">   1:                APFS Volume Macintosh HD            11.1 GB    disk1s1</span><br><span class="line">   2:                APFS Volume Macintosh HD - Data     76.8 GB    disk1s2</span><br><span class="line">   3:                APFS Volume Preboot                 81.3 MB    disk1s3</span><br><span class="line">   4:                APFS Volume Recovery                528.1 MB   disk1s4</span><br><span class="line">   5:                APFS Volume VM                      3.2 GB     disk1s5</span><br><span class="line"></span><br><span class="line">/dev/disk2 (external, physical):</span><br><span class="line"><span class="meta">   #</span><span class="bash">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class="line">   0:     Apple_partition_scheme                        *8.1 GB     disk2</span><br><span class="line">   1:        Apple_partition_map                         4.1 KB     disk2s1</span><br><span class="line">   2:                  Apple_HFS                         2.5 MB     disk2s2</span><br></pre></td></tr></table></figure>

<p>可以看到，我们的 U 盘对应的是 <code>/dev/disk2</code>，使用下面的命令卸载 U 盘。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> diskutil unmountDisk /dev/disk2</span></span><br><span class="line">Unmount of all volumes on disk2 was successful</span><br></pre></td></tr></table></figure>

<p>最后，使用 dd 命令将其写入到 U 盘中，这里需要注意我们的 U 盘设备名应使用 <code>/dev/rdisk2</code>，即在 <code>/dev/disk2</code> 的磁盘名前面加上 <code>r</code> 字母。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dd <span class="keyword">if</span>=ubuntu-18.04.4-server-arm64.img.dmg of=/dev/rdisk2 bs=1m</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 数据库跨库查询</title>
    <url>/2019/05/cross-database-querying-in-postgresql/</url>
    <content><![CDATA[<p>PostgreSQL 数据库默认情况下是不支持跨数据库访问的。如果我们想要执行跨数据库的查询，我们需要借助 dblink 来实现，dblink 是 PostgreSQL 的一个模块，支持从数据库会话中连接到其他数据库。</p>
<a id="more"></a>

<h2 id="安装-dblink"><a href="#安装-dblink" class="headerlink" title="安装 dblink"></a>安装 dblink</h2><p>通过 <code>CREATE EXTENSION dblink;</code> 即可安装 dblink。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# CREATE EXTENSION dblink;</span><br><span class="line">CREATE EXTENSION</span><br></pre></td></tr></table></figure>
<p>dblink 提供了一系列函数用于访问远端数据库，具体的可以参看 <a href="https://www.postgresql.org/docs/10/dblink.html">PostgreSQL dblink</a> 文档。</p>
<h2 id="本地跨库访问"><a href="#本地跨库访问" class="headerlink" title="本地跨库访问"></a>本地跨库访问</h2><p>为了演示本地跨库访问，我们首先在 <code>postgres</code> 中建立 <code>userinfo</code> 表，随后在本地新建一个 <code>localdb</code> 数据库，并在其中建立一个 <code>local_test</code> 数据表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# CREATE TABLE userinfo (id int primary key, name text);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres&#x3D;# INSERT INTO userinfo VALUES (1, &#39;Eric&#39;), (2, &#39;Tom&#39;);</span><br><span class="line">INSERT 0 2</span><br><span class="line">postgres&#x3D;# SELECT * FROM userinfo;</span><br><span class="line"> id | name</span><br><span class="line">----+------</span><br><span class="line">  1 | Eric</span><br><span class="line">  2 | Tom</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# CREATE DATABASE localdb;</span><br><span class="line">CREATE DATABASE</span><br><span class="line">postgres&#x3D;# \c localdb</span><br><span class="line">You are now connected to database &quot;localdb&quot; as user &quot;japin&quot;.</span><br><span class="line">localdb&#x3D;# CREATE TABLE local_test (id serial primary key, ival int default 0, create_time timestamptz not null default now());</span><br><span class="line">CREATE TABLE</span><br><span class="line">localdb&#x3D;# INSERT INTO local_test(ival) VALUES (1), (2), (3), (4);</span><br><span class="line">INSERT 0 4</span><br><span class="line">localdb&#x3D;# SELECT * FROM local_test;</span><br><span class="line"> id | ival |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 |    1 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  2 |    2 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  3 |    3 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  4 |    4 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">(4 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时，如果我想在 <code>postgres</code> 数据库中查询 <code>local_test</code> 表，就需要使用到 dblink 来访问了。首先，我们通过 <code>dblink_connect</code> 创建一个连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# SELECT dblink_connect(&#39;local_dblink_test&#39;, &#39;dbname&#x3D;localdb&#39;);</span><br><span class="line"> dblink_connect</span><br><span class="line">----------------</span><br><span class="line"> OK</span><br><span class="line">(1 row)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>随后，我们就可以通过 dblink 执行查询了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# SELECT * FROM dblink(&#39;local_dblink_test&#39;, &#39;SELECT * FROM local_test;&#39;) AS lt(id int, ival int, create_time timestamptz);</span><br><span class="line"> id | ival |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 |    1 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  2 |    2 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  3 |    3 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  4 |    4 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">(4 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，我们也可以将返回结果与本库中的表进行联合查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# SELECT u.id, name, create_time FROM userinfo u JOIN dblink(&#39;local_dblink_test&#39;, &#39;SELECT * FROM local_test;&#39;) AS lt(id int, ival int, create_time timestamptz) on u.id &#x3D; lt.id;</span><br><span class="line"> id | name |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 | Eric | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  2 | Tom  | 2019-05-09 15:03:44.701121+08</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了方便，我们可以为 <code>dblink</code> 的执行创建一个视图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# CREATE VIEW v_localdb_test AS SELECT * FROM dblink(&#39;local_dblink_test&#39;, &#39;SELECT * FROM local_test;&#39;) AS lt(id int, ival int, create_time timestamptz);</span><br><span class="line">CREATE VIEW</span><br><span class="line">postgres&#x3D;# SELECT * FROM v_localdb_test ;</span><br><span class="line"> id | ival |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 |    1 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  2 |    2 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  3 |    3 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  4 |    4 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">(4 rows)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# SELECT u.id, name, create_time FROM userinfo u JOIN v_localdb_test v ON u.id &#x3D; v.id;</span><br><span class="line"> id | name |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 | Eric | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  2 | Tom  | 2019-05-09 15:03:44.701121+08</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 在 <code>local_test</code> 表中 <code>id</code> 字段类型为 <code>serial</code>，但是在通过 <code>dblink</code> 查询时返回的结果类型不能使用 <code>serial</code> 类型。</p>
<h2 id="远端跨库访问"><a href="#远端跨库访问" class="headerlink" title="远端跨库访问"></a>远端跨库访问</h2><p>上面我们介绍了 PostgreSQL 如何在本地进行跨库访问，其实远端跨库访问本质也是类似的，只不过在配置 <code>dblink_connect</code> 连接参数时需要指明远端数据库的地址、端口、用户名和密码等信息。</p>
<p>我们在远端创建一个 <code>remotedb</code> 数据库，并在该数据库中创建一个 <code>remote_test</code> 表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# create database remotedb;</span><br><span class="line">CREATE DATABASE</span><br><span class="line">postgres&#x3D;# \c remotedb</span><br><span class="line">remotedb&#x3D;# CREATE TABLE remote_test (id serial primary key, ival int not null default 0, create_time timestamptz default now());</span><br><span class="line">CREATE TABLE</span><br><span class="line">remotedb&#x3D;# INSERT INTO remote_test(ival) values (1),(2),(3),(4),(5);</span><br><span class="line">INSERT 0 5</span><br><span class="line">remotedb&#x3D;# SELECT * FROM remote_test;</span><br><span class="line"> id | ival |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 |    1 | 2019-05-09 07:34:42.599409+00</span><br><span class="line">  2 |    2 | 2019-05-09 07:34:42.599409+00</span><br><span class="line">  3 |    3 | 2019-05-09 07:34:42.599409+00</span><br><span class="line">  4 |    4 | 2019-05-09 07:34:42.599409+00</span><br><span class="line">  5 |    5 | 2019-05-09 07:34:42.599409+00</span><br><span class="line">(5 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着，我们在本地通过 dblink 进行连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# SELECT dblink_connect(&#39;remote_dblink_test&#39;, &#39;dbname&#x3D;remotedb hostaddr&#x3D;10.9.10.24 port&#x3D;5432 user&#x3D;postgres password&#x3D;postgres&#39;);</span><br><span class="line"> dblink_connect</span><br><span class="line">----------------</span><br><span class="line"> OK</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# SELECT * FROM dblink(&#39;remote_dblink_test&#39;, &#39;SELECT * FROM remote_test;&#39;) AS t(id int, ival int, create_time timestamptz);</span><br><span class="line"> id | ival |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 |    1 | 2019-05-09 15:34:42.599409+08</span><br><span class="line">  2 |    2 | 2019-05-09 15:34:42.599409+08</span><br><span class="line">  3 |    3 | 2019-05-09 15:34:42.599409+08</span><br><span class="line">  4 |    4 | 2019-05-09 15:34:42.599409+08</span><br><span class="line">  5 |    5 | 2019-05-09 15:34:42.599409+08</span><br><span class="line">(5 rows)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# SELECT u.id, name, create_time FROM userinfo u JOIN dblink(&#39;remote_dblink_test&#39;, &#39;SELECT * FROM remote_test;&#39;) AS t(id int, ival int, create_time timestamptz) ON u.id &#x3D; t.id;</span><br><span class="line"> id | name |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 | Eric | 2019-05-09 15:34:42.599409+08</span><br><span class="line">  2 | Tom  | 2019-05-09 15:34:42.599409+08</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="关闭-dblink"><a href="#关闭-dblink" class="headerlink" title="关闭 dblink"></a>关闭 dblink</h2><p>最后，当不需要在使用 dblink 访问外部数据库时，我们需要使用 <code>dblink_disconnect</code> 来关闭连接。首先，我们通过 <code>dblink_get_connections</code> 来查看现有的 dblink 连接，随后将其关闭。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# SELECT dblink_get_connections();</span><br><span class="line">         dblink_get_connections</span><br><span class="line">----------------------------------------</span><br><span class="line"> &#123;local_dblink_test,remote_dblink_test&#125;</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# SELECT dblink_disconnect(&#39;remote_dblink_test&#39;);</span><br><span class="line"> dblink_disconnect</span><br><span class="line">-------------------</span><br><span class="line"> OK</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# SELECT dblink_disconnect(&#39;local_dblink_test&#39;);</span><br><span class="line"> dblink_disconnect</span><br><span class="line">-------------------</span><br><span class="line"> OK</span><br><span class="line">(1 row)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/11/dblink.html">https://www.postgresql.org/docs/11/dblink.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>dblink</tag>
      </tags>
  </entry>
  <entry>
    <title>列存数据库 cstore_fdw 的实现</title>
    <url>/2018/10/cstore-fdw-implementation/</url>
    <content><![CDATA[<p>在<a href="/2018/09/introduction-cstore-fdw-columnar-store/" title="上一篇">上一篇</a>中我介绍了如何安装和使用列存数据库 cstore_fdw。接着，我将在本篇中介绍 cstore_fdw 是如何实现的。</p>
<p>Cstore_fdw 是基于 PostgreSQL 开发的一款列存数据库，它采用 ORC 作为低层的物理存储格式 (有部分改动)，使用 protobuf 进行序列化并采用 PostgreSQL 外部插件的形式集成到数据库中。Cstore_fdw 包含 3 个头文件以及 5 个源文件：</p>
<ul>
<li>__cstore_compression.c__ - 该文件包含 cstore_fdw 使用的压缩和解压缩的算法实现。</li>
<li>__cstore_fdw.c__ - 该文件包含列存扫描、分析以及复制数据到 cstore_fdw 外部表的函数的定义。它使用了 cstore_reader 和 cstore_writer 提供的 API 接口来读写 cstore 文件。</li>
<li>__cstore_fdw.h__ - 该文件包含 cstore_fdw 使用的类型及函数声明。</li>
<li><strong>cstore_metadata_serialization.c</strong> - 该文件包含 cstore_fdw 序列化和反序列化元数据的函数的实现。</li>
<li><strong>cstore_metadata_serialization.h</strong> - 该文件包含 cstore_fdw 序列化和反序列化元数据的函数的声明。</li>
<li>__cstore_reader.c__ - 该文件包含读取 cstore 文件的函数定义。它包括读取文件元数据，row stripes 以及跳跃不相关的数据块或列数据。</li>
<li><strong>cstore_version_compat.h</strong> - 该文件包含用于编写与 PostgreSQL 版本无关的代码宏。</li>
<li>__cstore_writer.c__ - 该文件包含写入 cstore 文件的函数定义。它包括写入文件元数据，row stripes 以及计算跳跃块节点信息。</li>
</ul>
<a id="more"></a>

<h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>Cstore_fdw 使用表数据文件 (Table Data File) 和表页脚文件 (Table Footer File) 来管理列存数据。</p>
<ul>
<li><strong>表数据文件</strong> - 该文件包含表数据以及用于执行 WHERE 查询时所用到的跳跃块信息。如果为外部表指定了 <code>filename</code> 参数，那么数据文件则存储在该参数指定的位置。否则，他将采用 <code>$PGDATA/$dboid/$relfilenode</code> 的路径进行存储。</li>
<li><strong>表页脚文件</strong> - 该文件包含每个 stripe 在表数据文件中的偏移位置及其长度。它的存储路径则是在表数据文件后添加 <code>.footer</code> 后缀。</li>
</ul>
<h3 id="表页脚文件"><a href="#表页脚文件" class="headerlink" title="表页脚文件"></a>表页脚文件</h3><p>表页脚文件同样由三个部分组成，它们是 Table Footer，Postscript 和 Postscript Size。</p>
<ul>
<li><strong>Table Footer</strong> - 该部分包含每个 stripe 的文件偏移位置以及不同部分的长度。我们可以使用这些信息来读取 stripe 结构。</li>
<li><strong>Postscript</strong> - 该部分包含 table footer 的长度以及签名和版本信息。</li>
<li><strong>Postscript Size</strong> - 表页脚文件的最后一个字节用于读取 postscript 结构。</li>
</ul>
<p>我们可以在 <a href="https://github.com/citusdata/cstore_fdw/blob/master/cstore_fdw.h">cstore_fdw.h</a> 文件和 <a href="https://github.com/citusdata/cstore_fdw/blob/master/cstore.proto">cstore.proto</a> 文件中查看该文件的物理布局。图 1 展示了包含四个 stripe 结构的表页脚的物理布局结构。</p>
<img src="/2018/10/cstore-fdw-implementation/Physical-of-Table-Footer.svg" class="" title="The Physical Layout of Table Footer">
<p style="text-align:center">图 1 表页脚的物理布局</p>

<h3 id="表数据文件"><a href="#表数据文件" class="headerlink" title="表数据文件"></a>表数据文件</h3><p>Cstore_fdw 中数据被划分为单个的 row stripe 结构并存储在表数据文件中，每个 row stripe 中包含的行数可以通过 <code>stripe_row_count</code> 参数进行修改，每个 stripe 包含下面三个部分：</p>
<ul>
<li><strong>Stripe Skip List</strong> - 该部分包含 stripe 中每个列数据块的统计信息 (最大值、最小值以及位置信息，参考 <a href="https://github.com/citusdata/cstore_fdw/blob/master/cstore_fdw.h">cstore_fdw.h</a> 中的定义)。我们可以通过这是信息来执行 WHERE 条件的过滤从而避免读取不必要的数据块。</li>
<li><strong>Stripe Data</strong> - 在列数据块中我们存储两个内容： “exists” 和 “value”。其中 “exists” 是一个布尔数组，它表明哪些值不为 NULL，而 “value” 数组则包含不为 NULL 的数据。如果使用了压缩，那么 “value” 的内容将会被压缩后在存储。我们可以使用 <code>compression=pglz</code> 来启用压缩。Cstore_fdw 使用 PostgreSQL 中的 Datum 结构来表示磁盘上的数据值。</li>
<li><strong>Stripe Footer</strong> - 该部分包含 stripe skip list 和 stripe data 的数据长度。</li>
</ul>
<p>图 2 给出了 cstore_fdw 中表数据文件的物理布局。</p>
<img src="/2018/10/cstore-fdw-implementation/Physical-of-Table-Data.svg" class="" title="The Physical Layout of Table Data">
<p style="text-align:center">图 2 表数据的物理布局</p>

<p>正如上文所述，表数据文件被划分为 stripe 结构，而 strip 内部又由 skip list，stripe data 和 stripe footer 组成。然而在 skip list 和 stripe data 内部则是由每个属性列组成，并且每个属性列又被划分为 block 结构。Skip list 中包含 block skip node 用于执行过滤，从而跳过不相关的数据块。Stripe data 则将数据进一步划分为 exists block 和 values block，它们分别存储属性值存储标志和属性值。</p>
<h2 id="列存读写实现"><a href="#列存读写实现" class="headerlink" title="列存读写实现"></a>列存读写实现</h2><p>Cstore_fdw 在读写数据文件分为两个步骤：(a) 读写表页脚文件；(b) 读写表数据文件。本节主要介绍 cstore_fdw 的读写实现。</p>
<h3 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h3><p>Cstore_fdw 在写入数据时通过 TableStateWrite 结构维护数据写入状态，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TableWriteState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        FILE *tableFile;                     <span class="comment">/* 数据文件描述符 */</span></span><br><span class="line">        TableFooter *tableFooter;            <span class="comment">/* 表页脚文件结构 */</span></span><br><span class="line">        StringInfo tableFooterFilename;      <span class="comment">/* 表页脚文件名称 */</span></span><br><span class="line">        CompressionType compressionType;     <span class="comment">/* 压缩类型，用于压缩数据值 */</span></span><br><span class="line">        TupleDesc tupleDescriptor;           <span class="comment">/* 元组描述符 */</span></span><br><span class="line">        FmgrInfo **comparisonFunctionArray;  <span class="comment">/* 压缩函数数组 */</span></span><br><span class="line">        uint64 currentFileOffset;            <span class="comment">/* 当前文件写入的偏移位置 */</span></span><br><span class="line">        Relation relation;                   <span class="comment">/* 当前关系表结构 */</span></span><br><span class="line"></span><br><span class="line">        MemoryContext stripeWriteContext;    <span class="comment">/* Stripe 内存管理句柄 */</span></span><br><span class="line">        StripeBuffers *stripeBuffers;        <span class="comment">/* 用于存储 stripe data 数据 */</span></span><br><span class="line">        StripeSkipList *stripeSkipList;      <span class="comment">/* 跳跃表信息 */</span></span><br><span class="line">        uint32 stripeMaxRowCount;            <span class="comment">/* Stripe 最大的行记录数 */</span></span><br><span class="line">        ColumnBlockData **blockDataArray;    <span class="comment">/* 当前 stripe 每个列的 block 信息 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * compressionBuffer 用于进行压缩时的临时存储，将它放至在这里主要是为了</span></span><br><span class="line"><span class="comment">         * 减小内存的分配，它位于 stripeWriteContext 内存上下文并且在该内存上下</span></span><br><span class="line"><span class="comment">         * 文重置时被删除。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        StringInfo compressionBuffer;</span><br><span class="line">&#125; TableWriteState;</span><br></pre></td></tr></table></figure>

<p>假设我们有一个名为 test 的数据表，其中包含两个属性，cstore_fdw 在执行 COPY 命令导入数据时会先执行 <code>CStoreBeginWrite()</code> 函数来初始化 TableWriteState 结构。图 3 给出了 TableWriteState 的逻辑结构。</p>
<img src="/2018/10/cstore-fdw-implementation/Logical-of-TableWriteState.svg" class="" title="The Logical Layout of TableWriteState">
<p style="text-align:center">图 3 TableWriteState 的逻辑结构</p>

<p><code>CStoreBeginWrite()</code> 函数的执行主要分为以下四个步骤：</p>
<ol>
<li>检测表页脚文件是否存在。如果存在，则将其内容读取出来并反序列化到 TableFooter 对象中；反之，若是不存在该文件，说明是第一次向表中插入数据，cstore_fdw 则在内存中创建一个新的 TableFooter 对象。其实在构造 TableFooter 之前，cstore_fdw 会根据表页脚文件的存在与否来决定表数据文件的打开方式。</li>
<li>从 tableFooter-&gt;stripMetadataList 中读取当前表数据文件的写入位置，并将表数据文件的文件写入指针移动到该位置，即读取最后一个 StripeMetadata 并将四个成员相加从而计算下个 stripe 应该写入的位置。</li>
<li>遍历所有的列并获取该列的压缩算法。</li>
<li>创建 stripe 内存上下文，在此之后，所有的列存相关的内存分配都在该内存上下文上进行分配，以便进行内存管理。同时我们需要为每个列新建 ColumnBlockData 对象用于存储插入的值，详细见 <code>CreateEmptyBlockDataArray()</code> 函数。</li>
</ol>
<p>在初始化 TableWriteState 完成之后，我们就需要向列存写入数据了，cstore_fdw 通过 <code>CStoreWriteRow()</code> 函数来实现该功能，其执行过程如下：</p>
<ol>
<li>检测 TableWriteState-&gt;stripeBuffers 是否为空。若为空，则调用 <code>CreateEmptyStripeBuffers()</code> 函数和 <code>CreateEmptyStripeSkipList()</code> 函数为每个列创建 ColumnBuffers 对象和 ColumnBlockSkipNode 对象。</li>
<li>遍历所有属性列并如果该属性列为空则设置 existsArray 中对应的值为 false；反之则调用 <code>SerializeSingleDatum()</code> 函数将值序列化到 valueBuffer 中，同时它将调用 <code>UpdateBlockSkipNodeMinMax()</code> 函数更新当前数据块中的最大值、最小值的统计信息。</li>
<li>判断当前数据块是否已满。若当前数据块已满，则调用 <code>SerializeBlockData()</code> 函数对当前数据块进行序列化。该函数内部首先将所有列的 exists 信息分别序列化到对应的 ColumnBlockBuffers 中的 existsBuffer 中，随后将所有列的 values 信息分别序列化到对应的 ColumnBlockBuffers 中的 valueBuffer 中。需要注意的是，在序列化属性值的时候，将根据属性列是否可以压缩来对其进行数据压缩。</li>
<li>最后，检查当前 stripe 的行记录数是否已经达到 stripe 可容纳的最大行记录数。若是则调用 <code>FlushStrip()</code> 函数将当前 stripe 刷到磁盘，并在 TableFooter 中新增一条 stripeMetadata 元数据；反之则进行下一条记录的写入操作。</li>
</ol>
<p>当所有记录通过 <code>CStoreWriteRow()</code> 函数写入到列存数据库中后，cstore_fdw 将通过 <code>CStoreEndWrite()</code> 函数来执行最后的清理动作。该函数主要进行以下工作：</p>
<ol>
<li>如果 stripe 不为空，则将 stripe 信息刷写到磁盘。</li>
<li>将数据文件内容同步到磁盘（stripe 信息的刷写可能只是到达了磁盘驱动的缓存中，而并没有实际落盘）。</li>
<li>创建临时文件刷写 TableFooter 信息，当 TableFooter 落盘成功后重名该文件为标准的表页脚文件名。</li>
</ol>
<p>至此，整个 cstore_fdw 的数据写入过程就介绍完毕了，接下来我们将介绍其数据读取部分的实现。</p>
<h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><p>同样，cstore_fdw 在读取数据时也通过一个名为 TableReadState 的结构来维护数据读取的相关信息，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct TableReadState</span><br><span class="line">&#123;</span><br><span class="line">    FILE *tableFile;</span><br><span class="line">    TableFooter *tableFooter;</span><br><span class="line">    TupleDesc tupleDescriptor;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 指向查询中的列的 Var 指针，使用它来获取投影的列</span><br><span class="line">     *&#x2F;</span><br><span class="line">    List *projectedColumnList;</span><br><span class="line"></span><br><span class="line">    List *whereClauseList;                 &#x2F;* 过滤条件 *&#x2F;</span><br><span class="line">    MemoryContext stripeReadContext;</span><br><span class="line">    StripeBuffers *stripeBuffers;          &#x2F;* Stripe 对象 *&#x2F;</span><br><span class="line">    uint32 readStripeCount;</span><br><span class="line">    uint64 stripeReadRowCount;             &#x2F;* 已经读取的行记录数（当前 stripe 中）*&#x2F;</span><br><span class="line">    ColumnBlockData **blockDataArray;</span><br><span class="line">    int32 deserializedBlockIndex;          &#x2F;* 当前反序列化的数据块编号 *&#x2F;</span><br><span class="line">&#125; TableReadState;</span><br></pre></td></tr></table></figure>

<p>当我们从 cstore_fdw 中读取数据时，首先需要通过 <code>CStoreBeginRead()</code> 函数来初始化 TableReadState 结构，随后调用 <code>CStoreReadNextRow()</code> 函数读取行记录，最后通过 <code>CStoreEndRead()</code> 函数进行清理工作。上述函数均依赖 TableReadState 结构来维护当前读取的信息。图 4 给出了 TableReadState 的逻辑结构。</p>
<img src="/2018/10/cstore-fdw-implementation/Logical-of-TableReadState.svg" class="" title="The Logical Layout of TableReadState">
<p style="text-align:center">图 4 TableReadState 的逻辑结构</p>

<p><code>CStoreBeginRead()</code> 函数主要负责初始化工作，它返回的 TableReadState 结构将用于整个读取过程。该函数的执行步骤如下：</p>
<ol>
<li>尝试从表页脚文件中读取 TableFooter 信息。函数 <code>CStoreReadFooter()</code> 用于读取表页脚文件，该函数首先读取文件的最后一个字节作为 postcript 的长度；随后对去 postscript 信息并通过 <code>DeserializePostScript()</code> 函数进行反序列化并校验其是否被修改，然后返回 TableFooter 信息的长度；最后将文件中的 TableFooter 信息通过 <code>DescrializeTableFooter()</code> 函数反序列化到 TableReadState-&gt;tableFooter 结构中。</li>
<li>打开表数据文件并创建 stripeReadContext 内存上下文。</li>
<li>由 <code>ProjectedColumnMask()</code> 函数根据 projectedColumnList 参数获取投影列信息，并使用 <code>CreateEmptyBlockDataArray()</code> 函数为所有投影的列新建 ColumnBlockData 对象。</li>
<li>最后，初始化反序列的数据块索引、当前 stripe 已读的行数、已读取的 stripe 数量等信息并返回 TableReadState 结构。</li>
</ol>
<p>接着，cstore_fdw 将通过 <code>CStoreReadNextRow()</code> 函数读取行记录。函数在成功读取到行数据时会将返回 true 并将数据通过参数的形式返回；若没有更多的记录可读，函数将返回 false。该函数的执行过程如下：</p>
<ol>
<li>首先判断 TableReadState-&gt;stripeBuffers 是否为空。若为空，则说明没有载入 stripe 信息，因此需要载入一个非空的 stripe 以便读取数据。如果当前读取的 stripe 编号与 TableFooter 中记录的 stripeMetadata 的数量相等，则说明没有可读的 stripe 信息，这标志了数据已经读取完，返回 false；反之则通过 <code>LoadFilteredStripeBuffers()</code> 函数载入 stripe 信息并将 TableReadState-&gt;readStripeCount 加 1。如果读取的 stripe 中行记录数为 0 则说明该 stripe 中不包含记录，因此我们需要继续读取下一个 stripe；反之则重置 TableReadState-&gt;stripeReadRowCount、TableReadState-&gt;deserializeBlockIndex 等与 stripe 相关的信息。</li>
<li>判断当前所读取的行是否在已经反序列化的数据块中。若是则转至 3，反之则需要通过函数 <code>DeserializeBlockData()</code> 来反序列化一个新的数据块用于读取数据。</li>
<li>调用函数 <code>ReadStripeNextRow()</code> 读取一条行记录。如果当前读取的 TableReadState-&gt;stripeReadRowCount 与 TableReadState-&gt;stripeBuffers-&gt;rowCount 相等则说明当前 stripe 中的行记录以及读取完，将 TableReadState-&gt;stripeBuffers 置为 NULL 为下次读取作准备。</li>
</ol>
<p>当表中所有的数据都已读出，cstore_fdw 将通过 <code>CStoreEndRead()</code> 函数来进行后续的善后工作。其中主要包括内存上下文的释放，文件的关闭等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文结合 cstore_fdw 的源码分析了其物理的存储格式，梳理了其数据读写的流程。从源码角度我们可以看到 cstore_fdw 在每次插入都会新建 stripe 来处理插入的数据，若是大量的小数据插入势必会导致元数据信息的迅速膨胀，从而影响性能，因此 cstore_fdw 不支持 INSERT 语句。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>cstore_fdw</tag>
        <tag>列存</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX 自定义封面</title>
    <url>/2019/04/customize-latex-title-page/</url>
    <content><![CDATA[<p>本文主要记录在使用 LaTeX 进行封面自定义的相关实现，如下图 1 所示。</p>
<img src="/2019/04/customize-latex-title-page/customize-title-page.png" class="" title="LaTeX Title Page">
<p style="text-align:center">图 1 LaTeX 自定义封面</p>

<a id="more"></a>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>图 1 的封面通过 LaTeX 实现起来非常简单，我们只需要会使用几个基本的命令就足够了。从图中我们可以将封面分为六个部分，它们分别是最上面的横线、居中的标题、标题下的横线、作者信息、日期以及封面底部的横线。如下所示：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;book&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="tag">\<span class="name">begin</span><span class="string">&#123;titlepage&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">centering</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">%    Top rules</span></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">rule</span><span class="string">&#123;\textwidth&#125;</span><span class="string">&#123;1pt&#125;</span></span>   <span class="comment">% The top horizontal rule</span></span><br><span class="line">    <span class="tag">\<span class="name">vspace</span><span class="string">&#123;0.2\textheight&#125;</span></span>  <span class="comment">% Whitespace between top horizontal rule and title</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">%    Title</span></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    &#123;<span class="tag">\<span class="name">Huge</span></span> Customize <span class="tag">\<span class="name">LaTeX</span><span class="string">&#123;&#125;</span></span> Title Page&#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">vspace</span><span class="string">&#123;0.025\textheight&#125;</span></span>   <span class="comment">% Whitespace between the title and short horizontal rule</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">rule</span><span class="string">&#123;0.83\textwidth&#125;</span><span class="string">&#123;0.4pt&#125;</span></span>  <span class="comment">% The short horizontal rule under title</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">vspace</span><span class="string">&#123;0.1\textheight&#125;</span></span>  <span class="comment">% Whitespace between the short horizontal rule and author</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">%    Author</span></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    &#123;<span class="tag">\<span class="name">Large</span></span> Author: <span class="tag">\<span class="name">textsc</span><span class="string">&#123;Japin Li&#125;</span></span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">vfill</span></span>  <span class="comment">% Whitespace between author and date</span></span><br><span class="line"></span><br><span class="line">    &#123;<span class="tag">\<span class="name">large</span></span> <span class="tag">\<span class="name">today</span></span>&#125;</span><br><span class="line">    <span class="tag">\<span class="name">vspace</span><span class="string">&#123;0.1\textheight&#125;</span></span>  <span class="comment">% Whitespace between date and bottom horizontal rule</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">%    Bottom rules</span></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">rule</span><span class="string">&#123;\textwidth&#125;</span><span class="string">&#123;1pt&#125;</span></span>  <span class="comment">% The bottom horizontal rule</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">\<span class="name">end</span><span class="string">&#123;titlepage&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中我只是将 <code>titlepage</code> 直接在文档中给出，其实我们还可以通过重定义 <code>\maketitle</code> 命令来实现自定义封面，这时我们还需要传入一些特定的参数，详细实现可以参考我实现的 <a href="https://github.com/japinli/ferret">ferret</a>。您也可以在封面中使用 <code>\includegraphics</code> 命令来导入图片。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://en.wikibooks.org/wiki/LaTeX/Title_Creation">https://en.wikibooks.org/wiki/LaTeX/Title_Creation</a></p>
]]></content>
      <categories>
        <category>排版</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言软件包下载</title>
    <url>/2020/05/download-go-package/</url>
    <content><![CDATA[<p>作为一个刚入门的 Go 小白来说，下载第三方包就成为了第一道坎 :( 。本文简要介绍一下如何下载 Go 软件包，尤其是 Google 系列的包。</p>
<a id="more"></a>

<p>本文基于 Go 1.13.4 版本，例如，我们要下载 <code>golang.org/x/tools</code> 包，由于某些不可抗力的原因，我们会遇到下面的错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get golang.org/x/tools</span></span><br><span class="line">package golang.org/x/tools: unrecognized import path &quot;golang.org/x/tools&quot; (https fetch: Get https://golang.org/x/tools?go-get=1: dial tcp 216.239.37.1:443: i/o timeout)</span><br></pre></td></tr></table></figure>

<p>出现了问题，自然就有解决办法，毕竟国内也还是要进行 Go 语言开发的，因此，关于 Go 语言包的代理就应运而生，<a href="https://goproxy.io/">goproxy</a> 就是其中之一。</p>
<p>根据介绍，我们可以设置 Go 的环境变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go env -w GO111MODULE=on</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go env -w GOPROXY=<span class="string">&quot;https://goproxy.io,direct&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>随后，我们便可以正常下载 Go 语言包了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get golang.org/x/tools</span></span><br><span class="line">go: finding golang.org/x/tools latest</span><br><span class="line">go: downloading golang.org/x/tools v0.0.0-20200515220128-d3bf790afa53</span><br><span class="line">go: extracting golang.org/x/tools v0.0.0-20200515220128-d3bf790afa53</span><br></pre></td></tr></table></figure>

<p>这是在 Go 1.13 及其之后的版本有效，对于之前的版本，我们可以采用如下方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Enable the go modules feature</span><br><span class="line">export GO111MODULE&#x3D;&quot;on&quot;</span><br><span class="line"># Set the GOPROXY environment variable</span><br><span class="line">export GOPROXY&#x3D;&quot;https:&#x2F;&#x2F;goproxy.io&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs 编辑二进制文件</title>
    <url>/2018/10/editing-binary-files-in-emacs/</url>
    <content><![CDATA[<p>二进制文件是以二进制格式存储的文件，它是计算机可读的，人类不直接阅读二进制文件。所有的可执行程序都以二进制文件存储。那我们该如何编辑二进制文件呢？在我使用的 Emacs 编辑器中提供了一个 hexl-mode 的主模式来编辑二进制文件。本文记录了 Emacs 中编辑二进制文件的基本操作。</p>
<img src="/2018/10/editing-binary-files-in-emacs/Editing_Binary_File.png" class="" title="Editing Binary File">

<a id="more"></a>

<h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><p>我们可以使用 <code>M-x hexl-find-file</code> 取代 <code>C-x C-f</code> 命令来编辑二进制文件，该命令将文件内容转换为十六进制，并允许用户进行编辑。当用户保存文件时，它将会自动转换为二进制格式。</p>
<p>当然，我们也可以使用 `M-x hexl-mode** 来将现有的缓冲区转换为十六进制，这在以普通方式打开二进制文件时非常有用。</p>
<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>普通文本字符在 hexl-mode 下被覆盖。这是为了降低意外破坏文件中数据对齐的风险。针对二进制文件，hexl-mode 有特殊的插入命令。以下是 hexl-mode 的命令列表：</p>
<ul>
<li><strong>C-M-d</strong> 插入一个包含十进制代码的字节。</li>
<li><strong>C-M-o</strong> 插入一个包含八进制代码的字节。</li>
<li><strong>C-M-x</strong> 插入一个包含十六进制代码的字节。</li>
<li><strong>C-M-[</strong> 移动到 1k 字节页面的开头。</li>
<li><strong>C-M-]</strong> 移动到 1k 字节页面的结尾。</li>
<li><strong>M-g</strong> 移至以十六进制指定的地址。</li>
<li><strong>M-j</strong> 移至以十进制指定的地址。</li>
<li><strong>C-c C-c</strong> 退出 hexl-mode，返回调用 hexl-mode 之前返回此缓冲区的主模式。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.webopedia.com/TERM/B/binary_file.html">https://www.webopedia.com/TERM/B/binary_file.html</a><br>[2] <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Editing-Binary-Files.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Editing-Binary-Files.html</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB 命令</title>
    <url>/2020/04/gdb-commands/</url>
    <content><![CDATA[<p>在<a href="/2020/01/getting-in-and-out-of-gdb/" title="上一篇">上一篇</a>文章中，我们介绍了如何进入和退出 GDB，以及一些基本的配置，本文主要介绍 GDB 的命令语法、与命令相关的配置，如何对命令进行补全、有关命令的选项以及如何获取命令的帮助信息。</p>
<a id="more"></a>

<h2 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h2><p>GDB 命令是一个单行的输入，这一行是没有限制的。GDB 命令的语法是命令名后跟参数。例如，命令 <code>step</code> 可以跟一个参数代表步进的次数，如 <code>step 5</code>。我们也可以使用不带参数的 <code>step</code> 命令，某些命令不允许带参数。</p>
<p>如果 GDB 命令的名称缩写没有歧义的话，我们可以简写命令名称。在某些情况下，我们甚至可以不明确的缩写。例如，即使有其他命令以 <code>s</code> 开头，GDB 也将 <code>s</code> 定义为 <code>step</code>。我们可以通过将缩写用作 <code>help</code> 命令的参数来测试缩写。</p>
<p>如果输入空行（即输入 <code>RET</code> 回车键）的话则表示重复之前的命令。某些命令（例如，<code>run</code> 命令）不会以这种方式重复，这些命令通常我们也不需要它重复执行。用户定义的命令可以禁用这个功能。</p>
<p>当我们使用 <code>RET</code> 来重复 <code>list</code> 和 <code>x</code> 命令时，它们会构造新的参数而不是使用之前输入的参数。这样可以很容易的查看源码和内存。</p>
<p>GDB 还可以通过另一种方式使用 <code>RET</code>：以类似于通用实用程序的方式对冗长的输出进行分区。</p>
<p>任何位于 <code>#</code> 字符之后的文本都是注释的内容，这通常在命令文件中非常有用。</p>
<h2 id="命令配置"><a href="#命令配置" class="headerlink" title="命令配置"></a>命令配置</h2><p>许多命令都可以由命令特定的变量或者配置来更改其行为。我们可以使用 <code>set</code> 子命令来修改配置。例如，<code>print</code> 命令（查看数据）打印数组的内容取决于 <code>set print elements NUMBER-OF-ELEMENTS</code> 和 <code>set print array-indexes</code> 以及其他配置。</p>
<p>我们可以在 GDB 启动时加载的 gdbinit 文件中更改这些设置。这些配置也可以在 gdb 回话中临时修改。例如，要更改要打印的数组元素的限制，可以执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(GDB) set print elements 10</span><br><span class="line">(GDB) print some_array</span><br><span class="line">$1 &#x3D; &#123;0, 10, 20, 30, 40, 50, 60, 70, 80, 90...&#125;</span><br></pre></td></tr></table></figure>

<p>上面的命令 <code>set print elements 10</code> 将默认打印的数组大小由 200 修改为 10。如果仅打算将此限制 10 用于打印 some_array，则我们需要将其设置回默认值 200 。</p>
<p>某些命令允许使用命令选项来覆盖设置。例如，<code>print</code> 命令支持一系列选项来覆盖相关的全局设置。上面的命令我们可以使用下面的命令来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(GDB) print -elements 10 -- some_array</span><br><span class="line">$1 &#x3D; &#123;0, 10, 20, 30, 40, 50, 60, 70, 80, 90...&#125;</span><br></pre></td></tr></table></figure>

<p>或者，我们可以在命令调用期间使用 <code>with</code> 命令来临时更改设置，即 <code>with setting [value] [-- command]</code> 或者 <code>w setting [value] [-- command]</code>，在命令执行期间临时将 <code>setting</code> 设置为 <code>value</code>。其中 <code>setting</code> 是任何可以使用 <code>set</code> 命令修改的配置。如果没有提供 <code>command</code>，那么将会重复执行上一条命令。如果指定了 <code>command</code>，那么必须使用 <code>--</code> 来分割设置和命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(GDB) with print array on -- print some_array</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(GDB) set print array on</span><br><span class="line">(GDB) print some_array</span><br><span class="line">(GDB) set print array off</span><br></pre></td></tr></table></figure>
<p>当我们覆盖自定义命令或者使用 Python 和 Guile 时非常有用。<br>如果我们需要为一个命令临时修改多个设置，我们可以使用嵌套的 <code>with</code> 命令，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with language ada -- with print elements 10</span><br></pre></td></tr></table></figure>

<p>上面的命令临时地将语言设置为 <code>ada</code> 并且设置数组和字符串的输出限制为 10。</p>
<h2 id="命令补全"><a href="#命令补全" class="headerlink" title="命令补全"></a>命令补全</h2><p>当只有一个候选的命令时，GDB 可以补全用户输入的命令，任何时候，GDB 都可以查看用户可能输入的命令。这对于 GDB 的命令、子命令、命令选项以及程序的符号名都是有效的。</p>
<p>当我们需要补全命令时，我们可以直接输入 <code>TAB</code>。如果只有一种可能性，则 GDB 会填入单词，并等待我们完成命令（或按 <code>RET</code> 键输入）。例如，如果我们输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) info bre TAB</span><br></pre></td></tr></table></figure>

<p>GDB 将会补全 <code>bre</code> 为 <code>breakpoints</code>，因为对于 <code>info</code> 的子命令并且以 <code>bre</code> 开头的只有 <code>breakpoints</code> 一个候选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) info breakpoints</span><br></pre></td></tr></table></figure>

<p>此时，我们可以输入 <code>RET</code> 来执行 <code>info breakpoints</code> 命令，或者如果 <code>breakpoints</code> 不是我们期望的命令，我们可以使用退格键删除补全的内容，并输入我们想要的命令。（如果我们确定想要执行的命令就是 <code>info breakpoints</code>，我们可以在输入 <code>info bre</code> 之后立即输入 <code>RET</code> 来执行这条命令，这就是利用了 GDB 命令缩写的功能。）</p>
<p>如果我们在输入 <code>TAB</code> 进行补全时，候选项不止一个，那么 GDB 会发出铃声，我们可以尝试输入更多的字符来补全信息，或者再次输入 <code>TAB</code> 来查看可能的候选项。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b make_ TAB</span><br><span class="line"></span><br><span class="line">GDB sounds bell; press TAB again, to see:</span><br><span class="line"></span><br><span class="line">make_a_section_from_file     make_environ</span><br><span class="line">make_abs_section             make_function_type</span><br><span class="line">make_blockvector             make_pointer_type</span><br><span class="line">make_cleanup                 make_reference_type</span><br><span class="line">make_command                 make_symbol_completion_list</span><br><span class="line">(gdb) b make_</span><br></pre></td></tr></table></figure>

<p>当我么输入 <code>make_</code> 并按 <code>TAB</code> 键时，由于存在多个候选项，因此 GDB 将会发出铃声，当我么再次输入 <code>TAB</code> 时，GDB 会显示可能的候选项。随后，GDB 会赋值用户的输入并继续等待用户输入。</p>
<p>如果我们只是想要第一时间看到可能的候选项，我们可以直接输入 <code>M-?</code> 而不是连续输入两次 <code>TAB</code>。<code>M-?</code> 是 <code>META ?</code> 的简写。我们可以通过按 <code>ESC+?</code> 来达到相同的目的。</p>
<p>如果候选项非常大，GDB 将尽可能多的输出候选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b mTABTAB</span><br><span class="line">main</span><br><span class="line">&lt;... the rest of the possible completions ...&gt;</span><br><span class="line">*** List may be truncated, max-completions reached. ***</span><br><span class="line">(gdb) b m</span><br></pre></td></tr></table></figure>

<p>我们可以通过下面的命令来控制候选项的数量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set max-completions limit</span><br><span class="line">set max-completions unlimited</span><br></pre></td></tr></table></figure>

<p>上面的命令用于设置显示的最大的候选项数量。当达到最大的限制时，GDB 将不会在显示其他可能的候选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show max-completions</span><br></pre></td></tr></table></figure>

<p>显示候选项限制。</p>
<p>有时我们输入的内容逻辑上属于一个完整的内容，但是它包含了特殊字符，例如括号等。为了让补全在这种情况下也可以正常工作，我们需要使用单引号将其包裹起来。例如在补全 C++ 中模版名时经常会遇到这种情况，在正常情况下，GDB 会将 <code>&lt;</code> 视为一个分隔符，并假定它是小于符号。</p>
<p>如下所示，当我们需要使用 <code>print</code> 或者 <code>call</code> 命令调用 C++ 模版函数时，我们需要区分使用那个版本，如 <code>name&lt;int&gt;()</code> 或 <code>name&lt;float&gt;()</code>。为了在这种情况下使用补全共鞥，我们需要在函数名称之前键入 <code>&#39;</code> ，随后在使用补全的快捷键：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p &#39;func&lt; M-?</span><br><span class="line">func&lt;int&gt;()    func&lt;float&gt;()</span><br><span class="line">(gdb) p &#39;func&lt;</span><br></pre></td></tr></table></figure>

<p>但是在设置断点时，我们并不需要这样做，这是因为 GDB 知道我们需要在函数上设置断点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b func&lt; M-?</span><br><span class="line">func&lt;int&gt;()    func&lt;float&gt;()</span><br><span class="line">(gdb) b func&lt;</span><br></pre></td></tr></table></figure>

<p>这对于 C++ 中的重载函数也是一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b bubble( M-?</span><br><span class="line">bubble(int)    bubble(double)</span><br><span class="line">(gdb) b bubble(dou M-?</span><br><span class="line">bubble(double)</span><br></pre></td></tr></table></figure>

<p>GDB 提供了 <code>set overload-resolution off</code> 来禁止重载函数的解析。</p>
<p>当 GDB 在补全结构体的成员时，他将尝试补全除了左侧之外可用的字段名称，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p gdb_stdout.M-?</span><br><span class="line">magic                to_fputs             to_rewind</span><br><span class="line">to_data              to_isatty            to_write</span><br><span class="line">to_delete            to_put               to_write_async_safe</span><br><span class="line">to_flush             to_read</span><br></pre></td></tr></table></figure>

<p>上面的 <code>gdb_stdout</code> 变量在 GDB 源码中的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ui_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> *magic;</span><br><span class="line">   ui_file_flush_ftype *to_flush;</span><br><span class="line">   ui_file_write_ftype *to_write;</span><br><span class="line">   ui_file_write_async_safe_ftype *to_write_async_safe;</span><br><span class="line">   ui_file_fputs_ftype *to_fputs;</span><br><span class="line">   ui_file_read_ftype *to_read;</span><br><span class="line">   ui_file_delete_ftype *to_delete;</span><br><span class="line">   ui_file_isatty_ftype *to_isatty;</span><br><span class="line">   ui_file_rewind_ftype *to_rewind;</span><br><span class="line">   ui_file_put_ftype *to_put;</span><br><span class="line">   <span class="keyword">void</span> *to_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><p>GDB 的某些命令支持一个 <code>-</code> 给出命令选项，例如，<code>print -pretty</code>。与命令名称一样，命令选项也可以采用缩写的形式，前提是这个缩写不会导致歧义，同时，我梦也可以用 <code>TAB</code> 来补全命令选项（或者是查看可能的命令选项）。</p>
<p>GDB 某些命令将原始输入作为参数。例如，<code>print</code> 命令可以处理 GDB 支持的任何语言的表达式。在这些命令中，原始输入可能以 <code>-</code> 开始，因此这可能会与命令选项产生混淆，例如， <code>print -p</code> （它可以是 <code>print -pretty</code> 的缩写或者取变量 <code>p</code> 的相反数），因此如果我们的命令中包含选项，我们需要使用 <code>--</code> 来分割命令选项和参数。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) print -object on -pretty off -element unlimited -- *myptr</span><br><span class="line">(gdb) p -o -p 0 -e u -- *myptr</span><br></pre></td></tr></table></figure>

<p>上面两条命令是等价的。</p>
<p>我们可以使用补全功能来查看命令可用的选项，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) print -TABTAB</span><br><span class="line">-address         -max-depth       -raw-values      -union</span><br><span class="line">-array           -null-stop       -repeats         -vtbl</span><br><span class="line">-array-indexes   -object          -static-members</span><br><span class="line">-elements        -pretty          -symbol</span><br></pre></td></tr></table></figure>

<p>补全功能同样也能给出命令选项的参数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) print -elements TABTAB</span><br><span class="line">NUMBER     unlimited</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，选项期望输入一个整数（如，100），而不是文本 <code>NUMBER</code>。</p>
<h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>在 GDB 中，我们可以使用 <code>help</code> 命令来获取帮助信息。我们可以使用不带参数的 <code>help</code>（缩写为 <code>h</code>）来显示命令分类类的简短列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) help</span><br><span class="line">List of classes of commands:</span><br><span class="line"></span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying and examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without</span><br><span class="line">               stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"></span><br><span class="line">Type &quot;help&quot; followed by a class name for a list of</span><br><span class="line">commands in that class.</span><br><span class="line">Type &quot;help&quot; followed by command name for full</span><br><span class="line">documentation.</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>我们使用 <code>help class</code> 可以获取命令分类下的命令信息。例如，我们可以查看 <code>status</code> 分类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) help status</span><br><span class="line">Status inquiries.</span><br><span class="line"></span><br><span class="line">List of commands:</span><br><span class="line"></span><br><span class="line">info -- Generic command for showing things</span><br><span class="line">        about the program being debugged</span><br><span class="line">show -- Generic command for showing things</span><br><span class="line">        about the debugger</span><br><span class="line"></span><br><span class="line">Type &quot;help&quot; followed by command name for full</span><br><span class="line">documentation.</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p><code>help command</code> 则可以查看具体命令的使用。</p>
<p><code>apropos [-v] regexp</code> 命令可以在所有 GDB 命令中搜索与正则表达式匹配的命令。<code>-v</code> 是详细的意思。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apropos alias</span><br><span class="line">alias -- Define a new command that is an alias of an existing command</span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">d -- Delete some breakpoints or auto-display expressions</span><br><span class="line">del -- Delete some breakpoints or auto-display expressions</span><br><span class="line">delete -- Delete some breakpoints or auto-display expressions</span><br></pre></td></tr></table></figure>

<p><code>complete args</code> 命令用于获取所有以 <code>args</code> 开始的命令。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) complete i</span><br><span class="line">if</span><br><span class="line">ignore</span><br><span class="line">inferior</span><br><span class="line">info</span><br><span class="line">init-if-undefined</span><br><span class="line">interpreter-exec</span><br><span class="line">interrupt</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>除了 <code>help</code> 命令之外，我们还可以使用 <code>info</code> 和 <code>show</code> 命令来获取程序或 GDB 的状态。</p>
<ul>
<li><code>info</code> - 该命令可以缩写为 <code>i</code>，它用于获取当前程序的状态。例如，我们可以使用它来函数的参数 <code>info args</code>，查看当前使用的寄存器 <code>info registers</code>，或者是查看当前设置的断点信息 <code>info breakpoints</code>。我们可以使用 <code>help info</code> 来查看所有 <code>info</code> 的子命令。</li>
<li><code>set</code> - 我们可以使用 <code>set</code> 命令给环境变量赋值。例如，我们可以使用 <code>set prompt $</code> 将 GDB 命令提示符号修改为 <code>$</code> 符。</li>
<li><code>show</code> - 与 <code>info</code> 命令不通，<code>show</code> 用来查看 GDB 自身的状态。我们可以改变大多数我们可以使用 <code>show</code> 命令查看的内容。例如，我们可以使用 <code>set radix</code> 命令设置系统编号，并使用 <code>show radix</code> 来查询当前值。</li>
</ul>
<p>为了获取所有可以设置的参数，我们可以使用没有参数的 <code>show</code> 命令，或者 <code>info set</code> 命令，它们是等效的。</p>
<p>有几个 <code>show</code> 的子命令是无法使用 <code>set</code> 命令进行修改的。</p>
<ul>
<li><code>show version</code> - 查看当前 GDB 的版本信息。</li>
<li><code>show copying</code> &amp; <code>info copying</code> - 显示有关复制 GDB 的权限的信息。</li>
<li><code>show warranty</code> &amp; <code>info warranty</code> - 显示 GNU “NO WARRANTY” 声明。</li>
<li><code>show configuration</code> - 显示编译 GDB 时的详细配置信息。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Commands.html#Commands">https://sourceware.org/gdb/current/onlinedocs/gdb/Commands.html#Commands</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB 基本使用</title>
    <url>/2020/01/getting-in-and-out-of-gdb/</url>
    <content><![CDATA[<p>在工作中经常使用 GDB 来调试程序，但是一直都没有系统的进行学习过，为此，我打算对其进行一个系统的学习，学习的主要材料来自 GNU GDB 文档 <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">Debugging with GDB</a>。</p>
<p>本文主要包括如何运行以及退出 GDB，通常，我们使用 <code>gdb</code> 即可进入 GDB，而 <code>quit</code> 命令或者 <code>Ctrl-d</code> 快捷键便可以退出 GDB。</p>
<a id="more"></a>

<h2 id="运行-GDB"><a href="#运行-GDB" class="headerlink" title="运行 GDB"></a>运行 GDB</h2><p>通过在命令行中输入 <code>gdb</code> 就可以进入到 GDB，此时，GDB 将读取用户输入的命令并执行，这其实就是一个交互式的界面，读取用户命令，执行用户命令，再读取用户命令，直到用户输入退出指令执行退出操作。</p>
<p>我们还可以在 <code>gdb</code> 运行时指定一系列参数和选项，从而指定更多关于我们调试环境的一些设置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb program</span></span><br></pre></td></tr></table></figure>

<p>上面是最常用的 GDB 使用方式，它指定我们将要调试的可执行程序。此外，我们还可以指定调试的程序以及一个 core 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb program core</span></span><br></pre></td></tr></table></figure>

<p>如果我们要调试正在运行的程序，我们还可以使用进程 ID 或者 <code>-p</code> 选项作为第二个参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb program 1234</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gdb -p 1234</span></span><br></pre></td></tr></table></figure>

<p>上面的命令将使用 GDB 附加到进程 ID 为 <code>1234</code> 的进程上，如果使用 <code>-p</code> 选项，我们可以省略 <code>program</code> 程序名。</p>
<p>我们可以选择使用 <code>--args</code> 来向调试的程序传递参数，该选项将终止可选参数的处理。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb --args gcc -O2 -c foo.c</span></span><br></pre></td></tr></table></figure>

<p>上面的命令将使用 GDB 调试 gcc 程序，并将 <code>-O2 -c foo.c</code> 作为 <code>gcc</code> 的命令行参数。</p>
<p>GDB 运行时会输出类似下面的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">GNU gdb (GDB) 8.3</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http:&#x2F;&#x2F;gnu.org&#x2F;licenses&#x2F;gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-apple-darwin18.5.0&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;bugs&#x2F;&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;documentation&#x2F;&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br></pre></td></tr></table></figure>

<p>我们可以使用 <code>--slient</code> 或者 <code>-q/--quite</code> 选项来抑制这些信息的输出。还有很多关于 GDB 的命令行选项，我们可以通过 <code>gdb -help</code> 来获取其使用方法。</p>
<h3 id="文件选择"><a href="#文件选择" class="headerlink" title="文件选择"></a>文件选择</h3><p>当 GDB 运行时，它将读取选项以外的所有参数以指定可执行文件和 core 文件（或者进程 ID）中读取其它参数。这与分别由 <code>-se</code> 和 <code>-c</code> （或者 <code>-p</code>）指定参数相同。（GDB 将第一个没有选项关联的参数视为与 <code>-se</code> 后跟参数等效；将第二个没有选项关联的参数视为与 <code>-c</code> 或者 <code>-p</code> 后跟参数等效。）如果第二个参数以数字开始，GDB 首先尝试将其附加为一个进程，如果失败了，GDB 则试图将其作为一个 core 文件来打开。如果我们有一个以数字开始的 core 文件，那么我们可以为期添加前缀（如 <code>./</code>）来避免 GDB 将其视为一个进程 ID。</p>
<p>如果 GDB 不支持配置 core 文件，例如对于大多是嵌入式目标，那么 GDB 将输出日志并忽略第二个参数。</p>
<p>大多数 GDB 选项都有长，短选项两种形式；如果我们截断了长格式，只要足够 GDB 区分歧义，那么它也是能识别的。</p>
<style>
table th:nth-of-type(1) {
    width: 35%;
}
table th:nth-of-type(2) {
    width: 65%;
}
</style>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-symbols file</code>, <br/><code>-s file</code></td>
<td>从文件 <code>file</code> 中读取符号表</td>
</tr>
<tr>
<td><code>-exec file</code>, <br/><code>-e file</code></td>
<td>使用文件 <code>file</code> 作为可执行文件在适当时执行，并与核心转储一起检查纯数据</td>
</tr>
<tr>
<td><code>-se file</code></td>
<td>从文件 <code>file</code> 中读取符号表，并将其用作可执行文件</td>
</tr>
<tr>
<td><code>-core file</code>, <br/><code>-c file</code></td>
<td>使用文件 <code>file</code> 作为 coredump 文件进行检查</td>
</tr>
<tr>
<td><code>-pid number</code>, <br/><code>-p number</code></td>
<td>与 <code>attach</code> 命令一样，附加到进程 ID 为 <code>number</code> 的进程</td>
</tr>
<tr>
<td><code>-command file</code>, <br/><code>-x file</code></td>
<td>执行 <code>file</code> 文件中的命令，该文件的内容与 <code>source</code> 命令的内容相同</td>
</tr>
<tr>
<td><code>-eval-command command</code>, <br/><code>-ex command</code></td>
<td>执行单个的 GDB 命令，可多次使用，也可以与 <code>-x</code> 交叉使用</td>
</tr>
<tr>
<td><code>-init-command file</code>, <br/><code>-ix file</code></td>
<td>在加载 <code>inferior</code> 之前（在加载 <code>gdbinit</code> 文件之后）执行 <code>file</code> 文件内的 GDB 命令</td>
</tr>
<tr>
<td><code>-init-eval-command command</code>,<br/> <code>-iex command</code></td>
<td>在加载 <code>inferior</code> 之前（在加载 <code>gdbinit</code> 文件之后）执行单个 GDB 命令</td>
</tr>
<tr>
<td><code>-directory directory</code>, <br/><code>-d directory</code></td>
<td>将目录 <code>directory</code> 作为源码或脚本的搜索路径</td>
</tr>
<tr>
<td><code>-r</code>, <br/><code>-readnow</code></td>
<td>立即读取每个符号文件的整个符号表，而不是默认值，默认值是根据需要逐步读取它。这会使启动速度变慢，但会使以后的操作变快</td>
</tr>
<tr>
<td><code>--readnever</code></td>
<td>不要读取每个符号文件的符号调试信息。这使启动速度更快，但以无法执行符号调试为代价。DWARF展开信息也不会被读取，这意味着 backtrace 可能变得不完整或不准确。这种用法通常是用户只关心程序的执行顺序。</td>
</tr>
</tbody></table>
<h3 id="选择模式"><a href="#选择模式" class="headerlink" title="选择模式"></a>选择模式</h3><p>我们可以在不同模式下运行 GBD，例如，批处理模式或者静默模式。</p>
<ul>
<li><p><code>-nx, -n</code> 不要执行初始化文件中的命令。GDB 包含三个初始化文件，它们按照如下的顺序加载：</p>
<ul>
<li><code>system.gdbinit</code> - 系统级别的初始化文件，它由编译时选项 <code>--with-system-gdbinit</code> 指定的位置。GDB 会在命令行选项处理之前加载此文件。</li>
<li><code>system.gdbinit.d</code> - 这是系统级别的初始化目录。它由编译时选项 <code>--with-system-gdbinit-dir</code> 指定。此处的文件将在 <code>system.gdbinit</code> 文件之后、命令行选项之前进行加载，该目录下可能存在多个文件，它们按字母顺序进行加载。文件需要具有公认的脚本语言扩展名（<code>.py/.scm</code>）或以 <code>.gdb</code> 扩展名（将其视为普通的 GDB 命令）命名。GDB 不会递归的加载该目录下的子目录。</li>
<li><code>~/.gdbinit</code> - 用户家目录初始化文件，它在 <code>system.gdbinit</code> 之后，命令行选项处理之前加载。</li>
<li><code>./.gdbinit</code> - 当前目录的初始化文件。它最后被加载，除了 <code>-x</code> 和 <code>-nx</code> 命令行选项之外。<code>-x</code> 和 <code>-ex</code> 是最后被处理的，在 <code>./.gdbinit</code> 之后加载。</li>
</ul>
</li>
<li><p><code>-nh</code> 不要执行来自用户家目录下的初始化文件（即 <code>~/.gdbinit</code>）中的命令。</p>
</li>
<li><p><code>-quite, -silent, -q</code> 静默模式，不输出介绍信息和版权信息。在批处理模式下也不会输出这些信息。</p>
</li>
<li><p><code>-batch</code> 批处理模式。在处理完由 <code>-x</code> 指定的所有命令文件（如果没有使用 <code>-n</code> 选项，也将处理初始化文件中的命令）并退出，正常返回 0，非 0 表示出现错误。批处理模式将会禁止分页功能，即终端的宽度和高度没有限制，类似于 <code>set confirm off</code>。</p>
</li>
<li><p><code>-cd directory</code> 使用 <code>directory</code> 作为工作目录，而不是当前目录作为工作目录。</p>
</li>
<li><p><code>-data-directory directory, -D directory</code> 使用 <code>directory</code> 作为 GDB 运行时的数据目录，这个目录包含了 GDB 的辅助文件。</p>
</li>
</ul>
<p>此处只列出了部分选项，更多选项<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Mode-Options.html#Mode-Options">请看这里</a>。</p>
<h3 id="GDB-在启动时都做了什么"><a href="#GDB-在启动时都做了什么" class="headerlink" title="GDB 在启动时都做了什么"></a>GDB 在启动时都做了什么</h3><p>下面是有关 GDB 在会话启动过程中执行的操作的说明：</p>
<ol>
<li><p>设置命令行指定的命令解释器。</p>
</li>
<li><p>读取系统级别的初始化文件以及系统级别的初始化目录，并执行这些文件中的命令。这些文件以 <code>.gdb</code> 结尾（包含 GDB 命令）或者 GDB 支持的脚本语言的后缀结尾。</p>
</li>
<li><p>读取用户级别的初始化文件并执行其中的命令。</p>
</li>
<li><p>执行由 <code>-iex</code> 或 <code>-ix</code> 选项指定的命令文件或命令，按照指定的顺序执行。</p>
</li>
<li><p>处理命令行选项和操作数。</p>
</li>
<li><p>读取并执行来自当前工作目录下的初始化文件（需要 <code>set auto-load local-gdbinit</code> 设置为 <code>on</code>）。仅在当前目录不是用户家目录时才会执行。因此，我们可以在调用 GDB 的目录中拥有多个初始化文件，一个初始化文件位于用户家目录中，而另一个文件特定于要调试的程序目录。</p>
</li>
<li><p>如果命令行选项指定了待调试的程序，或者需要附加的进程，或者 core 文件，GDB 会加载为程序或其加载的共享库提供的有自动加载的脚本。<br>如果我们想要禁用启动时自动加载脚本，可以按如下方式使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb -iex &quot;set auto-load python-scripts off&quot; myprogname</span><br></pre></td></tr></table></figure>

<p>选项 <code>-ex</code> 不会有效，这是因为它加载的时间太晚了，以致于来不及关闭自动加载功能。</p>
</li>
<li><p>按顺序执行来自 <code>-ex</code> 和 <code>-x</code> 选项指定的命令。</p>
</li>
<li><p>读取历史文件中的历史文件。</p>
</li>
</ol>
<p>初始化文件使用的语法与命令文件相同，并且 GDB 处理的方式也一样。用户家目录的初始化文件设置选项可以影响后续选项的处理。如果使用了 <code>-nx</code> 选项，那么将不会执行初始化文件中的命令。</p>
<p>通过 <code>gdb --help</code> 可以看到 GDB 启动时加载的初始化文件列表。</p>
<h2 id="退出-GDB"><a href="#退出-GDB" class="headerlink" title="退出 GDB"></a>退出 GDB</h2><p>我们可以使用 <code>quit [expression]</code> 或者 <code>q [expression]</code> 退出 GDB。如果没有指定 <code>expression</code> 表达式，GDB 将正常终止；否则他将使用表达式 <code>experssion</code> 的结果作为错误码。</p>
<p>中断（通常是 <code>Ctrl-c</code>）不会退出 GDB，而是终止正在运行的 GDB 命令，并返回到 GDB 的命令行。如果您一直在使用 GDB 来控制连接的进程或设备，则可以使用 <code>detach</code> 命令释放它。</p>
<h2 id="Shell-命令"><a href="#Shell-命令" class="headerlink" title="Shell 命令"></a>Shell 命令</h2><p>如果我们想要在调试期间执行 shell 命令，我们没有必要离开或者挂起 GDB；我们可以直接使用 SHELL 命令。</p>
<p>我们可以使用 <code>shell command-string</code> 或者 <code>!command-string</code> 来执行标准的 shell 命令。需要注意的是在 <code>!</code> 和 <code>command-string</code> 之间没有空格。如果存在空格，那么将使用环境变量 <code>SHELL</code> 来运行 shell 命令。否则，GDB 将使用默认的 shell（Unix 系统为 /bin/sh，Windows 平台为 COMMAND.COM 等）。</p>
<p>编译工具 <code>make</code> 总是在开发环境中，因此，在 GDB 中我们不必为 <code>make</code> 使用 <code>shell</code> 命令。</p>
<ul>
<li><p><code>make make-args</code> -  将以给定的参数执行 <code>make</code> 命令，这等同于 <code>shell make make-args</code>。</p>
</li>
<li><p><code>pipe [command] | shell_command</code> 和 <code>| [command] | shell_command</code> - 命令执行 <code>command</code> 命令并将结果重定向到 <code>shell_command</code> 中。</p>
</li>
<li><p><code>pipe -d delim command delim shell_command</code> 和<code>| -d delim command delim shell_command</code> - 与上面的命令相似，不同的是我们可以指定分割符 <code>delim</code>。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p var</span><br><span class="line">$1 &#x3D; &#123;</span><br><span class="line">  black &#x3D; 144,</span><br><span class="line">  red &#x3D; 233,</span><br><span class="line">  green &#x3D; 377,</span><br><span class="line">  blue &#x3D; 610,</span><br><span class="line">  white &#x3D; 987</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(gdb) pipe p var | wc</span><br><span class="line">      7      19      80</span><br><span class="line">(gdb) | p var | wc -l</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">(gdb) p &#x2F;x var</span><br><span class="line">$4 &#x3D; &#123;</span><br><span class="line">  black &#x3D; 0x90,</span><br><span class="line">  red &#x3D; 0xe9,</span><br><span class="line">  green &#x3D; 0x179,</span><br><span class="line">  blue &#x3D; 0x262,</span><br><span class="line">  white &#x3D; 0x3db</span><br><span class="line">&#125;</span><br><span class="line">(gdb) || grep red</span><br><span class="line">  red &#x3D;&gt; 0xe9,</span><br><span class="line"></span><br><span class="line">(gdb) | -d ! echo this contains a | char\n ! sed -e &#39;s&#x2F;|&#x2F;PIPE&#x2F;&#39;</span><br><span class="line">this contains a PIPE char</span><br><span class="line">(gdb) | -d xxx echo this contains a | char!\n xxx sed -e &#39;s&#x2F;|&#x2F;PIPE&#x2F;&#39;</span><br><span class="line">this contains a PIPE char!</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>变量 <code>$_shell_exitcode</code> 和 <code>$_shell_exitsignal</code> 可以方便的检查 <code>shell</code>, <code>make</code>, <code>pipe</code> 和 <code>|</code> 最后一个 shell 命令的退出状态。</p>
<h2 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h2><p>我们可能想要将 GDB 的输出保存在文件中，GDB 提供多个命令来控制日志的输出。</p>
<ul>
<li><code>set logging on</code> - 启用日志。</li>
<li><code>set logging off</code> - 禁用日志。</li>
<li><code>set logging file filename</code> - 改变当前日志文件名。默认为 gdb.txt。</li>
<li><code>set logging overwrite [on|off]</code> - 默认情况下，GDB 将采用追加的方法写日志文件。我们可以通过设置该参数来改变其行为。</li>
<li><code>set logging redirect [on|off]</code> - 默认情况下，GDB 会同时输出到终端和日志文件中，如果设置 <code>redirect</code>，那么只会输出到日志文件。如果是使用多个 TUI 模式，在 GDB 的命令窗口没有输出，也就无法输出到日志文件中。</li>
<li><code>set logging debugredirect [on|off]</code> - 默认情况下，GDB 的调试输出同时输出到终端和日志文件中，如果设置了 <code>debugredirect</code>，那么就只会输出到日志文件中。GDB 8.1 没有这个命令。</li>
<li><code>show logging</code> - 显示当前日志配置。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb">https://sourceware.org/gdb/current/onlinedocs/gdb</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 git blame</title>
    <url>/2019/12/git-blame/</url>
    <content><![CDATA[<p>最近在向 PostgreSQL 社区提交 patch 时，发现其维护者很快就定位到了代码何时由谁更改了，作为一个萌新，我也不好意思问:(，只能自己下来查找资料，经过一番搜索，发现了 <code>git blame</code> 这个命令。</p>
<a id="more"></a>

<h2 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h2><p>Git 的 blame 子命令可以显示一个文件每一行最后的修改作者及信息。由此，我们便可以快速定位代码的修改。</p>
<p>例如，我们可以通过如下命令来查看文件的更改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame ./src/backend/utils/adt/timestamp.c</span></span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000    1) /*-------------------------------------------------------------------------</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000    2)  *</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000    3)  * timestamp.c</span><br><span class="line">cc26ea9fe2e (Peter Eisentraut   2013-04-20 11:04:41 -0400    4)  *        Functions for the built-in SQL types &quot;timestamp&quot; and &quot;interval&quot;.</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000    5)  *</span><br><span class="line">97c39498e5c (Bruce Momjian      2019-01-02 12:44:25 -0500    6)  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000    7)  * Portions Copyright (c) 1994, Regents of the University of California</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000    8)  *</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000    9)  *</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000   10)  * IDENTIFICATION</span><br><span class="line">9f2e2113869 (Magnus Hagander    2010-09-20 22:08:53 +0200   11)  *        src/backend/utils/adt/timestamp.c</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000   12)  *</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000   13)  *-------------------------------------------------------------------------</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000   14)  */</span><br><span class="line">18952f67446 (Tom Lane           2000-05-29 01:59:17 +0000   15)</span><br><span class="line">18952f67446 (Tom Lane           2000-05-29 01:59:17 +0000   16) #include &quot;postgres.h&quot;</span><br><span class="line">18952f67446 (Tom Lane           2000-05-29 01:59:17 +0000   17)</span><br><span class="line">4bc578eb838 (Marc G. Fournier   1997-04-03 19:58:11 +0000   18) #include &lt;ctype.h&gt;</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000   19) #include &lt;math.h&gt;</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000   20) #include &lt;limits.h&gt;</span><br><span class="line">dd4eea257b7 (Neil Conway        2005-06-30 03:48:58 +0000   21) #include &lt;sys/time.h&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>是不是觉得太长了不方便查看，没关系，<code>git blame</code> 还提供了参数可以控制文件中查看的内容。例如查看文件第 20 行到 40 行之间的改动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame -L 20,40 ./src/backend/utils/adt/timestamp.c</span></span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000 20) #include &lt;limits.h&gt;</span><br><span class="line">dd4eea257b7 (Neil Conway        2005-06-30 03:48:58 +0000 21) #include &lt;sys/time.h&gt;</span><br><span class="line">cb292206c5c (Peter Eisentraut   2000-07-12 22:59:15 +0000 22)</span><br><span class="line">18952f67446 (Tom Lane           2000-05-29 01:59:17 +0000 23) #include &quot;access/xact.h&quot;</span><br><span class="line">5cabcfccce4 (Tom Lane           2002-08-26 17:54:02 +0000 24) #include &quot;catalog/pg_type.h&quot;</span><br><span class="line">df1a699e5ba (Tom Lane           2017-04-05 23:51:27 -0400 25) #include &quot;common/int128.h&quot;</span><br><span class="line">b6d15590f72 (Tom Lane           2008-05-04 23:19:24 +0000 26) #include &quot;funcapi.h&quot;</span><br><span class="line">30f609484d0 (Tom Lane           2003-05-12 23:08:52 +0000 27) #include &quot;libpq/pqformat.h&quot;</span><br><span class="line">8507ddb9c63 (Thomas G. Lockhart 1997-07-01 00:22:46 +0000 28) #include &quot;miscadmin.h&quot;</span><br><span class="line">b8a18ad4850 (Noah Misch         2015-03-01 13:22:34 -0500 29) #include &quot;nodes/makefuncs.h&quot;</span><br><span class="line">c13897983a0 (Robert Haas        2012-02-08 09:33:02 -0500 30) #include &quot;nodes/nodeFuncs.h&quot;</span><br><span class="line">1fb57af9206 (Tom Lane           2019-02-09 18:08:48 -0500 31) #include &quot;nodes/supportnodes.h&quot;</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 32) #include &quot;parser/scansup.h&quot;</span><br><span class="line">bec98a31c55 (Tom Lane           2000-07-17 03:05:41 +0000 33) #include &quot;utils/array.h&quot;</span><br><span class="line">94094c05697 (Marc G. Fournier   1997-03-14 05:58:13 +0000 34) #include &quot;utils/builtins.h&quot;</span><br><span class="line">b5f7cff84f5 (Tom Lane           2005-06-29 22:51:57 +0000 35) #include &quot;utils/datetime.h&quot;</span><br><span class="line">6bf0bc842bd (Tomas Vondra       2018-07-29 03:30:48 +0200 36) #include &quot;utils/float.h&quot;</span><br><span class="line">b5f7cff84f5 (Tom Lane           2005-06-29 22:51:57 +0000 37)</span><br><span class="line">e303a2dbe8c (Tom Lane           2002-09-21 19:52:41 +0000 38) /*</span><br><span class="line">e303a2dbe8c (Tom Lane           2002-09-21 19:52:41 +0000 39)  * gcc&#x27;s -ffast-math switch breaks routines that expect exact results from</span><br><span class="line">a536b2dd80f (Bruce Momjian      2005-07-21 03:56:25 +0000 40)  * expressions like timeval / SECS_PER_HOUR, where timeval is double.</span><br></pre></td></tr></table></figure>

<p>我们还可以通过指定偏移的方式来显示。例如，下面的命令可以到达和上面的命令相同的效果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame -L 20,+21 ./src/backend/utils/adt/timestamp.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame -L 40,-21 ./src/backend/utils/adt/timestamp.c</span></span><br></pre></td></tr></table></figure>

<p>如果我们向查看一个函数的变更呢？是否需要先在源文件中查看函数的起止行，然后在指定行号呢？答案当然是 NO。我们可以通过指定函数名来完成这一需求。例如，我想要查看 <code>timestamp_part</code> 函数的更改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame -L :timestamp_part ./src/backend/utils/adt/timestamp.c</span></span><br><span class="line">ae526b40703 (Tom Lane           2000-06-09 01:11:16 +0000 4522) timestamp_part(PG_FUNCTION_ARGS)</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000 4523) &#123;</span><br><span class="line">220db7ccd8c (Tom Lane           2008-03-25 22:42:46 +0000 4524)         text       *units = PG_GETARG_TEXT_PP(0);</span><br><span class="line">1dc34982511 (Bruce Momjian      2005-10-15 02:49:52 +0000 4525)         Timestamp       timestamp = PG_GETARG_TIMESTAMP(1);</span><br><span class="line">ae526b40703 (Tom Lane           2000-06-09 01:11:16 +0000 4526)         float8          result;</span><br><span class="line">a70e13a39ec (Tom Lane           2016-03-16 19:09:04 -0400 4527)         Timestamp       epoch;</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000 4528)         int                     type,</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000 4529)                                 val;</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 4530)         char       *lowunits;</span><br><span class="line">547df0cc853 (Thomas G. Lockhart 2002-04-21 19:52:18 +0000 4531)         fsec_t          fsec;</span><br><span class="line">b6b71b85bc4 (Bruce Momjian      2004-08-29 05:07:03 +0000 4532)         struct pg_tm tt,</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000 4533)                            *tm = &amp;tt;</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000 4534)</span><br><span class="line">220db7ccd8c (Tom Lane           2008-03-25 22:42:46 +0000 4535)         lowunits = downcase_truncate_identifier(VARDATA_ANY(units),</span><br><span class="line">220db7ccd8c (Tom Lane           2008-03-25 22:42:46 +0000 4536)                                                                                         VARSIZE_ANY_EXHDR(units),</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 4537)                                                                                         false);</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 4538)</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 4539)         type = DecodeUnits(0, lowunits, &amp;val);</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 4540)         if (type == UNKNOWN_FIELD)</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 4541)                 type = DecodeSpecial(0, lowunits, &amp;val);</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 4542)</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4543)         if (TIMESTAMP_NOT_FINITE(timestamp))</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4544)         &#123;</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4545)                 result = NonFiniteTimestampTzPart(type, val, lowunits,</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4546)                                                                                   TIMESTAMP_IS_NOBEGIN(timestamp),</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4547)                                                                                   false);</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4548)                 if (result)</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4549)                         PG_RETURN_FLOAT8(result);</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4550)                 else</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4551)                         PG_RETURN_NULL();</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4552)         &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>您以为这就完了么？Too yong too simple. <code>git blame</code> 的 <code>-L</code> 参数还支持正则表达式。我们可以是下面的正则表达式方式实现上面的需求。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame -L <span class="string">&#x27;/^timestamp_part(/,/^&#125;$/&#x27;</span> ./src/backend/utils/adt/timestamp.c</span></span><br></pre></td></tr></table></figure>

<p>暂时先整理到此处，更多的用法可以查看<a href="https://git-scm.com/docs/git-blame">文档</a>或帮助手册 (<code>man git-blame</code>)。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://git-scm.com/docs/git-blame">https://git-scm.com/docs/git-blame</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 撤销已经修改的文件</title>
    <url>/2019/12/git-discard-changes/</url>
    <content><![CDATA[<p>Git 中可以通过 <code>git checkout -- &lt;file&gt;...</code> 来撤销当前工作空间的修改。例如，我们有以下文件已经做出了修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch hunghudb-11.3beta</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   src&#x2F;backend&#x2F;postmaster&#x2F;pgstat.c</span><br><span class="line">        modified:   src&#x2F;backend&#x2F;replication&#x2F;logical&#x2F;reorderbuffer.c</span><br><span class="line">        modified:   src&#x2F;backend&#x2F;storage&#x2F;file&#x2F;buffile.c</span><br><span class="line">        modified:   src&#x2F;include&#x2F;pgstat.h</span><br><span class="line">        modified:   src&#x2F;include&#x2F;replication&#x2F;reorderbuffer.h</span><br><span class="line">        modified:   src&#x2F;include&#x2F;storage&#x2F;buffile.h</span><br></pre></td></tr></table></figure>

<p>如果此时我想要撤销这些修改，我们应该怎么做呢？</p>
<a id="more"></a>

<p>最简单的方法是针对每个文件，我们可以使用下面的命令进行撤销：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- src&#x2F;backend&#x2F;postmaster&#x2F;pgstat.c</span><br></pre></td></tr></table></figure>


<p>下面的命令通过将 <code>git</code> 与 shell 结合使用，更为方便快捷。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- $(git status -s | grep &#39;^ M&#39; | cut -d&#39; &#39; -f 3)</span><br></pre></td></tr></table></figure>

<p>此外，我们还可以使用 <code>git checkout .</code> 命令来撤销所有修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- &#39;*.c&#39;</span><br></pre></td></tr></table></figure>

<p>上面的命令可以撤销所有对 C 源文件的修改。</p>
<p><a href="https://public-inbox.org/git/xmqqy2zszuz7.fsf@gitster-ct.c.googlers.com/">Git 2.23 版本中引入了 <code>git restore</code> 和 <code>git switch</code> 命令</a>，其中 <code>git restore</code> 可以用于撤销修改，其使用方式与 <code>git checkout</code> 类似。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>git restore --worktree README.md</code></td>
<td>表示撤销 README.md 文件工作区的的修改</td>
</tr>
<tr>
<td><code>git restore --staged README.md</code></td>
<td>表示撤销暂存区的修改，将文件状态恢复到未 add 之前</td>
</tr>
<tr>
<td><code>git restore -s HEAD~1 README.md</code></td>
<td>表示将当前工作区切换到上个 commit 版本</td>
</tr>
<tr>
<td><code>git restore -s &lt;commit&gt; README.md</code></td>
<td>表示将当前工作区切换到指定 commit 的版本</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://git-scm.com/docs/git-checkout">https://git-scm.com/docs/git-checkout</a><br>[2] <a href="https://public-inbox.org/git/xmqqy2zszuz7.fsf@gitster-ct.c.googlers.com/">https://public-inbox.org/git/xmqqy2zszuz7.fsf@gitster-ct.c.googlers.com/</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 跳过 SSL 验证</title>
    <url>/2019/08/git-skip-ssl-verify/</url>
    <content><![CDATA[<p>有时，我们在克隆代码或者拉取代码时想要跳过 SSL 验证（至于为什么有这么奇葩的需求就不多说了，自行体会），git 提供了多种方式可供用户选择。</p>
<p>首先，我们看来看看克隆代码时如何跳过 SSL 验证。如下，我们可以使用 <code>GIT_NO_SSL_VERIFY</code> 环境变量来设置是否采用 SSL 验证。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> GIT_SSL_NO_VERIFY=<span class="literal">true</span> git <span class="built_in">clone</span> https://github.com/xxx/xxx</span></span><br></pre></td></tr></table></figure>

<p>如果是仓库已经采用 SSL 验证克隆下来，但是在随后的拉取过程中想要取消 SSL 验证，我们可以通过修改配置来完成，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config http.sslVerify <span class="literal">false</span></span></span><br></pre></td></tr></table></figure>

<p>如果您想后续的仓库都跳过 SSL 验证，可以设置全局的 <code>http.sslVerify</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global http.sslVerify <span class="literal">false</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 多仓库分支同步</title>
    <url>/2019/01/git-sync-branches-among-remote-repositories/</url>
    <content><![CDATA[<p>今天遇到一个 git 远程仓库分支同步的问题，主要的诉求是将两个远程仓库的分支同步到一致状态。起初，项目只是在 GitHub 上进行维护，后期又在 GitLab 上创建了该项目，并且两个仓库之间的分支情况有所不同。我们可以使用如下命令同步两个远程仓库之间的分支信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch --all -p</span><br><span class="line">$ git push github &quot;refs&#x2F;remotes&#x2F;gitlab&#x2F;*:refs&#x2F;heads&#x2F;*&quot;</span><br><span class="line">$ git push gitlab &quot;refs&#x2F;remotes&#x2F;github&#x2F;*:refs&#x2F;heads&#x2F;*&quot;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> <code>github</code> 指向远端的 GitHub 项目地址，同理，<code>gitlab</code> 指向远端的 GitLab 项目地址。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何学习 Emacs</title>
    <url>/2019/03/how-to-learn-emacs/</url>
    <content><![CDATA[<img src="/2019/03/how-to-learn-emacs/How-to-Learn-Emacs-v2-Large.png" class="" title="How to Learn Emacs">


<p><a href="http://sachachua.com/blog/2013/05/how-to-learn-emacs-a-hand-drawn-one-pager-for-beginners/">上图</a>来自于 <a href="http://sachachua.com/blog/">Sacha Chua</a> 的博客。她的博客记录许多关于学习 Emacs 的资源。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse 导入证书文件</title>
    <url>/2019/01/import-certificate-into-eclipse/</url>
    <content><![CDATA[<p>现在越来越多的网站采用 HTTPS 协议，今天就遇到一个关于 HTTPS 证书的问题，服务器端采用 HTTPS 加密传输，而证书是使用的自签名证书，因此客户端开发时需要将其导入到 Eclipse 中才能通过验证（客户端采用 Java 开发）。Eclipse 采用 keystore 来管理证书，可以利用工具 <code>keytool</code> 来管理证书文件，本文主要记录 Eclipse 证书管理的基本使用，以及使用自签名证书的格式问题。</p>
<a id="more"></a>

<h3 id="导入-SSL-证书"><a href="#导入-SSL-证书" class="headerlink" title="导入 SSL 证书"></a>导入 SSL 证书</h3><p>我登陆到服务器取下了服务端使用的 SSL 证书（一个名为 ssl.pem 的文件），随后通过 <code>keytool</code> 将其导入到 Eclipse 中，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ keytool -import -alias &lt;provide_an_alias&gt; -file &lt;certificate_file&gt; -keysotre &lt;your_path_to_jre&gt;&#x2F;lib&#x2F;security&#x2F;cacerts</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> <code>&lt; &gt;</code> 中的内容需要根据实际情况填写。</p>
<p>然而我执行时出现了如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool error: java.lang.Exception: Input not an X.509 certificate</span><br><span class="line">java.lang.Exception: Input not an X.509 certificate</span><br><span class="line">        at sun.security.tools.KeyTool.addTrustedCert(KeyTool.java:1913)</span><br><span class="line">        at sun.security.tools.KeyTool.doCommands(KeyTool.java:818)</span><br><span class="line">        at sun.security.tools.KeyTool.run(KeyTool.java:172)</span><br><span class="line">        at sun.security.tools.KeyTool.main(KeyTool.java:166)</span><br></pre></td></tr></table></figure>

<h3 id="证书格式转换"><a href="#证书格式转换" class="headerlink" title="证书格式转换"></a>证书格式转换</h3><p>从上面的错误结果可以看到证书格式不是标准的 X.509 格式，于是我查看了一下 ssl.pem 文件的内容，其格式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">BASE64 ENCODING INFORMATION</span><br><span class="line">-----END PRIVATE KEY-----</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">BASE64 ENCODING INFORMATION</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>

<p>这与 X.509 的证书格式不同，因此出现上述问题。X.509 证书的格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">BASE64 ENCODING CERTIFICATE INFORMATION</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>

<p>因此，我们需要将 ssl.pem 格式的证书转换为 X.509 格式，我们利用 openssl 来实现，其命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl x509 -in ssl.pem -text</span><br></pre></td></tr></table></figure>

<p>此外，我们可以直接将 ssl.pem 文件中的 <code>-----BEGIN CERTIFICATE-----</code> 到 <code>-----END CERTIFICATE-----</code> 之间的内容拷贝出来即可。</p>
<p>现在我们再次使用 <code>keytool -import</code> 命令导入证书即可。</p>
<p><strong>备注：</strong></p>
<ol>
<li>当 <code>keytool</code> 提示输入密码时，请输入：<code>changeit</code>。这应该是默认的。</li>
<li>当 <code>keytool</code> 询问是否信任该证书时，请输入：<code>yes</code>。默认为 <code>on</code>。</li>
</ol>
<h3 id="删除证书"><a href="#删除证书" class="headerlink" title="删除证书"></a>删除证书</h3><p>当我们不再需要这个自签名证书时，可以通过如下命令将其从 keystore 中删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ keytool -delete -alias &lt;cert_alias&gt; -keystore &lt;your_path_to_jre&gt;&#x2F;lib&#x2F;security&#x2F;cacerts</span><br></pre></td></tr></table></figure>

<p>我们也可以使用下面的命令查看 keystore 中证书的详细信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ keytool -list -v -keystore &lt;your_path_to_jre&gt;&#x2F;lib&#x2F;security&#x2F;cacerts</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://stackoverflow.com/questions/684081/importing-ssl-certificate-into-eclipse">Importing SSL certificate into eclipse</a><br>[2] <a href="https://stackoverflow.com/questions/9889669/error-importing-ssl-certificate-not-an-x-509-certificate">Error importing SSL certificate not an X509 certificate</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>列存数据库 cstore_fdw 入门</title>
    <url>/2018/09/introduction-cstore-fdw-columnar-store/</url>
    <content><![CDATA[<p>Cstore_fdw 是 Citus Data 开发的一款开放源码的 PostgreSQL 列存扩展插件。列存储在数据批量导入的分析场景能够提供更好的性能。Cstore_fdw 通过只读取磁盘上相关的列数据来提升性能，同时，由于每列的数据来自同一个域，因此更利于数据压缩，cstore_fdw 提供 6~10 倍的数据压缩能力，从而减小了对磁盘存储的需求。</p>
<p>Cstore_fdw 采用 Optimized Row Columnar (ORC) 格式作为其数据的物理存储格式。ORC 优化了 Facebook 的 RCFile 存储格式，并具有以下优点：</p>
<ul>
<li>压缩 (Compression) - 大约减少了 2~4 倍的内存和磁盘存储空间。易于扩展以支持不同的编码。</li>
<li>列投影 (Column Projections) - 仅仅读取与该查询有关的数据列，提高了 I/O 效率。</li>
<li>跳跃索引 (Skip Indexes) - 为每个行组 (Row Groups) 存储其最大值和最小值，并利用他们来跳过不相关的数据行。</li>
</ul>
<p>除此之外，cstore_fdw 使用了 PostgreSQL 的数据类型和 fdw API 编程接口，这样做的好处有以下几点：</p>
<ul>
<li>支持 40+ 的 PostgreSQL 数据类型，用户也可以创建并使用新的类型。</li>
<li>统计信息收集，PostgreSQL 使用这些统计信息来评估不同的查询计划并选择最优查询计划的来执行。</li>
<li>配置简单，用户只需要创建外部表并导入数据，之后就可以使用 SQL 进行查询。</li>
</ul>
<a id="more"></a>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>Cstore_fdw 依赖 protobuf-c 来序列化和反序列化表的元数据信息，因此需要先安装 protobuf-c 套件 (Ubuntu 平台)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install protobuf-c-compiler libprotobuf-c-dev</span></span><br></pre></td></tr></table></figure>

<p>首先，编译安装 PostgreSQL 数据库，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://ftp.postgresql.org/pub/<span class="built_in">source</span>/v9.3.24/postgresql-9.3.24.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xf postgresql-9.3.24.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> postgresql-9.3.24</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=/home/postgres/postgresql-9.3.24/Debug --<span class="built_in">enable</span>-debug --<span class="built_in">enable</span>-cassert CFLAGS=<span class="string">&#x27;-O0 -g&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make &amp;&amp; make install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> Debug</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt;END &gt;pg-9.3.24.env</span></span><br><span class="line">export PGHOME=$PWD</span><br><span class="line">export PGDATA=\$PGHOME/pgdata</span><br><span class="line">export PATH=\$PGHOME/bin:\$PATH</span><br><span class="line">export LD_LIBRARY_PATH=\$PGHOME/lib:\$LD_LIBRARY_PATH</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>为了使用方便，我将 PostgreSQL 的环境变量配置到了 pg-9.3.24.env 文件中，当需要使用是只需要 source 以下即可。<br>接着，编译安装 cstore_fdw 插件，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/citusdata/cstore_fdw</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> cstore_fdw</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> . /path/to/pg-9.3.24.env</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> Cstore_fdw 支持 PostgreSQL 9.3, 9.4, 9.5, 9.6 和 10 的版本，更早的版本则不支持。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在使用 cstore_fdw 之前，我们需要将他添加到 postgresql.conf 文件的 shared_preload_libraries 中，并重启 PostgreSQL 数据库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shared_preload_libraries &#x3D; &#39;cstore_fdw&#39; # (change requires restart)</span><br></pre></td></tr></table></figure>

<p>以下四个选项可以在创建 cstore 外部表的时候指定：</p>
<ul>
<li>filename (可选) - 存放列存表数据的绝对路径，如果没有指定该选项，那么 cstore_fdw 则采用默认的 $PGHOME/cstore_fdw 来存储列存表数据。如果为该参数指定了值，则使用该值作为前缀来存储列存表数据信息。例如，当指定的 filename 值为 /cstore_fdw/my_table，那么 cstore_fdw 将使用 /cstore_fdw/my_table 来存储列存表用户数据，同时，使用 /cstore_fdw/my_table.footer 来存储列存表的元数据信息。</li>
<li>compression (可选) - 该参数用于指定用户数据的压缩算法，目前仅支持 none 和 pglz 两个值，即不压缩或者使用 pglz 压缩算法进行压缩，默认值为 none。</li>
<li>stripe_row_count (可选) - 该参数指定每个 stripe 中行记录数，默认值为 150000。该值越小，加载数据或者查询时使用的内存也就越小，相反，其性能也就越低。</li>
<li>block_row_count (可选) - 该参数指定每个列数据块 (column block) 中的行记录数，默认为 10000。Cstore_fdw 压缩数据、创建跳跃索引以及磁盘读取时都是以块 (block) 为最小单元。该值越大，则利用数据压缩，并可以减少磁盘读取的次数量，然而，这将影响到跳过不相关的数据块的概率。</li>
</ul>
<p>Cstore_fdw 提供了两种方式用于向其导入数据：</p>
<ul>
<li>使用 <code>COPY</code> 命令将文件、程序或者标准输入中导入数据；</li>
<li>使用 <code>INSERT INTO cstore_table SELECT ...</code> 语法从其他表导入数据。</li>
</ul>
<p>我们可以使用 <code>ANALYZE</code> 命令收集列存表的统计信息，从而帮助优化器选择最优的查询计划。</p>
<p><strong>注意：</strong> Cstore_fdw 目前并不支持使用 <code>UPDATE</code> 或 <code>DELETE</code> 命令来对表进行更新。同样，他也不支持单条记录的插入，这是由于每次导入数据都会形成至少一个数据块，若是支持单条记录插入，那么每个 <code>INSERT</code> 命令插入一条纪律，将导致数据块过多从而影响性能，为此，Cstore_fdw 不支持单条记录的插入。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>为了展示 cstore_fdw，我们可以使用官方给出的测试数据用以验证。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://examples.citusdata.com/customer_reviews_1998.csv.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget http://examples.citusdata.com/customer_reviews_1999.csv.gz</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> gzip -d customer_reviews_1998.csv.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gzip -d customer_reviews_1999.csv.gz</span></span><br></pre></td></tr></table></figure>

<p>接着初始化数据库并修改 <code>shared_preload_libraries</code> 参数，然后启动并登陆到 postgres 数据库，然后执行下面的命令创建列存储外部表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 在首次安装完成之后加载 cstore_fdw 插件</span><br><span class="line">CREATE EXTENSION cstore_fdw;</span><br><span class="line"></span><br><span class="line">-- 创建服务对象</span><br><span class="line">CREATE SERVER cstore_server FOREIGN DATA WRAPPER cstore_fdw;</span><br><span class="line"></span><br><span class="line">-- 创建外部表</span><br><span class="line">CREATE FOREIGN TABLE customer_reviews</span><br><span class="line">(</span><br><span class="line">    customer_id TEXT,</span><br><span class="line">    review_date DATE,</span><br><span class="line">    review_rating INTEGER,</span><br><span class="line">    review_votes INTEGER,</span><br><span class="line">    review_helpful_votes INTEGER,</span><br><span class="line">    product_id CHAR(10),</span><br><span class="line">    product_title TEXT,</span><br><span class="line">    product_sales_rank BIGINT,</span><br><span class="line">    product_group TEXT,</span><br><span class="line">    product_category TEXT,</span><br><span class="line">    product_subcategory TEXT,</span><br><span class="line">    similar_product_ids CHAR(10)[]</span><br><span class="line">)</span><br><span class="line">SERVER cstore_server</span><br><span class="line">OPTIONS(compression &#39;pglz&#39;);</span><br></pre></td></tr></table></figure>

<p>最后，我们使用 <code>COPY</code> 命令导入数据到列存储外部表中，并使用 <code>ANALYZE</code> 命令收集统计信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY customer_reviews FROM &#39;&#x2F;path&#x2F;to&#x2F;customer_reviews_1998.csv&#39; WITH CSV;</span><br><span class="line">COPY customer_reviews FROM &#39;&#x2F;path&#x2F;to&#x2F;customer_reviews_1999.csv&#39; WITH CSV;</span><br></pre></td></tr></table></figure>

<p>在执行完上述操作之后，我们就可以在列存表上执行查询操作了。例如，执行下面的查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查找特定客户在 1998 年对 Dune 系列所做的所有评论</span><br><span class="line">SELECT</span><br><span class="line">    customer_id, review_date, review_rating, product_id, product_title</span><br><span class="line">FROM</span><br><span class="line">    customer_reviews</span><br><span class="line">WHERE</span><br><span class="line">    customer_id &#x3D;&#39;A27T7HVDXA3K2A&#39; AND</span><br><span class="line">    product_title LIKE &#39;%Dune%&#39; AND</span><br><span class="line">    review_date &gt;&#x3D; &#39;1998-01-01&#39; AND</span><br><span class="line">    review_date &lt;&#x3D; &#39;1998-12-31&#39;;</span><br><span class="line"></span><br><span class="line">-- 我们是否有书的标题长度和评论评级之间的相关性？</span><br><span class="line">SELECT</span><br><span class="line">    width_bucket(length(product_title), 1, 50, 5) title_length_bucket,</span><br><span class="line">    round(avg(review_rating), 2) AS review_average,</span><br><span class="line">    count(*)</span><br><span class="line">FROM</span><br><span class="line">   customer_reviews</span><br><span class="line">WHERE</span><br><span class="line">    product_group &#x3D; &#39;Book&#39;</span><br><span class="line">GROUP BY</span><br><span class="line">    title_length_bucket</span><br><span class="line">ORDER BY</span><br><span class="line">    title_length_bucket;</span><br></pre></td></tr></table></figure>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>在卸载 cstore_fdw 之前，我们需要删除所有的 cstore 列存表、server 和扩展：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP FOREIGN TABLE customer_reviews;</span><br><span class="line">DROP SERVER cstore_server;</span><br><span class="line">DROP EXTENSION cstore_fds;</span><br></pre></td></tr></table></figure>

<p>Cstore_fdw 会自动的创建目录来存储列存相关的数据，我们可以执行下面的命令来删除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm -rf <span class="variable">$PGDATA</span>/cstore_fdw</span></span><br></pre></td></tr></table></figure>

<p>注意，上面给出的是 cstore_fdw 的默认路径，若在建表的时候指定了 filename，其位置可能不同。</p>
<p>此外，别忘了将 postgresql.conf 文件中 <code>shared_preload_libraries</code> 中的 <code>cstore_fdw</code> 移除掉。最后，我们可以到 cstore_fdw 的源码目录执行 <code>make uninstall</code> 删除已安装的 cstore_fdw 相关的文件。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://github.com/citusdata/cstore_fdw">https://github.com/citusdata/cstore_fdw</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>cstore_fdw</tag>
        <tag>列存</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX 页码设置</title>
    <url>/2019/03/latex-page-numbering/</url>
    <content><![CDATA[<p>默认情况下，LaTeX 会在每个页面的底部生成一个页码编号，即使是标题页也是如此。通常情况下，我们不需要在标题页输出页码编号，而且目录页一般也会采用罗马数字的形式给出页码，而正文内容则以阿拉伯数字的形式给出页码编号。本文接下来介绍了 LaTeX 中基本的页码设置。</p>
<a id="more"></a>

<h2 id="页码设置相关的命令"><a href="#页码设置相关的命令" class="headerlink" title="页码设置相关的命令"></a>页码设置相关的命令</h2><p>在 LaTex 中，与页码和页面设置相关的命令有 <code>\pagestyle&#123;type&#125;</code>，<code>\thispagestyle&#123;type&#125;</code>，<code>setcounter&#123;page&#125;&#123;number&#125;</code> 和 <code>\pagenumbering&#123;style&#125;</code>。</p>
<p>其中 <code>\pagestyle&#123;type&#125;</code> 和 <code>\thispagestyle&#123;type&#125;</code> 命令用于设置页面样式 (页眉和页脚)。<code>\pagestyle&#123;type&#125;</code> 和 <code>\thispagestyle&#123;type&#125;</code> 的主要区别在于 <code>\pagestyle&#123;type&#125;</code> 对后续所有页面都有效，而 <code>\thispagestyle&#123;type&#125;</code> 仅仅对当前页面有效。在 LaTeX 中，默认提供了以下五种页面样式：</p>
<ul>
<li><strong>empty</strong> - 没有页眉和页脚</li>
<li><strong>plain</strong> - 没有页眉，页脚包含一个居中的页码</li>
<li><strong>headings</strong> - 没有页脚，页眉包含章/节或者字节的名字和页码</li>
<li><strong>myheadings</strong> - 没有页脚，页眉包含有页码</li>
</ul>
<p>默认情况下，页码从第一页开始 (通常是包含标题页的) 并且以阿拉伯数字形式显示 (例如：1，2，3, … )。页码的编号也可以通过 <code>\setcounter&#123;page&#125;&#123;number&#125;</code> 命令手动设置，需要注意的是，手动设置可能会导致重复的页码出现。</p>
<p><code>\pagenumbering&#123;style&#125;</code> 命令则用于改变页码的显示风格。LaTeX 中页码风格包含以下五类：</p>
<ul>
<li><strong>arabic</strong> - 阿拉伯数字</li>
<li><strong>roman</strong> - 小写的罗马数字</li>
<li><strong>Roman</strong> - 大写的罗马数字</li>
<li><strong>alph</strong> - 小写的字符形式</li>
<li><strong>Alph</strong> - 大写的字符形式</li>
</ul>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;fontspec, xunicode, xlextra&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;xeCJK&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">title</span><span class="string">&#123;\LaTeX 页码设置&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">author</span><span class="string">&#123;Japinli&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">maketitle</span></span></span><br><span class="line"><span class="tag">\<span class="name">thispagestyle</span><span class="string">&#123;empty&#125;</span></span> <span class="comment">% 当前页不显示页码</span></span><br><span class="line"><span class="tag">\<span class="name">newpage</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">pagestyle</span><span class="string">&#123;headings&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">setcounter</span><span class="string">&#123;page&#125;</span><span class="string">&#123;1&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">pagenumbering</span><span class="string">&#123;Roman&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">section*</span><span class="string">&#123;前言&#125;</span></span></span><br><span class="line">学习如何在<span class="tag">\<span class="name">LaTeX</span></span> 中设置页码。</span><br><span class="line"><span class="tag">\<span class="name">newpage</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">tableofcontents</span></span></span><br><span class="line"><span class="tag">\<span class="name">newpage</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">setcounter</span><span class="string">&#123;page&#125;</span><span class="string">&#123;1&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">pagenumbering</span><span class="string">&#123;arabic&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">section</span><span class="string">&#123;页码风格&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">LaTeX</span></span> 中包含五种页码风格，分别是<span class="tag">\<span class="name">emph</span><span class="string">&#123;arabic&#125;</span></span>，<span class="tag">\<span class="name">emph</span><span class="string">&#123;roman&#125;</span></span>，<span class="tag">\<span class="name">emph</span><span class="string">&#123;Roman&#125;</span></span>，</span><br><span class="line"><span class="tag">\<span class="name">emph</span><span class="string">&#123;alph&#125;</span></span>和<span class="tag">\<span class="name">emph</span><span class="string">&#123;Alph&#125;</span></span>。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">section</span><span class="string">&#123;页码风格说明&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">emph</span><span class="string">&#123;arabic&#125;</span></span>代表阿拉伯数字类型。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">emph</span><span class="string">&#123;roman&#125;</span></span>代表小写的罗马数字类型。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">emph</span><span class="string">&#123;Roman&#125;</span></span>代表大写的罗马数字类型。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">emph</span><span class="string">&#123;alph&#125;</span></span>代表小写的字符类型。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">emph</span><span class="string">&#123;Alph&#125;</span></span>代表大写的字符类型。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">section</span><span class="string">&#123;页码风格设置&#125;</span></span></span><br><span class="line"></span><br><span class="line">为了改变页码的风格，可以使用<span class="tag">\<span class="name">emph</span><span class="string">&#123;\textbackslash pagenumbering\&#123;sytle\&#125;</span></span>&#125;</span><br><span class="line">命令设置。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排版</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>小米路由器刷 Breed 和 Padavan 固件</title>
    <url>/2020/07/miwifi-breed-padavan/</url>
    <content><![CDATA[<p>本文主要记录一下小米路由器 3G 刷 breed 和 padavan 的过程。</p>
<ul>
<li><a href="https://openwrt.org/docs/techref/bootloader/breed">Breed</a> 是嵌入式设备的引导和恢复环境的简称。</li>
<li>Padavan 是由俄罗斯人基于华硕源码开发的针对 mtk 芯片的固件。</li>
</ul>
<p>我将整个过程分为分为 5 个步骤，更新 ROM、开启 SSH、备份路由器、刷 breed、刷 padavan。</p>
<a id="more"></a>

<h2 id="更新路由器-ROM"><a href="#更新路由器-ROM" class="headerlink" title="更新路由器 ROM"></a>更新路由器 ROM</h2><p>首先，我们需要将小米路由器的 ROM 更新为开发版，在小米的 <a href="http://miwifi.com/miwifi_download.html">miwifi 下载页面</a>找到路由器对应的开发版 ROM（<a href="http://bigota.miwifi.com/xiaoqiang/rom/r3g/miwifi_r3g_firmware_12f97_2.25.124.bin">R3G ROM 开发版</a>）。</p>
<p>ROM 的升级有两种方式：</p>
<ol>
<li><p>登陆路由器后台在线升级，我采用的这种方式，简单快捷。</p>
</li>
<li><p>如果不行的话，可以将其拷贝到 U 盘根目录，并命名为 miwifi.bin。<strong>随后断开电源，插上 U 盘，并按住 reset 按钮后插入电源，等到指示灯变为黄色闪烁状态后松开 reset 键，之后路由器将更新 ROM 并重启进入正常状态（指示灯变为蓝色常亮）。</strong></p>
</li>
</ol>
<h2 id="开启-SSH"><a href="#开启-SSH" class="headerlink" title="开启 SSH"></a>开启 SSH</h2><p>接下来，我们开启路由器的 ssh 功能，在 <a href="http://miwifi.com/miwifi_open.html">miwifi 开放</a> 找到__开启 SSH 工具__下载 miwifi_ssh.bin，这里需要使用小米账号对路由器进行绑定，绑定了之后小米会给出一个 root 用户的密码。</p>
<p>接着将下载的 miwifi_ssh.bin 拷贝到 U 盘根目录（__名称必须为 miwifi_ssh.bin__），如果之前是用 U 盘升级的 ROM，建议将 miwifi.bin 删除。</p>
<p>最后，将路由器断电，插上 U 盘，并按住 reset 按钮后插入电源，等到指示灯变为黄色闪烁状态后松开 reset 键，待蓝灯亮起时表示 ssh 开启完成。我们便可以使用 <code>ssh root@192.168.1.1</code> 登陆路由器了。</p>
<h2 id="备份路由器"><a href="#备份路由器" class="headerlink" title="备份路由器"></a>备份路由器</h2><p>这个步骤我其实是没有做的，一开始我是按照<a href="https://blog.csdn.net/z619193774/article/details/81507917">参考文献 [1]</a> 来做的，现在想想还是挺后怕的，这就是所谓的无知者无谓吧！登陆路由器后，我们使用下面的命令对路由器进行备份。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /dev/sd*</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mount /dev/sda1 /mnt <span class="comment"># 找到属于你的 U 盘</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> name <span class="keyword">in</span> $(grep -v <span class="string">&#x27;dev&#x27;</span> /proc/mtd | awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>); <span class="keyword">do</span> dd <span class="keyword">if</span>=/dev/<span class="variable">$name</span> of=/mnt/<span class="variable">$name</span>.bin; <span class="keyword">done</span></span></span><br></pre></td></tr></table></figure>

<h2 id="刷-Breed"><a href="#刷-Breed" class="headerlink" title="刷 Breed"></a>刷 Breed</h2><p>在 <a href="https://breed.hackpascal.net/">Breed</a> 网址上找到对应的版本，小米路由器 R3G 对应的 breed 为 <a href="https://breed.hackpascal.net/breed-mt7621-xiaomi-r3g.bin">breed-mt7621-xiaomi-r3g.bin</a>。然后将其通过 <code>scp</code> 拷贝到路由器上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scp breed-mt7621-xiaomi-r3g.bin root@192.168.1.1:/tmp/</span></span><br></pre></td></tr></table></figure>

<p>随后登陆到小米路由器，执行下面的命令刷入 breed：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mtd -r write /tmp/breed-mt7621-xiaomi-r3g.bin Bootloader</span></span><br></pre></td></tr></table></figure>

<p>刷入成功后，路由器将会重启，等到重启完成之后，拔掉电源，按住 reset 按钮，插电开机，等到路由器蓝灯闪烁时，在浏览器中输入 192.168.1.1，就可以进入 breed 的控制台了。</p>
<p>在 breed 控制台中，选择__固件备份__，备份 EEPRO 和编程固件，这样我们可以在之后刷回原来的系统。</p>
<h2 id="刷-Padavan-固件"><a href="#刷-Padavan-固件" class="headerlink" title="刷 Padavan 固件"></a>刷 Padavan 固件</h2><p>在 <a href="http://opt.cn2qq.com/padavan/">Padavan</a> 下载页面下载小米路由器 R3G 版本 <a href="http://opt.cn2qq.com/padavan/MI-R3G_3.4.3.9-099.trx">MI-R3G_3.4.3.9-099.trx</a>。登陆 breed，在__固件更新__中选择__固件__，随后浏览本地文件选择我们下载的 MI-R3G_3.4.3.9-099.trx 文件，点击上传，上传成功之后将自动更新固件，最后完成之后，我们可以通过访问 192.168.123.1 来登陆 padavan，用户名和密码默均为 <code>admin</code>，初始化的 wifi 名称为 <code>PCDN</code> 和 <code>PCDN_5G</code>，密码为 <code>1234567890</code>。</p>
<img src="/2020/07/miwifi-breed-padavan/padavan.jpg" class="" title="Padavan 管理界面">

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>在上文中使用的 U 盘需为 FAT/FTA32 格式化的。</li>
<li>可能需要使用网线连接路由器进行配置。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://blog.csdn.net/z619193774/article/details/81507917">https://blog.csdn.net/z619193774/article/details/81507917</a><br>[2] <a href="https://schaepher.github.io/2019/10/12/xiaomi-router-r3-openwrt/">https://schaepher.github.io/2019/10/12/xiaomi-router-r3-openwrt/</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>R3G</tag>
        <tag>breed</tag>
        <tag>padavan</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT (v8.x) 主题添加近期文章</title>
    <url>/2020/08/next-8-0-0-recent-posts/</url>
    <content><![CDATA[<p>最近将博客由 NexT-v5.x 迁移到 NexT-v8.x 版本，这其中有很多东西已将发生变化了。本文简要介绍一下如何在新版中加入近期文章的功能。NexT-v8.x 版本将模版文件由原来的 <code>swig</code> 变更为 <code>njk</code> 后缀，因此，之前的近期文章的功能不再适用，我们需要稍作修改。</p>
<a id="more"></a>

<h2 id="创建自定义文件"><a href="#创建自定义文件" class="headerlink" title="创建自定义文件"></a>创建自定义文件</h2><p>NexT-v8.x 支持自定义 <code>njk</code> 文件，从而避免修改 NexT 的源码，见参考链接 [<a href="https://theme-next.js.org/docs/advanced-settings/custom-files.html?highlight=sideb">2</a>]。我们在站点的 <code>source</code> 目录下创建 <code>_data/sidebar.njk</code> 文件，并加入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- recent posts --&gt;</span><br><span class="line">&#123;%- if theme.recent_posts %&#125;</span><br><span class="line">    &lt;div class&#x3D;&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts_layout &#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;links-of-blogroll-title recent-posts-title&quot;&gt;</span><br><span class="line">	    &lt;i class&#x3D;&quot;fa fa-history &#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">            &#123;&#123; theme.recent_posts_title &#125;&#125;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;ul class&#x3D;&quot;links-of-blogroll-list recent-posts-list&quot;&gt;</span><br><span class="line">	    &#123;%- set posts &#x3D; site.posts.sort(&#39;-date&#39;).toArray() %&#125;</span><br><span class="line">	    &#123;%- for post in posts.slice(&#39;0&#39;, &#39;5&#39;) %&#125;</span><br><span class="line">	        &lt;li class&#x3D;&quot;my-links-of-blogroll-item&quot;&gt;</span><br><span class="line">		    &lt;a href&#x3D;&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; post.title &#125;&#125;&quot; target&#x3D;&quot;&quot;&gt;</span><br><span class="line">		    &#123;&#123; post.title &#125;&#125;</span><br><span class="line">		    &lt;&#x2F;a&gt;</span><br><span class="line">		&lt;&#x2F;li&gt;</span><br><span class="line">	    &#123;%- endfor %&#125;</span><br><span class="line">	&lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h2><p>接着我们在站点目录下的主题配置文件（_config.next.yml）中加入如下内容开启近期文章功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">recent_posts: true</span><br><span class="line">recent_posts_title: 近期文章</span><br><span class="line">recent_posts_layout: block</span><br></pre></td></tr></table></figure>

<p>接着重启服务，我们便可以看到如下所示的近期文章板块。</p>
<img src="/2020/08/next-8-0-0-recent-posts/recent-posts.jpg" class="">

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://theme-next.js.org/next-8-0-0-rc-1-released/">https://theme-next.js.org/next-8-0-0-rc-1-released/</a><br>[2] <a href="https://theme-next.js.org/docs/advanced-settings/custom-files.html?highlight=sideb">https://theme-next.js.org/docs/advanced-settings/custom-files.html?highlight=sideb</a><br>[3] <a href="https://hasaik.com/posts/ab21860c.html">https://hasaik.com/posts/ab21860c.html</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Ping 权限拒绝</title>
    <url>/2018/09/ping-permission-denied/</url>
    <content><![CDATA[<p>今天在 CentOS 上遇到一个奇怪的问题，ping 程序在 root 用户下能正常使用，但是在非 root 用户下则出现如下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user@host:~ $ ping 127.0.0.1</span><br><span class="line">ping: socket: Permission denied</span><br></pre></td></tr></table></figure>

<p>在 StackExchage 上也有人遇到了<a href="https://unix.stackexchange.com/questions/385980/ping-socket-permission-denied">类似的问题</a>，他需要在 PHP 中调用 ping 命令，并且他通过执行 <code>setenforce 0</code> 可以让 ping 命令正常使用，但是经我测试发现这种方法对我无效。</p>
<p>之后在 LinuxQuestions 上发现<a href="https://www.linuxquestions.org/questions/linux-embedded-and-single-board-computer-78/socket-permission-denied-915704/">有人</a>指出 ping 命名将创建原始套接字而非 TCP 套接字，然而 Linux 系统对于普通用户创建原开套接字是禁止的，因此我们就看到了文章开始的错误，针对这一问题他也提出了解决方案，即为 ping 命令添加 suid 权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user@host:~ $ chmod +s /bin/ping</span><br><span class="line">user@host:~ $ ls -al /bin/ping</span><br><span class="line">-rwsr-xr-x 1 root root 64424 Mar 10  2017 /bin/ping</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>那么什么是 suid 权限呢？我们所熟悉的文件权限包括读、写和可执行 (r/w/x) 三种权限，其实在 Linux 系统中对所有文件还有三种特殊的权限说明，即 SUID, SGID 和 Sticky Bits。</p>
<h3 id="Sticky-Bit"><a href="#Sticky-Bit" class="headerlink" title="Sticky Bit"></a>Sticky Bit</h3><p>由于 Unix 是多用户操作系统并且设计为多个用户可以同时使用，而 Sticky Bit 则告诉 Unix 系统一旦程序被执行，那么他将一直保留在内存当中，这样可以避免不同用户执行同一程序进行多次加载。在设置了 Sticky Bit 位后，当一个用户使用了这个程序，另一个用户再次使用时可以避免初始化该程序的过程。Sticky Bit 的概念在快速磁盘访问 (Fast Disk Access) 和内存访问技术 (Memory Access Technologies) 出现之前非常有用。随着技术的发展程序加载到内存的时间的减少，Sticky Bit 的概念逐渐被废弃，因此，目前 Sticky Bit 的作用不是很明显。需要注意的是 Sticky Bit 只能用于可执行文件。</p>
<h3 id="SUID-Set-User-ID-Bit"><a href="#SUID-Set-User-ID-Bit" class="headerlink" title="SUID (Set User ID) Bit"></a>SUID (Set User ID) Bit</h3><p>SUID (Set User ID) 意味着当执行应用程序时，用户的 ID 将被设置为文件或程序所有者的 ID 而不是当前用户的 ID。例如，假设我有一个应用程序他的所有者为 root 并且设置和了 SUID 位，那么当我以普通用户运行该应用程序时，该应用程序依然会以 root 身份运行。这是由于 SUID 位告诉 Linux 系统为该应用程序设置 root 用户的 ID，并且在运行时始终以 root 用户的身份去运行该应用程序 (此处文件的所有者为 root 用户)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置文件 SUID 位</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod u+s filename</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 去掉文件 SUID 位</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod u<span class="_">-s</span> filename</span></span><br></pre></td></tr></table></figure>

<h3 id="SGID-Set-Group-ID-Bit"><a href="#SGID-Set-Group-ID-Bit" class="headerlink" title="SGID (Set Group ID) Bit"></a>SGID (Set Group ID) Bit</h3><p>SGID (Set Group ID) 与 SUID 类似，他意味着文件执行时设置其执行的用户组 ID。通常情况下，在 Linux/Unix 系统中程序运行时会继承当前登录用户的权限。SGID 则可以给运行的程序临时修改有效用户组为文件所属的组。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置文件 SGID 位</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod g+s filename</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 去掉文件 SGID 位</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod g<span class="_">-s</span> filename</span></span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.codecoffee.com/tipsforlinux/articles/028.html">What are the SUID, SGID and the Sticky Bits?</a></li>
</ol>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>ping</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 修改配置参数</title>
    <url>/2020/06/postgresql-alter-system/</url>
    <content><![CDATA[<p>今天在使用 <code>ALTER SYSTEM</code> 来修改 PostgreSQL 参数时遇到无法启动数据库的问题。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# ALTER SYSTEM SET shared_preload_libraries TO &#39;pg_buffercache,passwordcheck&#39;;</span><br><span class="line">ALTER SYSTEM</span><br><span class="line">postgres&#x3D;# \q</span><br><span class="line">$ pg_ctl restart</span><br><span class="line">waiting for server to shut down.... done</span><br><span class="line">server stopped</span><br><span class="line">waiting for server to start....postgres: could not access directory &quot;&#x2F;Users&#x2F;japinli&#x2F;Codes&#x2F;postgresql&#x2F;pg&#x2F;data&quot;: No such file or directory</span><br><span class="line">Run initdb or pg_basebackup to initialize a PostgreSQL data directory.</span><br><span class="line"> stopped waiting</span><br><span class="line">pg_ctl: could not start server</span><br><span class="line">Examine the log output.</span><br></pre></td></tr></table></figure>

<p>你是否也遇到了这样的问题呢？其实这都是由于我们先入为主的思想导致的，<code>ALTER SYSTEM</code> 支持以逗号分割的列表，而这类参数的修改不需要使用引号。因此，正确的使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER SYSTEM SET shared_preload_libraries TO pg_buffercache, passwordcheck;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们看看 pg_ctl 在启动时是如何加载 <code>shared_preload_libraries</code> 配置文件的。这里我们需要注意的是 pg_ctl 最终还是调用 postgres 来启动。通过分析我们可以发现 <code>shared_preload_libraries</code> 参数是在 <code>PostmasterMain()</code> 函数中调用 <code>process_shared_preload_libraries()</code> 来处理的，该函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">process_shared_preload_libraries(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    process_shared_preload_libraries_in_progress = <span class="literal">true</span>;</span><br><span class="line">    load_libraries(shared_preload_libraries_string,</span><br><span class="line">                   <span class="string">&quot;shared_preload_libraries&quot;</span>,</span><br><span class="line">                   <span class="literal">false</span>);</span><br><span class="line">    process_shared_preload_libraries_in_progress = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，<code>shared_preload_libraries</code> 是通过 <code>load_libraries()</code> 函数处理的，<code>load_libraries()</code> 函数则是通过 <code>SplitDirectoriesString()</code> 函数来处理的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">SplitDirectoriesString(<span class="keyword">char</span> *rawstring, <span class="keyword">char</span> separator,</span><br><span class="line">                       List **namelist)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>       *nextp = rawstring;</span><br><span class="line">    <span class="keyword">bool</span>        done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    *namelist = NIL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (scanner_isspace(*nextp))</span><br><span class="line">        nextp++;                <span class="comment">/* skip leading whitespace */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*nextp == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;            <span class="comment">/* allow empty string */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* At the top of the loop, we are at start of a new directory. */</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>       *curname;</span><br><span class="line">        <span class="keyword">char</span>       *endp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*nextp == <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Quoted name --- collapse quote-quote pairs */</span></span><br><span class="line">            curname = nextp + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;)</span><br><span class="line">            &#123;</span><br><span class="line">                endp = <span class="built_in">strchr</span>(nextp + <span class="number">1</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (endp == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">/* mismatched quotes */</span></span><br><span class="line">                <span class="keyword">if</span> (endp[<span class="number">1</span>] != <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span>;      <span class="comment">/* found end of quoted name */</span></span><br><span class="line">                <span class="comment">/* Collapse adjacent quotes into one quote, and look again */</span></span><br><span class="line">                memmove(endp, endp + <span class="number">1</span>, <span class="built_in">strlen</span>(endp));</span><br><span class="line">                nextp = endp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* endp now points at the terminating quote */</span></span><br><span class="line">            nextp = endp + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Unquoted name --- extends to separator or end of string */</span></span><br><span class="line">            curname = endp = nextp;</span><br><span class="line">            <span class="keyword">while</span> (*nextp &amp;&amp; *nextp != separator)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* trailing whitespace should not be included in name */</span></span><br><span class="line">                <span class="keyword">if</span> (!scanner_isspace(*nextp))</span><br><span class="line">                    endp = nextp + <span class="number">1</span>;</span><br><span class="line">                nextp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curname == endp)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">/* empty unquoted name not allowed */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner_isspace(*nextp))</span><br><span class="line">            nextp++;            <span class="comment">/* skip trailing whitespace */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*nextp == separator)</span><br><span class="line">        &#123;</span><br><span class="line">            nextp++;</span><br><span class="line">            <span class="keyword">while</span> (scanner_isspace(*nextp))</span><br><span class="line">                nextp++;        <span class="comment">/* skip leading whitespace for next */</span></span><br><span class="line">            <span class="comment">/* we expect another name, so done remains false */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*nextp == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;       <span class="comment">/* invalid syntax */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Now safe to overwrite separator with a null */</span></span><br><span class="line">        *endp = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Truncate path if it&#x27;s overlength */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(curname) &gt;= MAXPGPATH)</span><br><span class="line">            curname[MAXPGPATH - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Finished isolating current name --- add it to list</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        curname = pstrdup(curname);</span><br><span class="line">        canonicalize_path(curname);</span><br><span class="line">        *namelist = lappend(*namelist, curname);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Loop back if we didn&#x27;t reach end of string */</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!done);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的 22-38 行代码，我们可以看到，postgres 在处理带有双引号的内容是将其作为一个整体来处理的，因此，我们的 <code>shared_preload_libraries</code> 配置无法通过。</p>
<p>关于 <code>shared_preload_libraries</code> 的处理流程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt; PostmasterMain()</span><br><span class="line">    |</span><br><span class="line">    +-&gt; process_shared_preload_libraries()</span><br><span class="line">         |</span><br><span class="line">         +-&gt; load_libraries()</span><br><span class="line">              |</span><br><span class="line">              +-&gt; SplitDirectoriesString()</span><br></pre></td></tr></table></figure>

<p>那么为什么 <code>ALTER SYSTEM</code> 在写入时要加上双引号呢？我们先看看 <code>share_preload_libraries</code> 参数的相关设置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;shared_preload_libraries&quot;</span>, PGC_POSTMASTER, CLIENT_CONN_PRELOAD,</span><br><span class="line">        gettext_noop(<span class="string">&quot;Lists shared libraries to preload into server.&quot;</span>),</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        GUC_LIST_INPUT | GUC_LIST_QUOTE | GUC_SUPERUSER_ONLY</span><br><span class="line">    &#125;,</span><br><span class="line">    &amp;shared_preload_libraries_string,</span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>参数 <code>shared_preload_libraries</code> 的 <code>flag</code> 为 <code>GUC_LIST_INPUT | GUC_LIST_QUOTE | GUC_SUPERUSER_ONLY</code>，而我们使用的 <code>&#39;pg_buffercache,passwordcheck&#39;</code> 是作为一个整体，而不是 LIST 来处理的，因此，在写入是由于有特殊的分割符，所以就需要加上双引号，从而导致错误。</p>
<p>关于 <code>ALTER SYSTEM</code> 命令的处理可以查看 <code>gram.y</code> 中的 <code>AlterSystemStmt</code> 定义，随后接着分析 <code>AlterSystemSetConfigFile()</code> 函数，其处理流程大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt; AlterSystemSetConfigFile()</span><br><span class="line">    |</span><br><span class="line">    +-&gt; ExtractSetVariableArgs()</span><br><span class="line">         |</span><br><span class="line">         +-&gt; ExtractSetVariableArgs()</span><br><span class="line">              |</span><br><span class="line">              +-&gt; flatten_set_variable_args()</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/10/sql-altersystem.html">https://www.postgresql.org/docs/10/sql-altersystem.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 13 - backtrace 功能预览</title>
    <url>/2020/08/postgresql-backtrace/</url>
    <content><![CDATA[<p>目前在 Greenplum、MySQL 数据库中均支持 backtrace 功能，现在 PostgreSQL 13-devel 版本中也新增了这个功能，我们可以在服务器日志中记录堆栈信息。</p>
<img src="/2020/08/postgresql-backtrace/backtrace.png" class="" title="Backtrace 提交记录">

<p>本文将对该功能进行简要介绍。</p>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PostgreSQL 13 数据库提供了一个参数 <code>backtrace_functions</code> 来控制堆栈信息的生成，该参数是包含C函数名称的逗号分隔列表。如果出现错误，并且该错误是由 <code>backtrace_functions</code> 中的 C 函数引发的，那么将会把堆栈信息记录到服务器日志文件中。这个选项可以方便我们调试特定区域的源代码。</p>
<p>目前并非所有平台都支持 backtrace 功能，并且其堆栈信息的质量也取决于编译选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET backtrace_functions TO &#39;ProcessUtility,ExecutorStart&#39;;</span><br></pre></td></tr></table></figure>

<p>该参数仅超级用户可以设置，它可以在 postgresql.conf 中进行全局设置，也可以针对某个会话进行设置。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在这里我们通过创建一个不存在的类型来演示如何使用 backtrace 功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# CREATE TABLE foo(id invalidtype);</span><br><span class="line">ERROR:  type &quot;invalidtype&quot; does not exist</span><br><span class="line">LINE 1: CREATE TABLE foo(id invalidtype);</span><br><span class="line">                            ^</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，我们输入的数据类型不存在，下面是服务器端的日志信息。总的来说信息是很有限的，我们无法得知更多的细节。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-08-15 18:03:35.857 CST [1666] ERROR:  type &quot;invalidtype&quot; does not exist at character 21</span><br><span class="line">2020-08-15 18:03:35.857 CST [1666] STATEMENT:  CREATE TABLE foo(id invalidtype);</span><br></pre></td></tr></table></figure>

<p>现在我们来试试 backtrace 大法。首先我们可以通过搜索源码的方法确定当前错误是来自那个内部的 C 函数。这里我们确定它是由 <code>typenameType()</code> 函数抱出来的。那么我们可以按如下方式进行操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# SET backtrace_functions TO &#39;typenameType&#39;;</span><br><span class="line">SET</span><br><span class="line">postgres&#x3D;# CREATE TABLE foo(id invalidtype);</span><br><span class="line">ERROR:  type &quot;invalidtype&quot; does not exist</span><br><span class="line">LINE 1: CREATE TABLE foo(id invalidtype);</span><br><span class="line">                            ^</span><br></pre></td></tr></table></figure>

<p>虽然在用户看来并没有什么区别，但是服务器日志里面多出了一下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-08-15 18:09:25.079 CST [1666] ERROR:  type &quot;invalidtype&quot; does not exist at character 21</span><br><span class="line">2020-08-15 18:09:25.079 CST [1666] BACKTRACE:</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(typenameType+0xb9) [0x563456c5f509]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(+0x1dcbbc) [0x563456c60bbc]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(transformCreateStmt+0x4da) [0x563456c6412a]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(+0x3d88c8) [0x563456e5c8c8]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(standard_ProcessUtility+0x230) [0x563456e5b7e0]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(+0x3d5012) [0x563456e59012]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(+0x3d5a93) [0x563456e59a93]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(PortalRun+0x161) [0x563456e5a611]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(+0x3d2017) [0x563456e56017]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(PostgresMain+0x1ede) [0x563456e5842e]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(+0x355cda) [0x563456dd9cda]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(PostmasterMain+0xeff) [0x563456ddadef]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(main+0x4a4) [0x563456b45e94]</span><br><span class="line">        &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(__libc_start_main+0xe7) [0x7f5502994b97]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(_start+0x2a) [0x563456b45f5a]</span><br><span class="line">2020-08-15 18:09:25.079 CST [1666] STATEMENT:  CREATE TABLE foo(id invalidtype);</span><br></pre></td></tr></table></figure>

<p>从上面的 backtrace 可以看到整个流程是如何一步一步走到 <code>typenameType()</code> 函数的。Backtrace 的每一行都包含函数的名称，函数内的偏移位置，以及栈帧的返回地址。在某些栈帧上，函数名称并没有出现，取而代之的是一个地址，这些函数是静态函数，它们的名字不会被导出，不过我们也可能通过它们的地址来获取其对应的函数名称。例如，<code>typenameType()</code> 函数的上层函数只是一个地址，我们并不知道其对应的函数是什么，这时我们可以使用下面的命令来进行转换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> addr2line 0x1dcbbc -a -f -e `<span class="built_in">which</span> postgres`</span></span><br><span class="line">0x00000000001dcbbc</span><br><span class="line">transformColumnDefinition</span><br><span class="line">parse_utilcmd.c:?</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>0x1dcbbc</code> 这个地址对应的是 <code>transformColumnDefinition()</code> 函数，它位于 <code>parse_utilcmd.c</code> 文件中。由于这里是采用的 <code>-O2</code> 优化，没能查看到更多的信息，如果我们使用 <code>-O0</code>，那么其查询的信息将更为丰富，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> addr2line +0x2525e6 -a -f -e `<span class="built_in">which</span> postgres`</span></span><br><span class="line">0x00000000002525e6</span><br><span class="line">transformColumnDefinition</span><br><span class="line">/home/japin/Codes/postgresql/Debug/../src/backend/parser/parse_utilcmd.c:568</span><br></pre></td></tr></table></figure>

<p>上面两次查看的地址不一致是因为重新编译生成的文件不同导致的。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>现在我们对于 backtrace 的功能有了基本的了解，接下来我们来看看它是如何实现的。</p>
<p>该功能是通过 <code>backtrace()</code> 和 <code>backtrace_symbols()</code> 这两个简单的函数来生成堆栈信息，<code>backtrace()</code> 函数仅返回所有栈帧的返回地址，接着调用 <code>backtrace_symbols()</code> 函数来将这些地址转换为描述这个函数的字符串，PostgreSQL backtrace功能的其核心代码主要集中在 <code>set_backtrace()</code> 函数中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Compute backtrace data and add it to the supplied ErrorData.  num_skip</span></span><br><span class="line"><span class="comment"> * specifies how many inner frames to skip.  Use this to avoid showing the</span></span><br><span class="line"><span class="comment"> * internal backtrace support functions in the backtrace.  This requires that</span></span><br><span class="line"><span class="comment"> * this and related functions are not inlined.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">set_backtrace(ErrorData *edata, <span class="keyword">int</span> num_skip)</span><br><span class="line">&#123;</span><br><span class="line">	StringInfoData errtrace;</span><br><span class="line"></span><br><span class="line">	initStringInfo(&amp;errtrace);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_BACKTRACE_SYMBOLS</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">void</span>	   *buf[<span class="number">100</span>];</span><br><span class="line">		<span class="keyword">int</span>			nframes;</span><br><span class="line">		<span class="keyword">char</span>	  **strfrms;</span><br><span class="line"></span><br><span class="line">		nframes = backtrace(buf, lengthof(buf));</span><br><span class="line">		strfrms = backtrace_symbols(buf, nframes);</span><br><span class="line">		<span class="keyword">if</span> (strfrms == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = num_skip; i &lt; nframes; i++)</span><br><span class="line">			appendStringInfo(&amp;errtrace, <span class="string">&quot;\n%s&quot;</span>, strfrms[i]);</span><br><span class="line">		<span class="built_in">free</span>(strfrms);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	appendStringInfoString(&amp;errtrace,</span><br><span class="line">						   <span class="string">&quot;backtrace generation is not supported by this installation&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	edata-&gt;backtrace = errtrace.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>set_backtrace()</code> 函数通过 <code>backtrace()</code> 和 <code>backtrace_symbols()</code> 函数来获取堆栈信息，并将其添加到 <code>edata-&gt;backtrace</code> 字段中（方便后续处理），<code>num_skip</code> 参数指定了需要跳过的内部栈的数量，这是由于我们报错的地方实际上并不是 <code>set_backtrace()</code> 函数位置，而是在调用该函数的位置（可能是一层或多层），因此，我们需要定位到真实报错的地方，从这个地方开始输出堆栈信息。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://amitdkhan-pg.blogspot.com/2020/07/backtraces-in-postgresql.html">https://amitdkhan-pg.blogspot.com/2020/07/backtraces-in-postgresql.html</a><br>[2] <a href="https://www.postgresql.org/docs/devel/runtime-config-developer.html">https://www.postgresql.org/docs/devel/runtime-config-developer.html</a><br>[3] <a href="https://github.com/postgres/postgres/commit/71a8a4f6e36547bb060dbcc961ea9b57420f7190">https://github.com/postgres/postgres/commit/71a8a4f6e36547bb060dbcc961ea9b57420f7190</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 聚簇索引</title>
    <url>/2019/11/postgresql-cluster-index/</url>
    <content><![CDATA[<p>聚簇索引是按照数据存放的物理位置为顺序的，每个表仅有一个聚簇索引。</p>
<p>MySQL 数据库中的 InnoDB 引擎中的主键即为聚簇索引，当我们在表上定义主键时，InnoDB 会将其用作聚簇索引，如果表上没有定义主键，那么 InnoDB 将会使用第一个全不为空的唯一性索引作为聚簇索引，如果表上即没有主键、也没有唯一性索引，那么 InnoDB 将会自动生成一个隐藏的 <code>GEN_CLUST_INDEX</code> 索引作为聚簇索引。</p>
<p>PostgreSQL 在创建表时并不能指定聚簇索引，但是我们可以通过 <code>CLUSTER</code> 来创建聚簇索引，本文主要介绍 PostgreSQL 数据库中的聚簇索引。</p>
<a id="more"></a>

<p>我们首先建立一个数据表，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# CREATE TABLE account (id integer, nickname text, password text);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres&#x3D;# \d account</span><br><span class="line">               Table &quot;public.account&quot;</span><br><span class="line">  Column  |  Type   | Collation | Nullable | Default</span><br><span class="line">----------+---------+-----------+----------+---------</span><br><span class="line"> id       | integer |           |          |</span><br><span class="line"> nickname | text    |           |          |</span><br><span class="line"> password | text    |           |          |</span><br></pre></td></tr></table></figure>

<p>随后，我们随机插入一些数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# INSERT INTO account SELECT id, &#39;user&#39; || id::text, md5(id::text)</span><br><span class="line">postgres-# FROM generate_series(1, 100) id ORDER BY random();</span><br><span class="line">INSERT 0 100</span><br><span class="line">postgres&#x3D;# SELECT ctid, * FROM account LIMIT 20;</span><br><span class="line">  ctid  | id | nickname |             password</span><br><span class="line">--------+----+----------+----------------------------------</span><br><span class="line"> (0,1)  | 85 | user85   | 3ef815416f775098fe977004015c6193</span><br><span class="line"> (0,2)  | 22 | user22   | b6d767d2f8ed5d21a44b0e5886680cb9</span><br><span class="line"> (0,3)  | 43 | user43   | 17e62166fc8586dfa4d1bc0e1742c08b</span><br><span class="line"> (0,4)  | 89 | user89   | 7647966b7343c29048673252e490f736</span><br><span class="line"> (0,5)  | 75 | user75   | d09bf41544a3365a46c9077ebb5e35c3</span><br><span class="line"> (0,6)  | 81 | user81   | 43ec517d68b6edd3015b3edc9a11367b</span><br><span class="line"> (0,7)  | 91 | user91   | 54229abfcfa5649e7003b83dd4755294</span><br><span class="line"> (0,8)  | 65 | user65   | fc490ca45c00b1249bbe3554a4fdf6fb</span><br><span class="line"> (0,9)  | 67 | user67   | 735b90b4568125ed6c3f678819b6e058</span><br><span class="line"> (0,10) | 11 | user11   | 6512bd43d9caa6e02c990b0a82652dca</span><br><span class="line"> (0,11) | 72 | user72   | 32bb90e8976aab5298d5da10fe66f21d</span><br><span class="line"> (0,12) | 36 | user36   | 19ca14e7ea6328a42e0eb13d585e4c22</span><br><span class="line"> (0,13) | 69 | user69   | 14bfa6bb14875e45bba028a21ed38046</span><br><span class="line"> (0,14) | 32 | user32   | 6364d3f0f495b6ab9dcf8d3b5c6e0b01</span><br><span class="line"> (0,15) | 17 | user17   | 70efdf2ec9b086079795c442636b55fb</span><br><span class="line"> (0,16) | 15 | user15   | 9bf31c7ff062936a96d3c8bd1f8f2ff3</span><br><span class="line"> (0,17) | 46 | user46   | d9d4f495e875a2e075a1a4a6e1b9770f</span><br><span class="line"> (0,18) | 83 | user83   | fe9fc289c3ff0af142b6d3bead98a923</span><br><span class="line"> (0,19) | 82 | user82   | 9778d5d219c5080b9a6a17bef029331c</span><br><span class="line"> (0,20) | 20 | user20   | 98f13708210194c475687be6106a3b84</span><br><span class="line">(20 rows)</span><br></pre></td></tr></table></figure>

<p>PostgreSQL 在创建表的时候无法指定聚簇索引，我们必须使用 <code>CLUSTER</code> 命令来创建聚簇索引，此外，我们在初次创建聚簇索引时，需要指定使用的索引名。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# CLUSTER account;</span><br><span class="line">ERROR:  there is no previously clustered index for table &quot;account&quot;</span><br></pre></td></tr></table></figure>

<p>上面我们没有指定索引名，因为我们还没有对其创建索引。接下来，我们在 <code>accout</code> 表上创建一个索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# CREATE INDEX account_id_idx ON account(id);</span><br><span class="line">CREATE INDEX</span><br><span class="line">postgres&#x3D;# SELECT ctid, * FROM account LIMIT 20;</span><br><span class="line">  ctid  | id | nickname |             password</span><br><span class="line">--------+----+----------+----------------------------------</span><br><span class="line"> (0,1)  | 85 | user85   | 3ef815416f775098fe977004015c6193</span><br><span class="line"> (0,2)  | 22 | user22   | b6d767d2f8ed5d21a44b0e5886680cb9</span><br><span class="line"> (0,3)  | 43 | user43   | 17e62166fc8586dfa4d1bc0e1742c08b</span><br><span class="line"> (0,4)  | 89 | user89   | 7647966b7343c29048673252e490f736</span><br><span class="line"> (0,5)  | 75 | user75   | d09bf41544a3365a46c9077ebb5e35c3</span><br><span class="line"> (0,6)  | 81 | user81   | 43ec517d68b6edd3015b3edc9a11367b</span><br><span class="line"> (0,7)  | 91 | user91   | 54229abfcfa5649e7003b83dd4755294</span><br><span class="line"> (0,8)  | 65 | user65   | fc490ca45c00b1249bbe3554a4fdf6fb</span><br><span class="line"> (0,9)  | 67 | user67   | 735b90b4568125ed6c3f678819b6e058</span><br><span class="line"> (0,10) | 11 | user11   | 6512bd43d9caa6e02c990b0a82652dca</span><br><span class="line"> (0,11) | 72 | user72   | 32bb90e8976aab5298d5da10fe66f21d</span><br><span class="line"> (0,12) | 36 | user36   | 19ca14e7ea6328a42e0eb13d585e4c22</span><br><span class="line"> (0,13) | 69 | user69   | 14bfa6bb14875e45bba028a21ed38046</span><br><span class="line"> (0,14) | 32 | user32   | 6364d3f0f495b6ab9dcf8d3b5c6e0b01</span><br><span class="line"> (0,15) | 17 | user17   | 70efdf2ec9b086079795c442636b55fb</span><br><span class="line"> (0,16) | 15 | user15   | 9bf31c7ff062936a96d3c8bd1f8f2ff3</span><br><span class="line"> (0,17) | 46 | user46   | d9d4f495e875a2e075a1a4a6e1b9770f</span><br><span class="line"> (0,18) | 83 | user83   | fe9fc289c3ff0af142b6d3bead98a923</span><br><span class="line"> (0,19) | 82 | user82   | 9778d5d219c5080b9a6a17bef029331c</span><br><span class="line"> (0,20) | 20 | user20   | 98f13708210194c475687be6106a3b84</span><br><span class="line">(20 rows)</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，创建索引之后，数据的物理位置并没有发生变化。现在我们使用 <code>account_id_idx</code> 作为 <code>account</code> 表的聚簇索引，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# CLUSTER account USING account_id_idx;</span><br><span class="line">CLUSTER</span><br><span class="line">postgres&#x3D;# SELECT ctid, * FROM account LIMIT 20;</span><br><span class="line">  ctid  | id | nickname |             password</span><br><span class="line">--------+----+----------+----------------------------------</span><br><span class="line"> (0,1)  |  1 | user1    | c4ca4238a0b923820dcc509a6f75849b</span><br><span class="line"> (0,2)  |  2 | user2    | c81e728d9d4c2f636f067f89cc14862c</span><br><span class="line"> (0,3)  |  3 | user3    | eccbc87e4b5ce2fe28308fd9f2a7baf3</span><br><span class="line"> (0,4)  |  4 | user4    | a87ff679a2f3e71d9181a67b7542122c</span><br><span class="line"> (0,5)  |  5 | user5    | e4da3b7fbbce2345d7772b0674a318d5</span><br><span class="line"> (0,6)  |  6 | user6    | 1679091c5a880faf6fb5e6087eb1b2dc</span><br><span class="line"> (0,7)  |  7 | user7    | 8f14e45fceea167a5a36dedd4bea2543</span><br><span class="line"> (0,8)  |  8 | user8    | c9f0f895fb98ab9159f51fd0297e236d</span><br><span class="line"> (0,9)  |  9 | user9    | 45c48cce2e2d7fbdea1afc51c7c6ad26</span><br><span class="line"> (0,10) | 10 | user10   | d3d9446802a44259755d38e6d163e820</span><br><span class="line"> (0,11) | 11 | user11   | 6512bd43d9caa6e02c990b0a82652dca</span><br><span class="line"> (0,12) | 12 | user12   | c20ad4d76fe97759aa27a0c99bff6710</span><br><span class="line"> (0,13) | 13 | user13   | c51ce410c124a10e0db5e4b97fc2af39</span><br><span class="line"> (0,14) | 14 | user14   | aab3238922bcc25a6f606eb525ffdc56</span><br><span class="line"> (0,15) | 15 | user15   | 9bf31c7ff062936a96d3c8bd1f8f2ff3</span><br><span class="line"> (0,16) | 16 | user16   | c74d97b01eae257e44aa9d5bade97baf</span><br><span class="line"> (0,17) | 17 | user17   | 70efdf2ec9b086079795c442636b55fb</span><br><span class="line"> (0,18) | 18 | user18   | 6f4922f45568161a8cdf4ad2299f6d23</span><br><span class="line"> (0,19) | 19 | user19   | 1f0e3dad99908345f7439f8ffabdffc4</span><br><span class="line"> (0,20) | 20 | user20   | 98f13708210194c475687be6106a3b84</span><br><span class="line">(20 rows)</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，数据的物理位置发生了变化，数据的物理位置与索引相同。虽然，我们对 <code>account</code> 表创建了聚簇索引，但是在新插入数据时，PostgreSQL 并不会维护索引的正确性（即后续插入的数据并不是按照聚簇索引的顺序在物理上排序），我们需要再次使用 <code>CLUSTER</code> 命令来维护聚簇索引的正确性。</p>
<p>下面的示例展示了 PostgreSQL 在创建聚簇索引后再次插入数据后，数据的物理顺序，并再次进行 <code>CLUSTER</code> 后的物理顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# INSERT INTO account SELECT id, &#39;test&#39;||id::text, md5(id::text)</span><br><span class="line">postgres-# FROM generate_series(200, 300) id ORDER BY random();</span><br><span class="line">INSERT 0 101</span><br><span class="line">postgres&#x3D;# SELECT ctid, * FROM account WHERE nickname ~ &#39;test&#39; LIMIT 20;</span><br><span class="line">  ctid   | id  | nickname |             password</span><br><span class="line">---------+-----+----------+----------------------------------</span><br><span class="line"> (0,101) | 296 | test296  | d296c101daa88a51f6ca8cfc1ac79b50</span><br><span class="line"> (0,102) | 292 | test292  | 1700002963a49da13542e0726b7bb758</span><br><span class="line"> (0,103) | 208 | test208  | 091d584fced301b442654dd8c23b3fc9</span><br><span class="line"> (0,104) | 210 | test210  | 6f3ef77ac0e3619e98159e9b6febf557</span><br><span class="line"> (0,105) | 240 | test240  | 335f5352088d7d9bf74191e006d8e24c</span><br><span class="line"> (0,106) | 211 | test211  | eb163727917cbba1eea208541a643e74</span><br><span class="line"> (0,107) | 265 | test265  | e56954b4f6347e897f954495eab16a88</span><br><span class="line"> (1,1)   | 269 | test269  | 06138bc5af6023646ede0e1f7c1eac75</span><br><span class="line"> (1,2)   | 222 | test222  | bcbe3365e6ac95ea2c0343a2395834dd</span><br><span class="line"> (1,3)   | 252 | test252  | 03c6b06952c750899bb03d998e631860</span><br><span class="line"> (1,4)   | 230 | test230  | 6da9003b743b65f4c0ccd295cc484e57</span><br><span class="line"> (1,5)   | 282 | test282  | 6a9aeddfc689c1d0e3b9ccc3ab651bc5</span><br><span class="line"> (1,6)   | 235 | test235  | 577ef1154f3240ad5b9b413aa7346a1e</span><br><span class="line"> (1,7)   | 213 | test213  | 979d472a84804b9f647bc185a877a8b5</span><br><span class="line"> (1,8)   | 249 | test249  | 077e29b11be80ab57e1a2ecabb7da330</span><br><span class="line"> (1,9)   | 200 | test200  | 3644a684f98ea8fe223c713b77189a77</span><br><span class="line"> (1,10)  | 267 | test267  | eda80a3d5b344bc40f3bc04f65b7a357</span><br><span class="line"> (1,11)  | 247 | test247  | 3cec07e9ba5f5bb252d13f5f431e4bbb</span><br><span class="line"> (1,12)  | 228 | test228  | 74db120f0a8e5646ef5a30154e9f6deb</span><br><span class="line"> (1,13)  | 262 | test262  | 36660e59856b4de58a219bcf4e27eba3</span><br><span class="line">(20 rows)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# CLUSTER account ;</span><br><span class="line">CLUSTER</span><br><span class="line">postgres&#x3D;# SELECT ctid, * FROM account WHERE nickname ~ &#39;test&#39; LIMIT 20;</span><br><span class="line">  ctid   | id  | nickname |             password</span><br><span class="line">---------+-----+----------+----------------------------------</span><br><span class="line"> (0,101) | 200 | test200  | 3644a684f98ea8fe223c713b77189a77</span><br><span class="line"> (0,102) | 201 | test201  | 757b505cfd34c64c85ca5b5690ee5293</span><br><span class="line"> (0,103) | 202 | test202  | 854d6fae5ee42911677c739ee1734486</span><br><span class="line"> (0,104) | 203 | test203  | e2c0be24560d78c5e599c2a9c9d0bbd2</span><br><span class="line"> (0,105) | 204 | test204  | 274ad4786c3abca69fa097b85867d9a4</span><br><span class="line"> (0,106) | 205 | test205  | eae27d77ca20db309e056e3d2dcd7d69</span><br><span class="line"> (0,107) | 206 | test206  | 7eabe3a1649ffa2b3ff8c02ebfd5659f</span><br><span class="line"> (1,1)   | 207 | test207  | 69adc1e107f7f7d035d7baf04342e1ca</span><br><span class="line"> (1,2)   | 208 | test208  | 091d584fced301b442654dd8c23b3fc9</span><br><span class="line"> (1,3)   | 209 | test209  | b1d10e7bafa4421218a51b1e1f1b0ba2</span><br><span class="line"> (1,4)   | 210 | test210  | 6f3ef77ac0e3619e98159e9b6febf557</span><br><span class="line"> (1,5)   | 211 | test211  | eb163727917cbba1eea208541a643e74</span><br><span class="line"> (1,6)   | 212 | test212  | 1534b76d325a8f591b52d302e7181331</span><br><span class="line"> (1,7)   | 213 | test213  | 979d472a84804b9f647bc185a877a8b5</span><br><span class="line"> (1,8)   | 214 | test214  | ca46c1b9512a7a8315fa3c5a946e8265</span><br><span class="line"> (1,9)   | 215 | test215  | 3b8a614226a953a8cd9526fca6fe9ba5</span><br><span class="line"> (1,10)  | 216 | test216  | 45fbc6d3e05ebd93369ce542e8f2322d</span><br><span class="line"> (1,11)  | 217 | test217  | 63dc7ed1010d3c3b8269faf0ba7491d4</span><br><span class="line"> (1,12)  | 218 | test218  | e96ed478dab8595a7dbda4cbcbee168f</span><br><span class="line"> (1,13)  | 219 | test219  | c0e190d8267e36708f955d7ab048990d</span><br><span class="line">(20 rows)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.guru99.com/clustered-vs-non-clustered-index.html">https://www.guru99.com/clustered-vs-non-clustered-index.html</a><br>[2] <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL Common Table Expressions</title>
    <url>/2019/03/postgresql-common-table-expressions/</url>
    <content><![CDATA[<p>本文将介绍 PostgreSQL 中的 Common Table Expressions, CTE，也叫做公用表表达式。在介绍 CTE 之前，我们需要先了解 WITH 查询。WITH 查询是 PostgreSQL 针对复杂查询，允许用户在该查询内容编写辅助语句的功能，其中用户编写的辅助语句就是今天介绍的 CTE，你可以将 CTE 视为在当前查询中的一个临时表。CTE 的一大优点就是我们可将查询中的较为耗时且多次重复使用的部分通过 CTE 缓存起来，从而避免多次执行。</p>
<a id="more"></a>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>下面是一个基本的 CTE 使用示列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> x <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> relkind, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> pg_class <span class="keyword">GROUP</span> <span class="keyword">BY</span> relkind</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> x <span class="keyword">WHERE</span> relkind = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line"> relkind | count</span><br><span class="line"><span class="comment">---------+-------</span></span><br><span class="line"> r       |    69</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">Time: 1.515 ms</span><br></pre></td></tr></table></figure>

<p>上述示列中 CTE 的名称为 <code>x</code>，实质上就是由一个 <code>SELECT</code> 语句定义出来的，返回的结果是 <code>relkind</code> 以及该类型的表的数量。外围的 SQL 语句会将其视为一个临时表来使用。其实上述查询等价于下面的查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> relkind, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> pg_class <span class="keyword">GROUP</span> <span class="keyword">BY</span> relkind</span><br><span class="line">) <span class="keyword">AS</span> x</span><br><span class="line"><span class="keyword">WHERE</span> relkind = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line"> relkind | count</span><br><span class="line"><span class="comment">---------+-------</span></span><br><span class="line"> r       |    69</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">Time: 0.954 ms</span><br></pre></td></tr></table></figure>

<h2 id="CTE-的缺点"><a href="#CTE-的缺点" class="headerlink" title="CTE 的缺点"></a>CTE 的缺点</h2><p>从上面的查询结果可以看到，采用 CTE 的查询方式其执行的时间反而比子查询的方式要慢。这是为什么呢？我们先来看看他们之间的查询计划有什么不一样。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> (<span class="keyword">analyze</span> <span class="keyword">on</span>, timing <span class="keyword">on</span>)</span><br><span class="line"><span class="keyword">WITH</span> x <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> relkind, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> pg_class <span class="keyword">GROUP</span> <span class="keyword">by</span> relkind</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> x <span class="keyword">WHERE</span> relkind = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                                                     QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> CTE Scan on x  (cost=17.17..17.26 rows=1 width=9) (actual time=0.678..0.687 rows=1 loops=1)</span><br><span class="line">   Filter: (relkind = &#x27;r&#x27;::&quot;char&quot;)</span><br><span class="line">   Rows Removed by Filter: 3</span><br><span class="line">   CTE x</span><br><span class="line">     -&gt;  HashAggregate  (cost=17.13..17.17 rows=4 width=9) (actual time=0.670..0.675 rows=4 loops=1)</span><br><span class="line">           Group Key: pg_class.relkind</span><br><span class="line">           -&gt;  Seq Scan on pg_class  (cost=0.00..15.42 rows=342 width=1) (actual time=0.011..0.150 rows=342 loops=1)</span><br><span class="line"> Planning Time: 1.025 ms</span><br><span class="line"> Execution Time: 1.054 ms</span><br><span class="line">(9 rows)</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> (<span class="keyword">analyze</span> <span class="keyword">on</span>, timing <span class="keyword">on</span>)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> relkind, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> pg_class <span class="keyword">GROUP</span> <span class="keyword">BY</span> relkind</span><br><span class="line">) <span class="keyword">AS</span> x</span><br><span class="line"><span class="keyword">WHERE</span> relkind = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                                                QUERY PLAN</span><br><span class="line"><span class="comment">-----------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> GroupAggregate  (cost=0.00..16.66 rows=4 width=9) (actual time=0.291..0.292 rows=1 loops=1)</span><br><span class="line">   Group Key: pg_class.relkind</span><br><span class="line">   -&gt;  Seq Scan on pg_class  (cost=0.00..16.27 rows=69 width=1) (actual time=0.018..0.261 rows=69 loops=1)</span><br><span class="line">         Filter: (relkind = &#x27;r&#x27;::&quot;char&quot;)</span><br><span class="line">         Rows Removed by Filter: 273</span><br><span class="line"> Planning Time: 0.249 ms</span><br><span class="line"> Execution Time: 0.395 ms</span><br><span class="line">(7 rows)</span><br></pre></td></tr></table></figure>

<p>目前，PostgreSQL 会将 CTE 的结构进行物化 (Materialize)，这就意味着创建一个临时表来存储其返回的结果，随后在该临时表上面进行过滤，正如查询计划中展示的一样。由于过滤条件不能直接应用到 CTE 中，PostgreSQL 也就无法在将上层的过滤条件下推到 CTE 中执行。然而，通过子查询的方式，PostgreSQL 可以很自然的将过滤条件下推到子查询中。从上面的结果可以看到，子查询的方式显然优于 CTE 的查询方式，这是因为 CTE 的查询方式执行了两次全表扫描以及需要额外的存储空间来存放 CTE 返回的结果。</p>
<p>而在 PostgreSQL 的官方文档中也存在如下描述：</p>
<blockquote>
<p>A useful property of WITH queries is that they are evaluated only once per<br>execution of the parent query, even if they are referred to more than once by<br>the parent query or sibling WITH queries. Thus, expensive calculations that<br>are needed in multiple places can be placed within a WITH query to avoid<br>redundant work. Another possible application is to prevent unwanted multiple<br>evaluations of functions with side-effects. However, the other side of this<br>coin is that the optimizer is less able to push restrictions from the parent<br>query down into a WITH query than an ordinary subquery. The WITH query will<br>generally be evaluated as written, without suppression of rows that the parent<br>query might discard afterwards. (But, as mentioned above, evaluation might stop<br>early if the reference(s) to the query demand only a limited number of rows.)</p>
</blockquote>
<p>因此，我们在使用 CTE 时需要特别注意，正确的使用 CTE 将会带来性能的提升；如果使用不当，则很可能影响数据库性能。</p>
<h2 id="禁止-CTE-物化？"><a href="#禁止-CTE-物化？" class="headerlink" title="禁止 CTE 物化？"></a>禁止 CTE 物化？</h2><p>那么我们是否能禁止 CTE 物化结果呢？就目前 PostgreSQL 来说，这是不可能的。但是在 2019 年 2 月 16 日 Tom Lane 提交了一个<a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=608b167f9f9c4553c35bb1ec0eab9ddae643989b">补丁</a>来解决该问题。</p>
<blockquote>
<p>Historically we’ve always materialized the full output of a CTE query,<br>treating WITH as an optimization fence (so that, for example, restrictions<br>from the outer query cannot be pushed into it).  This is appropriate when<br>the CTE query is INSERT/UPDATE/DELETE, or is recursive; but when the CTE<br>query is non-recursive and side-effect-free, there’s no hazard of changing<br>the query results by pushing restrictions down.</p>
<p>Another argument for materialization is that it can avoid duplicate<br>computation of an expensive WITH query — but that only applies if<br>the WITH query is called more than once in the outer query.  Even then<br>it could still be a net loss, if each call has restrictions that<br>would allow just a small part of the WITH query to be computed.</p>
<p>Hence, let’s change the behavior for WITH queries that are non-recursive<br>and side-effect-free.  By default, we will inline them into the outer<br>query (removing the optimization fence) if they are called just once.<br>If they are called more than once, we will keep the old behavior by<br>default, but the user can override this and force inlining by specifying<br>NOT MATERIALIZED.  Lastly, the user can force the old behavior by<br>specifying MATERIALIZED; this would mainly be useful when the query had<br>deliberately been employing WITH as an optimization fence to prevent a<br>poor choice of plan.</p>
<p>Andreas Karlsson, Andrew Gierth, David Fetter</p>
<p>Discussion: <a href="https://postgr.es/m/87sh48ffhb.fsf@news-spur.riddles.org.uk">https://postgr.es/m/87sh48ffhb.fsf@news-spur.riddles.org.uk</a></p>
</blockquote>
<p>这让用户禁止 CTE 物化结果成为可能，该功能预计在 PostgreSQL 12 版本中推出。</p>
<p>下面是在 PostgreSQL 12 开发版中的测试结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> (<span class="keyword">analyze</span> <span class="keyword">on</span>, timing <span class="keyword">on</span>)</span><br><span class="line"><span class="keyword">WITH</span> x <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> relkind, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> pg_class <span class="keyword">GROUP</span> <span class="keyword">by</span> relkind</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> x <span class="keyword">WHERE</span> relkind = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                                                QUERY PLAN</span><br><span class="line"><span class="comment">-----------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> GroupAggregate  (cost=0.00..18.21 rows=4 width=9) (actual time=0.103..0.103 rows=1 loops=1)</span><br><span class="line">   Group Key: pg_class.relkind</span><br><span class="line">   -&gt;  Seq Scan on pg_class  (cost=0.00..17.82 rows=69 width=1) (actual time=0.009..0.092 rows=69 loops=1)</span><br><span class="line">         Filter: (relkind = &#x27;r&#x27;::&quot;char&quot;)</span><br><span class="line">         Rows Removed by Filter: 317</span><br><span class="line"> Planning Time: 0.406 ms</span><br><span class="line"> Execution Time: 0.196 ms</span><br><span class="line">(7 rows)</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> (<span class="keyword">analyze</span> <span class="keyword">on</span>, timing <span class="keyword">on</span>)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> relkind, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> pg_class <span class="keyword">GROUP</span> <span class="keyword">BY</span> relkind</span><br><span class="line">) <span class="keyword">AS</span> x</span><br><span class="line"><span class="keyword">WHERE</span> relkind = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                                                QUERY PLAN</span><br><span class="line"><span class="comment">-----------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> GroupAggregate  (cost=0.00..18.21 rows=4 width=9) (actual time=0.118..0.118 rows=1 loops=1)</span><br><span class="line">   Group Key: pg_class.relkind</span><br><span class="line">   -&gt;  Seq Scan on pg_class  (cost=0.00..17.82 rows=69 width=1) (actual time=0.011..0.106 rows=69 loops=1)</span><br><span class="line">         Filter: (relkind = &#x27;r&#x27;::&quot;char&quot;)</span><br><span class="line">         Rows Removed by Filter: 317</span><br><span class="line"> Planning Time: 0.120 ms</span><br><span class="line"> Execution Time: 0.151 ms</span><br><span class="line">(7 rows)</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> (<span class="keyword">analyze</span> <span class="keyword">on</span>, timing <span class="keyword">on</span>)</span><br><span class="line"><span class="keyword">WITH</span> x <span class="keyword">AS</span>  <span class="keyword">MATERIALIZED</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> relkind, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> pg_class <span class="keyword">GROUP</span> <span class="keyword">by</span> relkind</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> x <span class="keyword">WHERE</span> relkind = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                                                     QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> CTE Scan on x  (cost=18.83..18.92 rows=1 width=9) (actual time=0.174..0.176 rows=1 loops=1)</span><br><span class="line">   Filter: (relkind = &#x27;r&#x27;::&quot;char&quot;)</span><br><span class="line">   Rows Removed by Filter: 3</span><br><span class="line">   CTE x</span><br><span class="line">     -&gt;  HashAggregate  (cost=18.79..18.83 rows=4 width=9) (actual time=0.171..0.172 rows=4 loops=1)</span><br><span class="line">           Group Key: pg_class.relkind</span><br><span class="line">           -&gt;  Seq Scan on pg_class  (cost=0.00..16.86 rows=386 width=1) (actual time=0.005..0.042 rows=386 loops=1)</span><br><span class="line"> Planning Time: 0.185 ms</span><br><span class="line"> Execution Time: 0.249 ms</span><br><span class="line">(9 rows)</span><br></pre></td></tr></table></figure>

<p>PostgreSQL 12 版中为 CTE 新增了 <code>MATERIALIZED | NOT MATERIALIZED</code> 选项，这样用户就可以通过选项控制是否对 CTE 进行物化，而默认情况下是不对 CTE 进行物化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CTE 可以使我们编写的 SQL 查询更易于阅读且能通过物化的方式将结果缓存到起来从而提升查询性能；但是，CTE 的使用不当甚至有可能导致性能的降低，例如在查询中仅使用一次的情况。当我们使用 CTE 时，需要考虑以下几个问题:</p>
<ol>
<li>该 CTE 是否会被重复使用？</li>
<li>查询中的条件是否能在 CTE 中应用?</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.depesz.com/2019/02/19/waiting-for-postgresql-12-allow-user-control-of-cte-materialization-and-change-the-default-behavior/#more-3491">Allow user control of CTE materialization, and change the default behavior</a><br>[2] <a href="https://medium.com/@hakibenita/be-careful-with-cte-in-postgresql-fca5e24d2119">Be careful with CTE in PostgreSQL</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>CTE</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 持续归档</title>
    <url>/2018/10/postgresql-continuous-archiving/</url>
    <content><![CDATA[<p>无论何时，PostgreSQL 总是在集群的数据目录 pg_wal 下面维护一个 <em>Write Ahead Log</em> 日志记录。该日志记录了数据文件的所有变化。当数据库系统发生崩溃时，数据库系统可以通过重放最新检查点之后的 WAL 日志条目来恢复数据库的一致性。在 PostgreSQL 中，我们通过将文件系统级的备份与 WAL 日志的备份相结合可以实现三种策略的数据库备份。当需要进行数据库恢复时，我们先恢复文件系统的备份，随后通过重放备份的 WAL 日志使得数据库进入到当前状态。尽管该方法过于复杂，但是它拥有以下好处：</p>
<ul>
<li>我们不需要完全一致的文件系统备份作为起点。备份中的任何内部不一致都将通过日志重放进行更正 (这与崩溃恢复期间发生的情况没有显着差异)。因此，我们不需要文件系统快照功能，只需要 tar 或类似的归档工具。</li>
<li>没有必要一直重放 WAL 条目到最后。我们可以在任何时候停止重放并拥有当时数据库的一致快照。因此，该技术支持时间点恢复 (Point-in-Time Recovery, PITR)。为此，我们可以将数据库还原到自从进行基本备份以后的任何状态。</li>
<li>如果我们持续地将一系列 WAL 日志文件提供给另一台已加载相同基本备份文件的计算机，此时，我们就拥有了一个热备系统：在任何时候我们都可以启动这台机器，它将拥有与原数据库几乎一致的状态。</li>
</ul>
<p>与普通文件系统备份技术一样，该方法只能支持恢复整个数据库集群，而不能用于恢复其子集。同时，它也需要更多的归档空间：基本的文件系统备份可能很庞大，繁忙的系统将生成许多必须归档的 WAL 流量。尽管如此，在多数情况下，它仍然是需要高可靠性的首选备份技术。</p>
<p>我们需要一系列连续归档 WAL 日志文件，这些文件至少可以延伸到备份的开始时间，从而确保连续归档 (许多数据库供应商也称为“在线备份”) 成功恢复。</p>
<a id="more"></a>

<h2 id="WAL-日志归档"><a href="#WAL-日志归档" class="headerlink" title="WAL 日志归档"></a>WAL 日志归档</h2><p>从抽象的意义上说，PostgreSQL 数据库系统会产生无限长的 WAL 日志记录序列。PostgreSQL 数据库该序列划分 WAL 段文件，通常每个段文件为 16MB (在构建 PostgreSQL 时可以更改段大小)。段文件的数字名称反映了它们在抽象 WAL 序列中的位置。当不使用 WAL 归档时，PostgreSQL 通常只需要创建几个段文件，然后通过将不再需要的段文件重命名为更高的段号来“回收”它们。</p>
<p>当使用 WAL 日志归档时，我们需要在每个段文件填充后捕获它们的内容，并在段文件被回收再利用之前将该数据保存在其他某处。PostgreSQL 允许管理员指定要执行的 shell 命令，以将已完成的段文件复制到需要的位置。该命令可以简单的 cp 命令，也可以是复杂的 shell 脚步，一切都取决于用户。</p>
<p>我们需要设置三个选项以便启用 WAL 日志归档： wal_level，archive_mode 和 archive_command。</p>
<p><strong>wal_level__ - 必须为 replica 或者更高的级别。<br>__archive_mode</strong> - 设置为 on。<br>__archive_command__ - 通常为归档命令，其中 <code>%p</code> 被替换为要归档的文件的路径名，<code>%f</code> 被替换为要归档的文件的文件名。如果需要在命令中嵌入实际的 <code>％</code> 字符，请使用 <code>%%</code>。</p>
<p>接下来我们尝试配置 WAL 日志归档，首先进行相关的准备工作，编译 PostgreSQL 10.4，初始化数据库，建立归档日志存储路径 (本例旨在使用 WAL 日志归档，因此就在本地建立目录来存储备份的 WAL 日志，通常的做法时备份到其他主机)，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">&#x2F;home&#x2F;postgres&#x2F;postgresql-10.4</span><br><span class="line">$ ls</span><br><span class="line">drwxr-xr-x  2 postgres postgres 4096 Oct 24 13:36 bin</span><br><span class="line">drwx------ 19 postgres postgres 4096 Oct 24 13:49 data</span><br><span class="line">drwxr-xr-x  6 postgres postgres 4096 Oct 24 13:36 include</span><br><span class="line">drwxr-xr-x  4 postgres postgres 4096 Oct 24 13:36 lib</span><br><span class="line">-rw-rw-r--  1 postgres postgres  177 Oct 24 13:39 pg-env.sh</span><br><span class="line">drwxr-xr-x  6 postgres postgres 4096 Oct 24 13:36 share</span><br><span class="line">$ cat pg-env.sh</span><br><span class="line">export PGHOME&#x3D;&#x2F;home&#x2F;postgres&#x2F;postgresql-10.4</span><br><span class="line">export PGDATA&#x3D;&#x2F;home&#x2F;postgres&#x2F;postgresql-10.4&#x2F;data</span><br><span class="line">export PATH&#x3D;$PGHOME&#x2F;bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;$PGHOME&#x2F;lib:$LD_LIBRARY_PATH</span><br><span class="line">$ mkdir wals            # 建立 WAL 日志备份目录</span><br><span class="line">$ . pg-env.sh           # 初始化环境变量</span><br><span class="line">$ initdb -D data        # 初始化数据库集群</span><br></pre></td></tr></table></figure>

<p>接着修改 data/postgresql.conf 文件中的 wal_level，archive_mode 和 archive_command 参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wal_level &#x3D; replica</span><br><span class="line">archive_mode &#x3D; on</span><br><span class="line">archive_command &#x3D; &#39;test ! -f &#x2F;home&#x2F;postgres&#x2F;postgresql-10.4&#x2F;wals&#x2F;%f &amp;&amp; cp %p &#x2F;home&#x2F;postgres&#x2F;postgresql-10.4&#x2F;wals&#x2F;%f&#39;</span><br></pre></td></tr></table></figure>

<p>按照上述操作进行，我们目前已经配置好了 WAL 日志归档，接下来我们运行数据库并创建一个基本备份 (即文件系统级备份) 并保存在当前目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pg_ctl -D data -l logfile start</span><br><span class="line">$ psql -c &quot;SELECT pg_start_backup(&#39;label&#39;);&quot; postgres</span><br><span class="line">$ tar -C data -czvf pg_basebackup_backup.tar.gz .</span><br><span class="line">$ psql -c &quot;SELECT pg_stop_backup();&quot; postgres</span><br></pre></td></tr></table></figure>

<p>此时，我们创建好了数据库集群的基本备份，之后我们便可以通过该基本备份并结合 WAL 日志备份进行恢复。紧接着，我们对数据库做一些修改，并停止数据库然后删除 data 目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ psql postgres</span><br><span class="line">psql (10.4)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# create table test (id int, name varchar(10));</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres&#x3D;# insert into test values (1, &#39;postgres&#39;);</span><br><span class="line">INSERT 0 1</span><br><span class="line">postgres&#x3D;# select * from test ;</span><br><span class="line"> id |   name</span><br><span class="line"> ----+----------</span><br><span class="line">   1 | postgres</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# \q</span><br><span class="line">$ pg_ctl -D data -l logfile stop</span><br><span class="line">$ rm -rf data</span><br></pre></td></tr></table></figure>

<p>下面将演示如何使用基础备份及 WAL 日志备份恢复数据库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> initdb -D data1                    <span class="comment"># 重新初始化一个数据库集群</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -C data1 -xvf pg_basebackup_backup.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt;END &gt; data1/recovery.conf    <span class="comment"># 创建恢复脚步</span></span></span><br><span class="line">restore_command = &#x27;cp /home/postgres/postgresql-10.4/wals/%f %p&#x27;</span><br><span class="line">END</span><br><span class="line"><span class="meta">$</span><span class="bash"> pg_ctl -D data1 -l logfile start   <span class="comment"># 恢复</span></span></span><br></pre></td></tr></table></figure>

<p>在恢复完成之后，PostgreSQL 将把 recovery.conf 文件重命名为 recovery.done。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/10/static/continuous-archiving.html">https://www.postgresql.org/docs/10/static/continuous-archiving.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL CREATE TABLE 查询计划树及执行计划树的生成</title>
    <url>/2019/05/postgresql-create-table-query-plan/</url>
    <content><![CDATA[<p>在<a href="/2019/05/postgresql-create-table-syntax-analysis/" title="上一篇文章">上一篇文章</a>中，我们主要分析了 <code>CREATE TABLE</code> 语句的的词法和语法，并简要说明了 PostgreSQL 的执行流程。本文将介绍 PostgreSQL 是如何将解析树转化为执行计划的。</p>
<a id="more"></a>

<h2 id="查询计划树"><a href="#查询计划树" class="headerlink" title="查询计划树"></a>查询计划树</h2><p>PostgreSQL 在获取到原始解析树之后将通过函数 <code>pg_analyze_and_rewrite()</code> 对解析树进行解析分析并进行规则重写，分析器或规则重写器可能会将一个查询扩展为多个查询，因此可能返回多个查询节点。其函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Given a raw parsetree (gram.y output), and optionally information about</span></span><br><span class="line"><span class="comment"> * types of parameter symbols ($n), perform parse analysis and rule rewriting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A list of Query nodes is returned, since either the analyzer or the</span></span><br><span class="line"><span class="comment"> * rewriter might expand one query to several.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> for reasons mentioned above, this must be separate from raw parsing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List *</span><br><span class="line">pg_analyze_and_rewrite(RawStmt *parsetree, <span class="keyword">const</span> <span class="keyword">char</span> *query_string,</span><br><span class="line">                       Oid *paramTypes, <span class="keyword">int</span> numParams,</span><br><span class="line">                       QueryEnvironment *queryEnv)</span><br><span class="line">&#123;</span><br><span class="line">    Query      *query;</span><br><span class="line">    List       *querytree_list;</span><br><span class="line"></span><br><span class="line">    TRACE_POSTGRESQL_QUERY_REWRITE_START(query_string);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * (1) Perform parse analysis.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (log_parser_stats)</span><br><span class="line">        ResetUsage();</span><br><span class="line"></span><br><span class="line">    query = parse_analyze(parsetree, query_string, paramTypes, numParams,</span><br><span class="line">                          queryEnv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log_parser_stats)</span><br><span class="line">        ShowUsage(<span class="string">&quot;PARSE ANALYSIS STATISTICS&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * (2) Rewrite the queries, as necessary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    querytree_list = pg_rewrite_query(query);</span><br><span class="line"></span><br><span class="line">    TRACE_POSTGRESQL_QUERY_REWRITE_DONE(query_string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> querytree_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从函数的定义可以看到，该函数分为两个阶段：(1) 解析分析；(2) 规则重写。其中规则重写阶段不是必须进行的。</p>
<h3 id="解析分析"><a href="#解析分析" class="headerlink" title="解析分析"></a>解析分析</h3><p>解析分析通过 <code>parse_analyze()</code> 函数进行处理，它将原始解析树转换为一棵查询树。查询树的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Query -</span></span><br><span class="line"><span class="comment"> *    Parse analysis turns all statements into a Query tree</span></span><br><span class="line"><span class="comment"> *    for further processing by the rewriter and planner.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    Utility statements (i.e. non-optimizable statements) have the</span></span><br><span class="line"><span class="comment"> *    utilityStmt field set, and the rest of the Query is mostly dummy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    Planning converts a Query tree into a Plan tree headed by a PlannedStmt</span></span><br><span class="line"><span class="comment"> *    node --- the Query structure is not used by the executor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Query</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NodeTag     type;</span><br><span class="line"></span><br><span class="line">    CmdType     commandType;    <span class="comment">/* select|insert|update|delete|utility */</span></span><br><span class="line"></span><br><span class="line">    QuerySource querySource;    <span class="comment">/* where did I come from? */</span></span><br><span class="line"></span><br><span class="line">    uint64      queryId;        <span class="comment">/* query identifier (can be set by plugins) */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span>        canSetTag;      <span class="comment">/* do I set the command result tag? */</span></span><br><span class="line"></span><br><span class="line">    Node       *utilityStmt;    <span class="comment">/* non-null if commandType == CMD_UTILITY */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>         resultRelation; <span class="comment">/* rtable index of target relation for</span></span><br><span class="line"><span class="comment">                                 * INSERT/UPDATE/DELETE; 0 for SELECT */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span>        hasAggs;        <span class="comment">/* has aggregates in tlist or havingQual */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasWindowFuncs; <span class="comment">/* has window functions in tlist */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasTargetSRFs;  <span class="comment">/* has set-returning functions in tlist */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasSubLinks;    <span class="comment">/* has subquery SubLink */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasDistinctOn;  <span class="comment">/* distinctClause is from DISTINCT ON */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasRecursive;   <span class="comment">/* WITH RECURSIVE was specified */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasModifyingCTE;    <span class="comment">/* has INSERT/UPDATE/DELETE in WITH */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasForUpdate;   <span class="comment">/* FOR [KEY] UPDATE/SHARE was specified */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasRowSecurity; <span class="comment">/* rewriter has applied some RLS policy */</span></span><br><span class="line"></span><br><span class="line">    List       *cteList;        <span class="comment">/* WITH list (of CommonTableExpr&#x27;s) */</span></span><br><span class="line"></span><br><span class="line">    List       *rtable;         <span class="comment">/* list of range table entries */</span></span><br><span class="line">    FromExpr   *jointree;       <span class="comment">/* table join tree (FROM and WHERE clauses) */</span></span><br><span class="line"></span><br><span class="line">    List       *targetList;     <span class="comment">/* target list (of TargetEntry) */</span></span><br><span class="line"></span><br><span class="line">    OverridingKind <span class="keyword">override</span>;    <span class="comment">/* OVERRIDING clause */</span></span><br><span class="line"></span><br><span class="line">    OnConflictExpr *onConflict; <span class="comment">/* ON CONFLICT DO [NOTHING | UPDATE] */</span></span><br><span class="line"></span><br><span class="line">    List       *returningList;  <span class="comment">/* return-values list (of TargetEntry) */</span></span><br><span class="line"></span><br><span class="line">    List       *groupClause;    <span class="comment">/* a list of SortGroupClause&#x27;s */</span></span><br><span class="line"></span><br><span class="line">    List       *groupingSets;   <span class="comment">/* a list of GroupingSet&#x27;s if present */</span></span><br><span class="line"></span><br><span class="line">    Node       *havingQual;     <span class="comment">/* qualifications applied to groups */</span></span><br><span class="line"></span><br><span class="line">    List       *windowClause;   <span class="comment">/* a list of WindowClause&#x27;s */</span></span><br><span class="line"></span><br><span class="line">    List       *distinctClause; <span class="comment">/* a list of SortGroupClause&#x27;s */</span></span><br><span class="line"></span><br><span class="line">    List       *sortClause;     <span class="comment">/* a list of SortGroupClause&#x27;s */</span></span><br><span class="line"></span><br><span class="line">    Node       *limitOffset;    <span class="comment">/* # of result tuples to skip (int8 expr) */</span></span><br><span class="line">    Node       *limitCount;     <span class="comment">/* # of result tuples to return (int8 expr) */</span></span><br><span class="line"></span><br><span class="line">    List       *rowMarks;       <span class="comment">/* a list of RowMarkClause&#x27;s */</span></span><br><span class="line"></span><br><span class="line">    Node       *setOperations;  <span class="comment">/* set-operation tree if this is top level of</span></span><br><span class="line"><span class="comment">                                 * a UNION/INTERSECT/EXCEPT query */</span></span><br><span class="line"></span><br><span class="line">    List       *constraintDeps; <span class="comment">/* a list of pg_constraint OIDs that the query</span></span><br><span class="line"><span class="comment">                                 * depends on to be semantically valid */</span></span><br><span class="line"></span><br><span class="line">    List       *withCheckOptions;   <span class="comment">/* a list of WithCheckOption&#x27;s (added</span></span><br><span class="line"><span class="comment">                                     * during rewrite) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The following two fields identify the portion of the source text string</span></span><br><span class="line"><span class="comment">     * containing this query.  They are typically only populated in top-level</span></span><br><span class="line"><span class="comment">     * Queries, not in sub-queries.  When not set, they might both be zero, or</span></span><br><span class="line"><span class="comment">     * both be -1 meaning &quot;unknown&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>         stmt_location;  <span class="comment">/* start location, or -1 if unknown */</span></span><br><span class="line">    <span class="keyword">int</span>         stmt_len;       <span class="comment">/* length in bytes; 0 means &quot;rest of string&quot; */</span></span><br><span class="line">&#125; Query;</span><br></pre></td></tr></table></figure>

<p>当所处理的语句为 DDL 时 <code>Query</code> 结构使用 <code>utilityStmt</code> 成员来存储 DDL 原始解析树，而对于非 DDL 语句，解析分析则会将原始解析树中对应的结构解析到 <code>Query</code> 相应的成员中，本文暂时不做介绍。</p>
<p><code>parse_analyze()</code> 函数通过调用 <code>transformTopLevelStmt()</code> 函数将原始解析树转换为查询树，在转换过程中，PostgreSQL 通过 <code>ParseState</code> 结构维护解析过程的中间状态。实际上 <code>transformTopLevelStmt()</code> 函数是通过调用 <code>transformOptionalSelectInto()</code> 函数进行处理，该函数针对 <code>SELECT ... INTO</code> 这种语句进行处理，随后使用 <code>transformStmt()</code> 函数进行所有语句的处理。</p>
<p><code>transformStmt()</code> 函数内部通过一个 <code>switch</code> 语句进行处理，PostgreSQL 将 SQL 语句分为三大类：</p>
<ul>
<li><strong>Optimizable statements</strong> - 可以优化的语句，包括 <code>INSERT</code>, <code>DELETE</code>, <code>UPDATE</code> 和 <code>SELECT</code> 语句。</li>
<li><strong>Special cases</strong> - 特殊语句，包括 <code>DECLARE CURSOR</code>, <code>EXPLAIN</code>, <code>CREATE TABLE AS</code> 和 <code>CALL</code> 语句。</li>
<li><strong>Utility statements</strong> - 功能性语句，主要包括 <code>CREATE TABLE</code>, <code>CREATE FUNCTION</code> 等 DDL 语句。</li>
</ul>
<p>函数 <code>parse_analyze()</code> 的函数定义如下（节选部分代码）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * transformStmt -</span></span><br><span class="line"><span class="comment"> *    recursively transform a Parse tree into a Query tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Query *</span><br><span class="line">transformStmt(ParseState *pstate, Node *parseTree)</span><br><span class="line">&#123;</span><br><span class="line">    Query      *result;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (nodeTag(parseTree))</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Optimizable statements</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">case</span> T_InsertStmt:</span><br><span class="line">            result = transformInsertStmt(pstate, (InsertStmt *) parseTree);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Special cases</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">case</span> T_DeclareCursorStmt:</span><br><span class="line">            result = transformDeclareCursorStmt(pstate,</span><br><span class="line">                                                (DeclareCursorStmt *) parseTree);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * other statements don&#x27;t require any transformation; just return</span></span><br><span class="line"><span class="comment">             * the original parsetree with a Query node plastered on top.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            result = makeNode(Query);</span><br><span class="line">            result-&gt;commandType = CMD_UTILITY;</span><br><span class="line">            result-&gt;utilityStmt = (Node *) parseTree;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark as original query until we learn differently */</span></span><br><span class="line">    result-&gt;querySource = QSRC_ORIGINAL;</span><br><span class="line">    result-&gt;canSetTag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本文针对 <code>CREATE TABLE</code> 语句进行介绍，从上面的代码可以看到，针对 <code>CREATE TABLE</code> 这类 DDL 语句其实只是将原始解析树保存到 <code>Query-&gt;utilityStmt</code> 结构中。</p>
<h3 id="规则重写"><a href="#规则重写" class="headerlink" title="规则重写"></a>规则重写</h3><p>规则重写则是通过函数 <code>pg_rewrite_query()</code> 进行处理，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Perform rewriting of a query produced by parse analysis.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: query must just have come from the parser, because we do not do</span></span><br><span class="line"><span class="comment"> * AcquireRewriteLocks() on it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> List *</span><br><span class="line">pg_rewrite_query(Query *query)</span><br><span class="line">&#123;</span><br><span class="line">    List       *querytree_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Debug_print_parse)</span><br><span class="line">        elog_node_display(LOG, <span class="string">&quot;parse tree&quot;</span>, query,</span><br><span class="line">                          Debug_pretty_print);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log_parser_stats)</span><br><span class="line">        ResetUsage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (query-&gt;commandType == CMD_UTILITY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* don&#x27;t rewrite utilities, just dump &#x27;em into result list */</span></span><br><span class="line">        querytree_list = list_make1(query);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* rewrite regular queries */</span></span><br><span class="line">        querytree_list = QueryRewrite(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> querytree_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看到，类似于 <code>parse_analyze()</code> 函数，<code>pg_rewrite_query()</code> 函数针对 DDL 语句也不会进行重写，而只是将其存放到查询树链表中。</p>
<h2 id="执行计划树"><a href="#执行计划树" class="headerlink" title="执行计划树"></a>执行计划树</h2><p>执行计划树则是通过 <code>pg_plan_queries()</code> 的生成的，其函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generate plans for a list of already-rewritten queries.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For normal optimizable statements, invoke the planner.  For utility</span></span><br><span class="line"><span class="comment"> * statements, just make a wrapper PlannedStmt node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The result is a list of PlannedStmt nodes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List *</span><br><span class="line">pg_plan_queries(List *querytrees, <span class="keyword">int</span> cursorOptions, ParamListInfo boundParams)</span><br><span class="line">&#123;</span><br><span class="line">    List       *stmt_list = NIL;</span><br><span class="line">    ListCell   *query_list;</span><br><span class="line"></span><br><span class="line">    foreach(query_list, querytrees)</span><br><span class="line">    &#123;</span><br><span class="line">        Query      *query = lfirst_node(Query, query_list);</span><br><span class="line">        PlannedStmt *stmt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (query-&gt;commandType == CMD_UTILITY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Utility commands require no planning. */</span></span><br><span class="line">            stmt = makeNode(PlannedStmt);</span><br><span class="line">            stmt-&gt;commandType = CMD_UTILITY;</span><br><span class="line">            stmt-&gt;canSetTag = query-&gt;canSetTag;</span><br><span class="line">            stmt-&gt;utilityStmt = query-&gt;utilityStmt;</span><br><span class="line">            stmt-&gt;stmt_location = query-&gt;stmt_location;</span><br><span class="line">            stmt-&gt;stmt_len = query-&gt;stmt_len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            stmt = pg_plan_query(query, cursorOptions, boundParams);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stmt_list = lappend(stmt_list, stmt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stmt_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pg_plan_queries()</code> 函数的处理于解析分析与规则重写相同，针对 DDL 语句就是将查询计划书的封装到执行计划树中，而非 DDL 的语句处理则通过 <code>pg_plan_query()</code> 函数进行处理，其过程相对比较复杂。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL CREATE TABLE 语法分析</title>
    <url>/2019/05/postgresql-create-table-syntax-analysis/</url>
    <content><![CDATA[<p>PostgreSQL 采用 flex 进行词法分析，随后利用 yacc 进行语法分析，其词法与语法分析在 scan.l 和 gram.y 文件中实现。本文主要针对 PostgreSQL 的建表语句 <code>CREATE TABLE</code> 来分析 PostgreSQL 数据库的词法、语法分析，并简要介绍整个 PostgreSQL 数据库的执行过程。</p>
<a id="more"></a>

<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>PostgreSQL 的词法以及语法分析相关的文件存放在 <code>src/include/parser/</code> 和 <code>src/backend/parser</code> 目录下，上文所介绍的 scan.l 和 gram.y 文件即在 <code>src/backend/parser</code> 目录中。本文对于词法分析不做详细介绍，PostgreSQL 将词法分析的结果交给语法分析模块进行语法分析，而语法分析的关键代码即在 gram.y 文件中。下面我们来看看 gram.y 文件的组成，该文件分为三个部分：声明部分 (declarations)、语法规则 (rules) 以及程序实现 (programs)。在声明部分其引入了 PostgreSQL 相关的头文件、函数声明等；第二部分规则给出了 PostgreSQL 数据库中 SQL 语句的定义；第三部分则包含了语法解析的初始化实现、节点的创建等函数定义。</p>
<p>现在，我们主要来看看规则部分的定义。PostgreSQL 关于 SQL 的规则定义开始于 stmtblock，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *  The target production for the whole parse.</span><br><span class="line"> *&#x2F;</span><br><span class="line">stmtblock:  stmtmulti</span><br><span class="line">            &#123;</span><br><span class="line">                pg_yyget_extra(yyscanner)-&gt;parsetree &#x3D; $1;</span><br><span class="line">            &#125;</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * At top level, we wrap each stmt with a RawStmt node carrying start location</span><br><span class="line"> * and length of the stmt&#39;s text.  Notice that the start loc&#x2F;len are driven</span><br><span class="line"> * entirely from semicolon locations (@2).  It would seem natural to use</span><br><span class="line"> * @1 or @3 to get the true start location of a stmt, but that doesn&#39;t work</span><br><span class="line"> * for statements that can start with empty nonterminals (opt_with_clause is</span><br><span class="line"> * the main offender here); as noted in the comments for YYLLOC_DEFAULT,</span><br><span class="line"> * we&#39;d get -1 for the location in such cases.</span><br><span class="line"> * We also take care to discard empty statements entirely.</span><br><span class="line"> *&#x2F;</span><br><span class="line">stmtmulti:  stmtmulti &#39;;&#39; stmt</span><br><span class="line">                &#123;</span><br><span class="line">                    if ($1 !&#x3D; NIL)</span><br><span class="line">                    &#123;</span><br><span class="line">                        &#x2F;* update length of previous stmt *&#x2F;</span><br><span class="line">                        updateRawStmtEnd(llast_node(RawStmt, $1), @2);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if ($3 !&#x3D; NULL)</span><br><span class="line">                        $$ &#x3D; lappend($1, makeRawStmt($3, @2 + 1));</span><br><span class="line">                    else</span><br><span class="line">                        $$ &#x3D; $1;</span><br><span class="line">                &#125;</span><br><span class="line">            | stmt</span><br><span class="line">                &#123;</span><br><span class="line">                    if ($1 !&#x3D; NULL)</span><br><span class="line">                        $$ &#x3D; list_make1(makeRawStmt($1, 0));</span><br><span class="line">                    else</span><br><span class="line">                        $$ &#x3D; NIL;</span><br><span class="line">                &#125;</span><br><span class="line">        ;</span><br></pre></td></tr></table></figure>

<p>PostgreSQL 的规则从 <code>stmtblock</code> 开始，它被定义为 <code>stmtmulti</code> 对象，其中 <code>$1</code> 即代表 <code>stmtmulti</code>，它最终被复制给 <code>base_yy_extra_type</code> 的 <code>parsetree</code> 成员，而 <code>parsetree</code> 是一个链表，它存储的是解析之后的原始解析树对象。<code>stmtmulti</code> 的定义则采用递归的方式进行定义，它可以是 <code>stmtmulti</code> 加上 <code>stmt</code> 也可以是单独的 <code>stmt</code>，但最终是以 <code>stmt</code> 对象来解析，而多个 <code>stmt</code> 对象则是通过链表链接起来的。</p>
<p>接下来，我们看看 <code>stmt</code> 是如何定义的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stmt :</span><br><span class="line">            AlterEventTrigStmt</span><br><span class="line">            | AlterCollationStmt</span><br><span class="line">            | AlterDatabaseStmt</span><br><span class="line">            | AlterDatabaseSetStmt</span><br><span class="line">            | AlterDefaultPrivilegesStmt</span><br><span class="line">            | AlterDomainStmt</span><br><span class="line">            | AlterEnumStmt</span><br><span class="line">            | AlterExtensionStmt</span><br><span class="line">            | AlterExtensionContentsStmt</span><br><span class="line">            | AlterFdwStmt</span><br><span class="line">            | AlterForeignServerStmt</span><br><span class="line">            | AlterForeignTableStmt</span><br><span class="line">              ...</span><br><span class="line">            | CopyStmt</span><br><span class="line">            | CreateAmStmt</span><br><span class="line">            | CreateAsStmt</span><br><span class="line">            | CreateAssertionStmt</span><br><span class="line">            | CreateCastStmt</span><br><span class="line">            | CreateConversionStmt</span><br><span class="line">            | CreateDomainStmt</span><br><span class="line">            | CreateExtensionStmt</span><br><span class="line">            | CreateFdwStmt</span><br><span class="line">            | CreateForeignServerStmt</span><br><span class="line">            | CreateForeignTableStmt</span><br><span class="line">            | CreateFunctionStmt</span><br><span class="line">              ...</span><br><span class="line">            | SelectStmt</span><br><span class="line">            | TransactionStmt</span><br><span class="line">            | TruncateStmt</span><br><span class="line">            | UnlistenStmt</span><br><span class="line">            | UpdateStmt</span><br><span class="line">            | VacuumStmt</span><br><span class="line">            | VariableResetStmt</span><br><span class="line">            | VariableSetStmt</span><br><span class="line">            | VariableShowStmt</span><br><span class="line">            | ViewStmt</span><br><span class="line">            | &#x2F;*EMPTY*&#x2F;</span><br><span class="line">                &#123; $$ &#x3D; NULL; &#125;</span><br><span class="line">        ;</span><br></pre></td></tr></table></figure>

<p>当你看到这个的时候是否有中似曾相识的感觉？<code>stmt</code> 包含了 PostgreSQL 所支持的 SQL 语句的语法定义，例如我们输入 <code>SELECT * FROM pg_class;</code> 时，它将通过 <code>stmt</code> 转到 <code>SelectStmt</code> 的定义处进行解析，而语句在解析完之后都会转换为对应的 <code>SelectStmt</code> 结构用于后续进行查询计划的生成。</p>
<p>现在我们针对 PostgreSQL 的建表语句进行分析，关于 <a href="https://www.postgresql.org/docs/devel/sql-createtable.html"><code>CREATE TABLE</code></a> 的语法可以在官方文档上查询。<code>CREATE TABLE</code> 的语法分析如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CreateStmt: CREATE OptTemp TABLE qualified_name &#39;(&#39; OptTableElementList &#39;)&#39;</span><br><span class="line">            OptInherit OptPartitionSpec table_access_method_clause OptWith</span><br><span class="line">            OnCommitOption OptTableSpace</span><br><span class="line">                &#123;</span><br><span class="line">                    CreateStmt *n &#x3D; makeNode(CreateStmt);</span><br><span class="line">                    $4-&gt;relpersistence &#x3D; $2;</span><br><span class="line">                    n-&gt;relation &#x3D; $4;</span><br><span class="line">                    n-&gt;tableElts &#x3D; $6;</span><br><span class="line">                    n-&gt;inhRelations &#x3D; $8;</span><br><span class="line">                    n-&gt;partspec &#x3D; $9;</span><br><span class="line">                    n-&gt;ofTypename &#x3D; NULL;</span><br><span class="line">                    n-&gt;constraints &#x3D; NIL;</span><br><span class="line">                    n-&gt;accessMethod &#x3D; $10;</span><br><span class="line">                    n-&gt;options &#x3D; $11;</span><br><span class="line">                    n-&gt;oncommit &#x3D; $12;</span><br><span class="line">                    n-&gt;tablespacename &#x3D; $13;</span><br><span class="line">                    n-&gt;if_not_exists &#x3D; false;</span><br><span class="line">                    $$ &#x3D; (Node *)n;</span><br><span class="line">                &#125;</span><br><span class="line">				...</span><br></pre></td></tr></table></figure>

<p>如上所示，<code>CREATE TABLE</code> 由关键字 <code>CREATE</code> 和 <code>TABLE</code> 以及其他一些语法解析对象组成。</p>
<ul>
<li><strong>OptTemp</strong> - 临时表的选项，表明该表是否为临时表，此外该选项还可以指定创建无日志表。</li>
<li>__qualified_name__ - 表名，可以指定表所在的 schema。</li>
<li><strong>OptTableElementList</strong> - 由链表构成的表属性列。</li>
<li><strong>OptInherit</strong> - 表继承相关信息。</li>
<li><strong>OptPartitionSpec</strong> - 表分区相关信息。</li>
<li>__table_access_method_clause__ - 该选项是计划在 PostgreSQL 12 版本中给出的用于替换存储引擎的选项。</li>
<li><strong>OptWith</strong> - <code>WITH</code> 选项，用于指定表的一些特定选项，例如 <code>fillfactor</code>、<code>parallel_workers</code> 等。</li>
<li><strong>OnCommitOption</strong> - 指定数据在提交时的行为。</li>
<li><strong>OptTableSpace</strong> - 指定表空间信息。</li>
</ul>
<p>从上面的语法分析可以看到，<code>CREATE TABLE</code> 语句在执行完语法分析之后将转换为 <code>CreateStmt</code> 对象，其定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ----------------------</span></span><br><span class="line"><span class="comment"> *      Create Table Statement</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> in the raw gram.y output, ColumnDef and Constraint nodes are</span></span><br><span class="line"><span class="comment"> * intermixed in tableElts, and constraints is NIL.  After parse analysis,</span></span><br><span class="line"><span class="comment"> * tableElts contains just ColumnDefs, and constraints contains just</span></span><br><span class="line"><span class="comment"> * Constraint nodes (in fact, only CONSTR_CHECK nodes, in the present</span></span><br><span class="line"><span class="comment"> * implementation).</span></span><br><span class="line"><span class="comment"> * ----------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CreateStmt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NodeTag     type;</span><br><span class="line">    RangeVar   *relation;       <span class="comment">/* relation to create */</span></span><br><span class="line">    List       *tableElts;      <span class="comment">/* column definitions (list of ColumnDef) */</span></span><br><span class="line">    List       *inhRelations;   <span class="comment">/* relations to inherit from (list of</span></span><br><span class="line"><span class="comment">                                 * inhRelation) */</span></span><br><span class="line">    PartitionBoundSpec *partbound;  <span class="comment">/* FOR VALUES clause */</span></span><br><span class="line">    PartitionSpec *partspec;    <span class="comment">/* PARTITION BY clause */</span></span><br><span class="line">    TypeName   *ofTypename;     <span class="comment">/* OF typename */</span></span><br><span class="line">    List       *constraints;    <span class="comment">/* constraints (list of Constraint nodes) */</span></span><br><span class="line">    List       *options;        <span class="comment">/* options from WITH clause */</span></span><br><span class="line">    OnCommitAction oncommit;    <span class="comment">/* what do we do at COMMIT? */</span></span><br><span class="line">    <span class="keyword">char</span>       *tablespacename; <span class="comment">/* table space to use, or NULL */</span></span><br><span class="line">    <span class="keyword">char</span>       *accessMethod;   <span class="comment">/* table access method */</span></span><br><span class="line">    <span class="keyword">bool</span>        if_not_exists;  <span class="comment">/* just do nothing if it already exists? */</span></span><br><span class="line">&#125; CreateStmt;</span><br></pre></td></tr></table></figure>

<p>PostgreSQL 在实现时对于内部节点采用了继承的思想，拿我们上面的 <code>CreateStmt</code> 结构体来说，它的第一个成员为 <code>NodeTag</code> 类型，当我们通过 <code>makeNode(CreateStmt)</code> 函数创建 <code>CreateStmt</code> 对象时，其内部通过一个 <code>switch</code> 来判断具体的节点类型，并分配存储空间，而在之后都转换为 <code>Node</code> 类型进行使用，如来 <code>$$ = (Node *) n;</code> 所示。</p>
<p>假如我们有如下的建表语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> (<span class="keyword">id</span> <span class="built_in">int</span>, info <span class="built_in">text</span>);</span><br></pre></td></tr></table></figure>

<p>根据上面的语法规则，由于 <code>OptTemp</code> 部分没有指定因此其值为 <code>RELPERSISTENCE_PERMANENT</code>，<code>qualified_name</code> 则是一个 <code>RangeVar</code> 对象，其结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RangeVar - range variable, used in FROM clauses</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also used to represent table names in utility statements; there, the alias</span></span><br><span class="line"><span class="comment"> * field is not used, and inh tells whether to apply the operation</span></span><br><span class="line"><span class="comment"> * recursively to child tables.  In some contexts it is also useful to carry</span></span><br><span class="line"><span class="comment"> * a TEMP table indication here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RangeVar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NodeTag     type;</span><br><span class="line">    <span class="keyword">char</span>       *catalogname;    <span class="comment">/* the catalog (database) name, or NULL */</span></span><br><span class="line">    <span class="keyword">char</span>       *schemaname;     <span class="comment">/* the schema name, or NULL */</span></span><br><span class="line">    <span class="keyword">char</span>       *relname;        <span class="comment">/* the relation/sequence name */</span></span><br><span class="line">    <span class="keyword">bool</span>        inh;            <span class="comment">/* expand rel by inheritance? recursively act</span></span><br><span class="line"><span class="comment">                                 * on children? */</span></span><br><span class="line">    <span class="keyword">char</span>        relpersistence; <span class="comment">/* see RELPERSISTENCE_* in pg_class.h */</span></span><br><span class="line">    Alias      *alias;          <span class="comment">/* table alias &amp; optional column aliases */</span></span><br><span class="line">    <span class="keyword">int</span>         location;       <span class="comment">/* token location, or -1 if unknown */</span></span><br><span class="line">&#125; RangeVar;</span><br></pre></td></tr></table></figure>

<p>PostgreSQL 在解析完表名之后会将表名 <code>test</code> 存放到 <code>RangeVar</code> 对象的 <code>relname</code> 成员中，随后使用<br><code>OptTemp</code> 的值更新 <code>RangeVar</code> 的 <code>relpersistence</code> 成员。</p>
<p>接着，PostgreSQL 对表的属性列进行解析，即 <code>OptTableElementList</code>，它对应的定义为 <code>TableElementList</code>，而 <code>TableElementList</code> 被定义为 <code>TableElement</code> 和 <code>TableElementList &#39;,&#39; TableElement</code>。<code>TableElement</code> 的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TableElement:</span><br><span class="line">            columnDef                           &#123; $$ &#x3D; $1; &#125;</span><br><span class="line">            | TableLikeClause                   &#123; $$ &#x3D; $1; &#125;</span><br><span class="line">            | TableConstraint                   &#123; $$ &#x3D; $1; &#125;</span><br><span class="line">        ;</span><br></pre></td></tr></table></figure>

<p>从定义可以看出，SQL 语句中表的每个属性列在解析完之后都对应一个 <code>columnDef</code> 对象，如果我们为表指定了约束条件，那么就有一个对应的 <code>TableConstraint</code> 对象，如果在其中使用了 <code>LIKE</code> 的话，就对应有一个 <code>TableLikeClause</code> 对象。在本文中我们只关注第一种情况，后面两种情况的分析其实与此类似，故不做详细分析。</p>
<p>在解析阶段，属性列由 <code>ColumnDef</code> 进行表示，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ColumnDef</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NodeTag     type;</span><br><span class="line">    <span class="keyword">char</span>       *colname;        <span class="comment">/* name of column */</span></span><br><span class="line">    TypeName   *typeName;       <span class="comment">/* type of column */</span></span><br><span class="line">    <span class="keyword">int</span>         inhcount;       <span class="comment">/* number of times column is inherited */</span></span><br><span class="line">    <span class="keyword">bool</span>        is_local;       <span class="comment">/* column has local (non-inherited) def&#x27;n */</span></span><br><span class="line">    <span class="keyword">bool</span>        is_not_null;    <span class="comment">/* NOT NULL constraint specified? */</span></span><br><span class="line">    <span class="keyword">bool</span>        is_from_type;   <span class="comment">/* column definition came from table type */</span></span><br><span class="line">    <span class="keyword">char</span>        storage;        <span class="comment">/* attstorage setting, or 0 for default */</span></span><br><span class="line">    Node       *raw_default;    <span class="comment">/* default value (untransformed parse tree) */</span></span><br><span class="line">    Node       *cooked_default; <span class="comment">/* default value (transformed expr tree) */</span></span><br><span class="line">    <span class="keyword">char</span>        identity;       <span class="comment">/* attidentity setting */</span></span><br><span class="line">    RangeVar   *identitySequence;   <span class="comment">/* to store identity sequence name for</span></span><br><span class="line"><span class="comment">                                     * ALTER TABLE ... ADD COLUMN */</span></span><br><span class="line">    <span class="keyword">char</span>        generated;      <span class="comment">/* attgenerated setting */</span></span><br><span class="line">    CollateClause *collClause;  <span class="comment">/* untransformed COLLATE spec, if any */</span></span><br><span class="line">    Oid         collOid;        <span class="comment">/* collation OID (InvalidOid if not set) */</span></span><br><span class="line">    List       *constraints;    <span class="comment">/* other constraints on column */</span></span><br><span class="line">    List       *fdwoptions;     <span class="comment">/* per-column FDW options */</span></span><br><span class="line">    <span class="keyword">int</span>         location;       <span class="comment">/* parse location, or -1 if none/unknown */</span></span><br><span class="line">&#125; ColumnDef;</span><br></pre></td></tr></table></figure>

<p><code>columnDef</code> 的语法解析如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">columnDef:  ColId Typename create_generic_options ColQualList</span><br><span class="line">                &#123;</span><br><span class="line">                    ColumnDef *n &#x3D; makeNode(ColumnDef);</span><br><span class="line">                    n-&gt;colname &#x3D; $1;</span><br><span class="line">                    n-&gt;typeName &#x3D; $2;</span><br><span class="line">                    n-&gt;inhcount &#x3D; 0;</span><br><span class="line">                    n-&gt;is_local &#x3D; true;</span><br><span class="line">                    n-&gt;is_not_null &#x3D; false;</span><br><span class="line">                    n-&gt;is_from_type &#x3D; false;</span><br><span class="line">                    n-&gt;storage &#x3D; 0;</span><br><span class="line">                    n-&gt;raw_default &#x3D; NULL;</span><br><span class="line">                    n-&gt;cooked_default &#x3D; NULL;</span><br><span class="line">                    n-&gt;collOid &#x3D; InvalidOid;</span><br><span class="line">                    n-&gt;fdwoptions &#x3D; $3;</span><br><span class="line">                    SplitColQualList($4, &amp;n-&gt;constraints, &amp;n-&gt;collClause,</span><br><span class="line">                                     yyscanner);</span><br><span class="line">                    n-&gt;location &#x3D; @1;</span><br><span class="line">                    $$ &#x3D; (Node *)n;</span><br><span class="line">                &#125;</span><br><span class="line">        ;</span><br></pre></td></tr></table></figure>

<p>例如，上面的示例语句将产生两个 <code>ColumnDef</code> 对象，它们通过链表组织在一起，链表的第一个节点的 <code>colname</code> 和 <code>typeName</code> 分别为 <code>id</code> 和 <code>int</code>；第二节点的 <code>colname</code> 和 <code>typeName</code> 分别为 <code>info</code> 和 <code>text</code>。</p>
<p>上面基本上就将示例给出的建表语法介绍完了，<code>CREATE TABLE</code> 语句解析完之后创建的 <code>CreateStmt</code> 对象将通过 <code>makeRawStmt()</code> 函数包装到 <code>RawStmt</code> 结构中，<code>RawStmt</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      RawStmt --- container for any one statement&#x27;s raw parse tree</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parse analysis converts a raw parse tree headed by a RawStmt node into</span></span><br><span class="line"><span class="comment"> * an analyzed statement headed by a Query node.  For optimizable statements,</span></span><br><span class="line"><span class="comment"> * the conversion is complex.  For utility statements, the parser usually just</span></span><br><span class="line"><span class="comment"> * transfers the raw parse tree (sans RawStmt) into the utilityStmt field of</span></span><br><span class="line"><span class="comment"> * the Query node, and all the useful work happens at execution time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * stmt_location/stmt_len identify the portion of the source text string</span></span><br><span class="line"><span class="comment"> * containing this raw statement (useful for multi-statement strings).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RawStmt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NodeTag     type;</span><br><span class="line">    Node       *stmt;           <span class="comment">/* raw parse tree */</span></span><br><span class="line">    <span class="keyword">int</span>         stmt_location;  <span class="comment">/* start location, or -1 if unknown */</span></span><br><span class="line">    <span class="keyword">int</span>         stmt_len;       <span class="comment">/* length in bytes; 0 means &quot;rest of string&quot; */</span></span><br><span class="line">&#125; RawStmt;</span><br></pre></td></tr></table></figure>

<p>从 <code>RawStmt</code> 的定义可以看出，所有语句最后都被转换为 <code>Node *</code> 的指针被存放到 <code>stmt</code> 成员中。根据 <code>makeRowStmt()</code> 函数的定义也验证的我们的看法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> RawStmt *</span><br><span class="line">makeRawStmt(Node *stmt, <span class="keyword">int</span> stmt_location)</span><br><span class="line">&#123;</span><br><span class="line">    RawStmt    *rs = makeNode(RawStmt);</span><br><span class="line"></span><br><span class="line">    rs-&gt;stmt = stmt;</span><br><span class="line">    rs-&gt;stmt_location = stmt_location;</span><br><span class="line">    rs-&gt;stmt_len = <span class="number">0</span>;           <span class="comment">/* might get changed later */</span></span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>上面我们分析了 PostgreSQL 的语法分析部分，接下来我们简要介绍一下 PostgreSQL 的执行流程。首先，我们需要明确 PostgreSQL 是基于多进程开发的，每当一个连接请求过来，PostgreSQL 都将创建一个新的 <code>postgres</code> 进程用于处理用户请求，在用户将需要执行的 SQL 语句发送到后端之后，<code>postgres</code> 进程将从 <code>exec_simple_query()</code> 函数开始进行处理，其主要的流程如下：</p>
<ol>
<li>调用 <code>pg_parse_query()</code> 函数进行词法、语法分析，即我们上面介绍的内容；</li>
<li>循环遍历解析树链表对每个语句进行处理，如果没有查询语句转步骤 7；</li>
<li>调用 <code>pg_analyze_and_rewrite()</code> 函数对解析树分析并重写并生成查询计划；</li>
<li>调用 <code>pg_plan_queries()</code> 对查询树进行优化并选择一条最优路径生成执行计划；</li>
<li>创建 <code>Portal</code> 对象并调用 <code>PortalRun()</code> 函数执行查询计划。</li>
<li>执行 <code>Portal</code> 的清理工作并转步骤 2；</li>
<li>退出。</li>
</ol>
<p>需要注意的是 DDL 在步骤 3 和步骤 4 时不会被重写或优化，而只是简单的在原始解析树外面包装对应的结构而已，只有到了步骤 5 时才会执行转换并生成查询计划。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/devel/sql-createtable.html">https://www.postgresql.org/docs/devel/sql-createtable.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 数据库大小监控</title>
    <url>/2019/09/postgresql-database-size-monitor/</url>
    <content><![CDATA[<p>最近在客户那边了解到一个需求，想要监控 PostgreSQL 数据库每天的大小变化。其实这个功能挺简单的，PostgreSQL 可以通过函数 <code>pg_database_size()</code> 来获取数据库的大小，而客户需要做的就是每天去执行一下，并与上次的结果进行比较就可以得到了。当然，手动执行的效率不是很高，因此，我利用业余时间整理了一下，将这个需求通过 PostgreSQL 插件的形式提供出来。本文主要介绍一下如何实现这个功能。</p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实这个功能的思路挺简单的，首先记录数据库大小，然后定期获取数据库大小，并与上一次数据库的大小相减获取这个数据库的增量，就这么简单。那么，我们需要通过什么技术来实现这个功能呢？当然，我们需要一个定时器；其次，我们需要一个结构来维护数据库的大小历史变更。</p>
<p>当然我们可以通过 shell 来实现这个功能，利用 crontab 添加一个定时器，然后将数据库的大小保存下来，再次获取时数据库大小时减去保存下来的数据库大小值便能获取增量。这里有一个问题就是数据库的大小历史如何来维护？</p>
<p>如果是通过数据库插件来实现，我们可以直接将这些历史变更记录在数据表中，这样做也可以方便后续查询。那么定时器如何实现了？这个其实 PostgreSQL 已经为我们提供了。我们可以通过创建一个后台进程来定期获取数据库的大小，并维护数据库增量信息。</p>
<h2 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程"></a>后台进程</h2><p>PostgreSQL 扩展可以在单独的进程中运行用户提供的代码。这些进程由 postgres 启动、停止和监控，这使得它们的生命周期与服务器的状态紧密相关。这些进程可以选择附加到 PostgreSQL 的共享内存区域并在内部连接到数据库。PostgreSQL 后台工作进程由 <code>BackgroundWorker</code> 结构来定义（如下所示），它需要在 <code>_PG_init()</code> 函数中通过 <code>RegisterBackgroundWorker()</code> 来注册。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*bgworker_main_type)</span><span class="params">(Datum main_arg)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BackgroundWorker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>        bgw_name[BGW_MAXLEN];</span><br><span class="line">    <span class="keyword">char</span>        bgw_type[BGW_MAXLEN];</span><br><span class="line">    <span class="keyword">int</span>         bgw_flags;</span><br><span class="line">    BgWorkerStartTime bgw_start_time;</span><br><span class="line">    <span class="keyword">int</span>         bgw_restart_time;       <span class="comment">/* in seconds, or BGW_NEVER_RESTART */</span></span><br><span class="line">    <span class="keyword">char</span>        bgw_library_name[BGW_MAXLEN];</span><br><span class="line">    <span class="keyword">char</span>        bgw_function_name[BGW_MAXLEN];</span><br><span class="line">    Datum       bgw_main_arg;</span><br><span class="line">    <span class="keyword">char</span>        bgw_extra[BGW_EXTRALEN];</span><br><span class="line">    <span class="keyword">int</span>         bgw_notify_pid;</span><br><span class="line">&#125; BackgroundWorker;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 该结构在不同的版本之间可能有所不同，请以<a href="https://www.postgresql.org/docs/11/bgworker.html">官网文档</a>为准，本文基于 PostgreSQL 11 版本。</p>
<ul>
<li><code>bgw_name</code> 和 <code>bgw_type</code> 是在日志消息，进程列表和类似上下文中使用的字符串。</li>
<li><code>bgw_flags</code> 是一个按位或位掩码，表示模块想要的功能。目前该域有两个值：<code>BGWORKER_SHMEM_ACCESS</code> - 请求共享内存访问；<code>BGWORKER_BACKEND_DATABASE_CONNECTION</code> - 请求能够建立数据库连接，以便以后可以运行事务和查询(需要与 <code>BGWORKER_SHMEM_ACCESS</code> 联合使用)。</li>
<li><code>bgw_start_time</code> 是 postgres 启动进程的服务器状态。目前该域有三个值：<code>BgWorkerStart_PostmasterStart</code> - postgres 本身完成自己的初始化后立即开始，请求此进程的进程不符合数据库连接的条件；<code>BgWorkerStart_ConsistentState</code> - 在热备用数据库中达到一致状态后立即启动，允许进程以只读的方式连接到数据库；<code>BgWorkerStart_RecoveryFinished</code> - 系统进入正常读写状态后立即启动。最后两个值在不是热备用的服务器中是等效的。此设置仅指示何时启动进程；当达到不同的状态时，它们不会停止。</li>
<li><code>bgw_restart_time</code> 是 postgres 在重新启动进程之前应该等待的时间间隔（以秒为单位）。当设置为 <code>BGW_NEVER_RESTART</code> 则表示崩溃后不重新启动进程。</li>
<li><code>bgw_library_name</code> - 是库的名称，在该库中应该包含后台工作进程的入口点。如果是从核心代码中加载函数，需要将其设置为 “postgres”。</li>
<li><code>bgw_function_name</code> 是动态加载库中函数的名称，该函数是新后台工作进程的入口点。</li>
<li><code>bgw_main_arg</code> 是后台进程入口函数的参数，参数类型为 <code>Datum</code>。</li>
</ul>
<p>更多关于该结构的介绍请看官方文档，任何时候您都应该以官方文档为主。</p>
<p>我们可以在后台进程中通过定时器来定时执行相应的 SQL 来查询数据库大小并计算数据库的增量。PostgreSQL 提供了 Latch 机制，我们可以利用它很方便地实现定时器功能。</p>
<h2 id="扩展插件"><a href="#扩展插件" class="headerlink" title="扩展插件"></a>扩展插件</h2><p>关于如何编写 PostgreSQL 可以参考<a href="/2018/12/write-postgresql-extension/" title="这里">这里</a>，当然第一手资料还是<a href="https://www.postgresql.org/docs/11/extend-pgxs.html">官方文档</a>。我们首先新建一个 <code>pg_dbsm</code> 目录用于存放该插件源码，其内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  pg_dbsm ls -l</span><br><span class="line">total 48</span><br><span class="line">-rw-r--r--  1 japinli  staff   277 Sep  4 22:32 Makefile</span><br><span class="line">-rw-r--r--  1 japinli  staff   244 Sep  4 22:29 README.md</span><br><span class="line">-rw-r--r--  1 japinli  staff   402 Sep  4 22:24 pg_dbsm--0.0.1.sql</span><br><span class="line">-rw-r--r--  1 japinli  staff  7785 Sep  4 22:38 pg_dbsm.c</span><br><span class="line">-rw-r--r--  1 japinli  staff    98 Sep  4 22:23 pg_dbsm.control</span><br></pre></td></tr></table></figure>

<p>为了方便配置定时器的时间，我们将定时器的值以参数的形式给出，与此同时，我们需要连接一个数据库用于创建需要存储数据库大小历史记录，为此，我们增加了一个数据库参数，我们将在该数据库中建立一个名为 <code>dbsm</code> 的数据表，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# \d+ dbsm</span><br><span class="line">                                            Table &quot;public.dbsm&quot;</span><br><span class="line"> Column  |           Type           | Collation | Nullable | Default | Storage | Stats target | Description</span><br><span class="line">---------+--------------------------+-----------+----------+---------+---------+--------------+-------------</span><br><span class="line"> datname | name                     |           | not null |         | plain   |              |</span><br><span class="line"> created | timestamp with time zone |           |          | now()   | plain   |              |</span><br><span class="line"> datsize | bigint                   |           | not null |         | plain   |              |</span><br><span class="line"> incsize | bigint                   |           |          |         | plain   |              |</span><br><span class="line">Indexes:</span><br><span class="line">    &quot;idx_datname_created&quot; btree (datname, created)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后台进程的处理流程如下：</p>
<ol>
<li>设置信号处理函数；</li>
<li>连接 <code>dbsm_database</code> 指定的数据库，默认为 <code>postgres</code>；</li>
<li>初始化数据库表对象，即 <code>dbsm</code>，并建立索引；</li>
<li>构建查询 SQL 语句；</li>
<li>循环执行查询 SQL 语句并更新 <code>dbsm</code> 表。</li>
</ol>
<p>上面的流程主要在函数 <code>dbsm_main()</code> 中体现，其代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dbsm_main()</span><br><span class="line">&#123;</span><br><span class="line">    StringInfoData    buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Establish signal handlers before unblocking signals. */</span></span><br><span class="line">    pqsignal(SIGHUP, dbsm_sighup);</span><br><span class="line">    pqsignal(SIGTERM, dbsm_sigterm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We&#x27;re now ready to receive signals */</span></span><br><span class="line">    BackgroundWorkerUnblockSignals();</span><br><span class="line"></span><br><span class="line">    BackgroundWorkerInitializeConnection(dbsm_database, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    initialize_dbsm_object();</span><br><span class="line"></span><br><span class="line">    initStringInfo(&amp;buf);</span><br><span class="line">    appendStringInfo(&amp;buf,</span><br><span class="line">                     <span class="string">&quot;WITH m AS (SELECT DISTINCT ON (datname) datname, &quot;</span></span><br><span class="line">                     <span class="string">&quot;datsize FROM dbsm ORDER BY datname, created DESC) &quot;</span></span><br><span class="line">                     <span class="string">&quot;INSERT INTO dbsm SELECT d.datname, now(), &quot;</span></span><br><span class="line">                     <span class="string">&quot;pg_database_size(d.datname) AS datsize, &quot;</span></span><br><span class="line">                     <span class="string">&quot;CASE WHEN m.datsize = NULL THEN 0 &quot;</span></span><br><span class="line">                     <span class="string">&quot;ELSE pg_database_size(d.datname) - m.datsize END AS incsize &quot;</span></span><br><span class="line">                     <span class="string">&quot;FROM pg_database d LEFT JOIN m ON m.datname = d.datname;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Main loop: do this until the SIGTERM handler tells us to terminate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (!got_sigterm)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>    ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Background workers mustn&#x27;t call usleep() or any direct equivalent:</span></span><br><span class="line"><span class="comment">         * instead, they may wait on their process latch, which sleeps as</span></span><br><span class="line"><span class="comment">         * necessary, but is awakened if postmaster dies.  That way the</span></span><br><span class="line"><span class="comment">         * background process goes away immediately in an emergency.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        (<span class="keyword">void</span>) WaitLatch(MyLatch,</span><br><span class="line">                         WL_LATCH_SET | WL_TIMEOUT | WL_POSTMASTER_DEATH,</span><br><span class="line">                         dbsm_naptime * <span class="number">1000L</span>,</span><br><span class="line">                         PG_WAIT_EXTENSION);</span><br><span class="line">        ResetLatch(MyLatch);</span><br><span class="line"></span><br><span class="line">        CHECK_FOR_INTERRUPTS();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * In case of a SIGHUP, just reload the configuration.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (got_sighup)</span><br><span class="line">        &#123;</span><br><span class="line">            got_sighup = <span class="literal">false</span>;</span><br><span class="line">            ProcessConfigFile(PGC_SIGHUP);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Start a transaction on which we can run queries.  Note that each</span></span><br><span class="line"><span class="comment">         * StartTransactionCommand() call should be preceded by a</span></span><br><span class="line"><span class="comment">         * SetCurrentStatementStartTimestamp() call, which sets both the time</span></span><br><span class="line"><span class="comment">         * for the statement we&#x27;re about the run, and also the transaction</span></span><br><span class="line"><span class="comment">         * start time.  Also, each other query sent to SPI should probably be</span></span><br><span class="line"><span class="comment">         * preceded by SetCurrentStatementStartTimestamp(), so that statement</span></span><br><span class="line"><span class="comment">         * start time is always up to date.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The SPI_connect() call lets us run queries through the SPI manager,</span></span><br><span class="line"><span class="comment">         * and the PushActiveSnapshot() call creates an &quot;active&quot; snapshot</span></span><br><span class="line"><span class="comment">         * which is necessary for queries to have MVCC data to work on.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The pgstat_report_activity() call makes our activity visible</span></span><br><span class="line"><span class="comment">         * through the pgstat views.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SetCurrentStatementStartTimestamp();</span><br><span class="line">        StartTransactionCommand();</span><br><span class="line">        SPI_connect();</span><br><span class="line">        PushActiveSnapshot(GetTransactionSnapshot());</span><br><span class="line">        pgstat_report_activity(STATE_RUNNING, buf.data);</span><br><span class="line"></span><br><span class="line">        ret = SPI_execute(buf.data, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret != SPI_OK_INSERT)</span><br><span class="line">            elog(FATAL, <span class="string">&quot;execute: \&quot;%s\&quot; failed&quot;</span>, buf.data);</span><br><span class="line"></span><br><span class="line">        SPI_finish();</span><br><span class="line">        PopActiveSnapshot();</span><br><span class="line">        CommitTransactionCommand();</span><br><span class="line">        pgstat_report_stat(<span class="literal">false</span>);</span><br><span class="line">        pgstat_report_activity(STATE_IDLE, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pfree(buf.data);</span><br><span class="line">    proc_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当启动数据库后，我们运行一段时间后查询表 <code>dbsm</code> 便可以看到如图所示的结果。</p>
<img src="/2019/09/postgresql-database-size-monitor/result.png" class="" title="效果图">

<p>完整代码在<a href="https://github.com/japinli/pg_dbsm">这里</a>。当然，这个代码目前还不完善，可能存在一些问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/11/bgworker.html">https://www.postgresql.org/docs/11/bgworker.html</a><br>[2] <a href="https://www.postgresql.org/docs/11/extend-pgxs.html">https://www.postgresql.org/docs/11/extend-pgxs.html</a><br>[3] <a href="https://tapoueh.org/images/confs/extension-tutoriel.pdf">https://tapoueh.org/images/confs/extension-tutoriel.pdf</a><br>[4] <a href="https://github.com/postgres/postgres/blob/REL_11_STABLE/src/test/modules/worker_spi/worker_spi.c">https://github.com/postgres/postgres/blob/REL_11_STABLE/src/test/modules/worker_spi/worker_spi.c</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 编辑查询缓冲区</title>
    <url>/2020/05/postgresql-edit-query-buffer/</url>
    <content><![CDATA[<p>我们经常需要在 psql 中修改查询语句，例如，我们编辑了几行查询语句，然后需要修改之前的内容，我之前额做法就是 Ctrl-C 然后在重新输入。其实，我们可以不必这么复杂。我们可以使用 <code>\e</code> 命令来编辑查询缓冲区。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# SELECT * FROM</span><br><span class="line">postgres-# pg_calss</span><br><span class="line">postgres-# WHERE relname &#x3D; &#39;pg_class&#39;</span><br><span class="line">postgres-#</span><br></pre></td></tr></table></figure>

<p>此时，我们发现 <code>pg_calss</code> 拼写错了，那么我们可以通过 <code>\e</code> 对其进行修改。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres-# WHERE relname &#x3D; &#39;pg_class&#39;</span><br><span class="line">postgres-# \e</span><br><span class="line">  1 SELECT * FROM</span><br><span class="line">  2 pg_class</span><br><span class="line">  3 WHERE relname &#x3D; &#39;pg_class&#39;</span><br></pre></td></tr></table></figure>

<p><code>\e</code> 命令将会创建一个临时文件，然后我们便可以通过编辑文件的方式对其进行修改了，当保存之后，psql 将会把文件内容存放到查询缓冲区中。</p>
<p><code>\e [ filename ] [ line_number ]</code> 命令还可以接文件和行号，文件指定了我们想要编辑的文件，行号则表明文件打开时光标所处的位置。注意，如果仅跟一个数字，该命令将其视为行号，例如 <code>\e 3</code> 表示编辑查询缓冲区，并将光标移动到第三行。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL HASH 索引拾遗</title>
    <url>/2020/02/postgresql-hash-index/</url>
    <content><![CDATA[<p>PostgreSQL 的 HASH 索引在 9.6 和 10 版本中有所不同，主要的区别在于 HASH 索引在 9.6 及其之前的版本中不会记录在 WAL 日志中，然而在 10 及其之后的版本这个已经被修复了。</p>
<p>例如，下面是在 PostgreSQL 9.6.17 中创建 HASH 索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# CREATE INDEX id_hash_index ON hash_table USING hash(id);</span><br><span class="line">WARNING:  hash indexes are not WAL-logged and their use is discouraged</span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>

<p>从警告中可以看到，PostgreSQL 已经给出了明确提示。然而在 PostgreSQL 12.2 中，创建 HASH 索引则没有上述提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# create index idx_hash_id on hash_table using hash(id);</span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>首先我们通过 ruby 创建测试数据：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">$ ruby -e <span class="string">&#x27;(1..1000).each &#123; |i| puts i.to_s.rjust(20, &quot;0&quot;) &#125;&#x27;</span> &gt; data.txt</span><br></pre></td></tr></table></figure>

<p>我们采用 PG9.6.17 搭建主从同步流复制，随后在主库上创建 <code>hash_table</code> 表，然后插入数据，并在从库查询，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# create table hash_table(id varchar(256));</span><br><span class="line">postgres&#x3D;# copy hash_table from &#39;&#x2F;path&#x2F;to&#x2F;data.txt&#39;;</span><br><span class="line">postgres&#x3D;# create index idx_hash_table_id on hash_table using hash(id);</span><br></pre></td></tr></table></figure>

<p>接着，我们分别在主库和从库上查看，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# select count(*) from hash_table;  -- 主库</span><br><span class="line"> count</span><br><span class="line">-------</span><br><span class="line"> 10000</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# select * from hash_table where id &#x3D; &#39;00000000000000000023&#39;;</span><br><span class="line">          id</span><br><span class="line">----------------------</span><br><span class="line"> 00000000000000000023</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# select pg_size_pretty(pg_relation_size(&#39;idx_hash_table_id));</span><br><span class="line"> pg_size_pretty</span><br><span class="line">----------------</span><br><span class="line"> 528 kB</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# select count(*) from hash_table;  -- 从库</span><br><span class="line"> count</span><br><span class="line">-------</span><br><span class="line"> 10000</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# select * from hash_table where id &#x3D; &#39;00000000000000000023&#39;;</span><br><span class="line">ERROR:  could not read block 0 in file &quot;base&#x2F;12407&#x2F;24577&quot;: read only 0 of 8192 bytes</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# select pg_size_pretty(pg_relation_size(&#39;idx_hash_table_id));</span><br><span class="line"> pg_size_pretty</span><br><span class="line">----------------</span><br><span class="line"> 0 bytes</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>从上面的输出结果也可以看到，HASH 索引并没有记录到 WAL 日志中，因此有关 HASH 索引的操作都不会在从节点进行重放。</p>
<p>同样地，我们也可以在 PG12.2 中进行测试。其结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# select count(*) from hash_table;  -- 主库</span><br><span class="line"> count</span><br><span class="line">-------</span><br><span class="line"> 10000</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# select * from hash_table where id &#x3D; &#39;00000000000000000023&#39;;</span><br><span class="line">          id</span><br><span class="line">----------------------</span><br><span class="line"> 00000000000000000023</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# select pg_size_pretty(pg_relation_size(&#39;idx_hash_table_id&#39;));</span><br><span class="line"> pg_size_pretty</span><br><span class="line">----------------</span><br><span class="line"> 592 kB</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# select count(*) from hash_table;  -- 从库</span><br><span class="line"> count</span><br><span class="line">-------</span><br><span class="line"> 10000</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# select * from hash_table where id &#x3D; &#39;00000000000000000023&#39;;</span><br><span class="line">          id</span><br><span class="line">----------------------</span><br><span class="line"> 00000000000000000023</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# select pg_size_pretty(pg_relation_size(&#39;idx_hash_table_id&#39;));</span><br><span class="line"> pg_size_pretty</span><br><span class="line">----------------</span><br><span class="line"> 592 kB</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://postgrespro.com/blog/pgsql/4161321">https://postgrespro.com/blog/pgsql/4161321</a><br>[2] <a href="https://www.postgresql.org/docs/9.6/continuous-archiving.html">https://www.postgresql.org/docs/9.6/continuous-archiving.html</a><br>[3] <a href="https://www.postgresql.org/docs/10/continuous-archiving.html">https://www.postgresql.org/docs/10/continuous-archiving.html</a><br>[4] <a href="https://blog.andrebarbosa.co/hash-indexes-on-postgres/">https://blog.andrebarbosa.co/hash-indexes-on-postgres/</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 大对象</title>
    <url>/2020/04/postgresql-large-object/</url>
    <content><![CDATA[<p>我们知道在 Oracle 数据库中，大对象有三种类型，分别是 CLOB，BLOB 和 BFILE。在 Oracle 数据库中大对象最大存储根据配置可以达到 8TB 到 128TB。然而在 PostgreSQL 数据库中并没有提供这三种数据类型。因此在进行迁移的时候，我们需要做类型的映射。在参考文献 [2] 中提到可以将 CLOB 和 BLOB 分别映射到 text 和 bytea 数据类型上。此外，PostgreSQL 的插件 pg_largeobject 也提供了一种大对象的支持。本文简要介绍这两种大对象的使用。</p>
<a id="more"></a>

<h2 id="text-amp-bytea"><a href="#text-amp-bytea" class="headerlink" title="text &amp; bytea"></a>text &amp; bytea</h2><p>CLOB 和 BLOB 分别用于存储字符大对象和二进制大对象，这与 PostgreSQL 中的 text 和 bytea 很类似，因此在迁移 Oracle 数据库的时候也就将他们分别对应起来。在 PostgreSQL 源码（c.h）中我们可以看到如下的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">varlena</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>        vl_len_[<span class="number">4</span>];     <span class="comment">/* Do not touch this field directly! */</span></span><br><span class="line">    <span class="keyword">char</span>        vl_dat[FLEXIBLE_ARRAY_MEMBER];  <span class="comment">/* Data content is here */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VARHDRSZ        ((int32) sizeof(int32))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These widely-used datatypes are just a varlena header and the data bytes.</span></span><br><span class="line"><span class="comment"> * There is no terminating null or anything like that --- the data length is</span></span><br><span class="line"><span class="comment"> * always VARSIZE_ANY_EXHDR(ptr).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">varlena</span> <span class="title">bytea</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">varlena</span> <span class="title">text</span>;</span></span><br></pre></td></tr></table></figure>

<p>从上面的定义，我们可以发现，text 和 bytea 的定义都是 varlena 类型，即变长数据类型，所不同的是，text 用于存储可打印字符，而 bytea 用于存储二进制字符，这与 Oracle 的 CLOB 和 BLOB 是一致的。<br>varlena 类型在 PostgreSQL 的存储可能触发 <a href="https://www.postgresql.org/docs/12/storage-toast.html">TOAST 机制</a>，而采用 TOAST 机制存储的数据最大支持 1GB 的存储空间，因此这导致其存储空间和 Oracle 中的大对象不一致。</p>
<p>此外，Oracle 中的大对象支持随机读写，但是采用 text 和 bytea 类型的大对象对随机读写的支持不是很好，对于随机读可以使用如下的方式进行替代：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# select name, substring(name from 1 for 2) from people ;</span><br><span class="line"> name | substring</span><br><span class="line">------+-----------</span><br><span class="line"> Jon  | Jo</span><br><span class="line"> Jane | Ja</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>然而，对于随机写貌似没有很好的替代方案。</p>
<h2 id="pg-largeobject"><a href="#pg-largeobject" class="headerlink" title="pg_largeobject"></a>pg_largeobject</h2><p>pg_largeobject 是 PostgreSQL 插件提供的一个大对象解决方案。在 pg_largeobject 中，所有的大对象都存储在系统表 <code>pg_largeobject</code> 中；此外，每个大对象在系统表 <code>pg_largeobject_metadata</code> 中也会有一条记录大对象的相关元信息，他们的定义如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# \d pg_largeobject</span><br><span class="line">         Table &quot;pg_catalog.pg_largeobject&quot;</span><br><span class="line"> Column |  Type   | Collation | Nullable | Default</span><br><span class="line">--------+---------+-----------+----------+---------</span><br><span class="line"> loid   | oid     |           | not null |</span><br><span class="line"> pageno | integer |           | not null |</span><br><span class="line"> data   | bytea   |           | not null |</span><br><span class="line">Indexes:</span><br><span class="line">    &quot;pg_largeobject_loid_pn_index&quot; UNIQUE, btree (loid, pageno)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# \d pg_largeobject_metadata</span><br><span class="line">      Table &quot;pg_catalog.pg_largeobject_metadata&quot;</span><br><span class="line">  Column  |   Type    | Collation | Nullable | Default</span><br><span class="line">----------+-----------+-----------+----------+---------</span><br><span class="line"> oid      | oid       |           | not null |</span><br><span class="line"> lomowner | oid       |           | not null |</span><br><span class="line"> lomacl   | aclitem[] |           |          |</span><br><span class="line">Indexes:</span><br><span class="line">    &quot;pg_largeobject_metadata_oid_index&quot; UNIQUE, btree (oid)</span><br></pre></td></tr></table></figure>

<p>采用 pg_largeobject 所存储的大对象最大可以达到 4TB 的存储空间，并且__支持随机读写__。pg_largeobject 采用 OID 的方式来引用 <code>pg_largeobject</code> 表中的大对象。例如，我们创建一个表来存储图片数据，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE image(name text, raster oid);</span><br></pre></td></tr></table></figure>

<p>pg_largeobject 提供了一系列函数用于创建、导入和导出大对象，见官方文档<a href="https://www.postgresql.org/docs/12/lo-funcs.html">服务端函数</a>。下图是简单的大对象插入导出的测试输出：</p>
<img src="/2020/04/postgresql-large-object/lo-test.jpg" class="" title="Large Object Test">

<p>需要注意的是，在使用 pg_largeobject 来管理大对象时，我们需要额外的操作来管理大对象。例如，上面的示例中，如果我们想要删除表 <code>image</code> 中名称为 <code>image1</code> 的记录，我们还需在 <code>pg_largeobject</code> 中删除 <code>loid = 24598</code> 的记录。如下图所示：</p>
<img src="/2020/04/postgresql-large-object/lo-delete.jpg" class="" title="Large Object Deletion Test">

<p>通常，我们会创建一个触发器来进行 OID 的删除。此外，pg_largeobject 提供了 lo_put 和 lo_get 函数来随机读写大对象。需要注意的是，我们在使用 libpq 对大对象进行读写时必须在事务中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的说明，我们可以发现在 PostgreSQL 中的大对象处理各自存在优缺点：</p>
<table>
<thead>
<tr>
<th></th>
<th>text &amp; bytea</th>
<th>pg_largeobject</th>
</tr>
</thead>
<tbody><tr>
<td>随机读</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>随机写</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>存储限制</td>
<td>1GB</td>
<td>4TB</td>
</tr>
<tr>
<td>需要事务</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>跟踪 OID</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://docs.oracle.com/cd/B28359_01/appdev.111/b28393/adlob_intro.htm#ADLOB001">https://docs.oracle.com/cd/B28359_01/appdev.111/b28393/adlob_intro.htm#ADLOB001</a><br>[2] <a href="https://wiki.postgresql.org/wiki/Oracle_to_Postgres_Conversion">https://wiki.postgresql.org/wiki/Oracle_to_Postgres_Conversion</a><br>[3] <a href="https://wiki.postgresql.org/wiki/Largeobject_Enhancement">https://wiki.postgresql.org/wiki/Largeobject_Enhancement</a><br>[4] <a href="https://www.postgresql.org/docs/12/largeobjects.html">https://www.postgresql.org/docs/12/largeobjects.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 添加系统表</title>
    <url>/2019/08/postgresql-new-catalog/</url>
    <content><![CDATA[<p>本文将介绍如何在 PostgreSQL 中创建一个新的系统表。PostgreSQL 将系统表都存放在 <code>src/include/catalog</code> 目录下，如下图所示：</p>
<img src="/2019/08/postgresql-new-catalog/catalogs.png" class="" title="PostgresQL 系统表目录">

<p>从目录结构来看，我们大概可以猜测到 PostgreSQL 将系统表的定义和数据分别存放在两个不同的文件中，例如，系统表 <code>pg_class</code>，其表结构定义在 <code>pg_class.h</code> 文件中，而数据则在 <code>pg_class.dat</code> 文件中。此外每个表都在数据库内部都有一个唯一的 OID 来作为标识。PostgreSQL 提供了脚本来检查未使用的 OID 以及是否包含重复的 OID，它们分别为 <code>unused_oids</code> 和 <code>duplicate_oids</code>。所有的系统表都将由 <code>src/backend/catalog/Catalog.pm</code> 进行处理，该文件负责将系统表文件转换为 Perl 数据结构。</p>
<a id="more"></a>
<p>在了解了 PostgreSQL 关于系统表的基本概念之后，我们尝试添加一个自己的系统表 <code>pg_play</code>。</p>
<h2 id="系统表头文件"><a href="#系统表头文件" class="headerlink" title="系统表头文件"></a>系统表头文件</h2><p>正如我们上面看到的，我们需要在 <code>src/include/catalog</code> 目录下新建一个 <code>pg_play.h</code> 的头文件，其内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * pg_play.h</span></span><br><span class="line"><span class="comment"> *    definition of the &quot;play&quot; system catalog (pg_play)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * src/include/catalog/pg_play.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTES</span></span><br><span class="line"><span class="comment"> *    The Catalog.pm module reads this file and derives schema</span></span><br><span class="line"><span class="comment"> *    information.</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PG_PLAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_PLAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;catalog/genbki.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;catalog/pg_class_d.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ----------------</span></span><br><span class="line"><span class="comment"> *		pg_play definition.  cpp turns this into</span></span><br><span class="line"><span class="comment"> *		typedef struct FormData_pg_play</span></span><br><span class="line"><span class="comment"> * ----------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CATALOG(pg_play,<span class="number">2023</span>,PlayRelationId)</span><br><span class="line">&#123;</span><br><span class="line">	Oid         playid;</span><br><span class="line">	NameData    playname;</span><br><span class="line">&#125; FormData_pg_play;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> FormData_pg_play *Form_pg_play;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* PG_PLAY_H */</span></span></span><br></pre></td></tr></table></figure>

<p>每个系统表头文件都应该包含 <code>catalog/genbki.h</code> 头文件，该文件中定义了 <code>CATALOG</code>, <code>BKI_BOOTSTRAP</code> 等相关的宏。其中 <code>CATALOG</code> 宏的作用就是定义一个结构体变量，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CppConcat(x, y)                   x##y</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CATALOG(name,oid,oidmacro)  typedef struct CppConcat(FormData_,name)</span></span><br></pre></td></tr></table></figure>

<p>而 <code>catalog/pg_class_d.h</code> 文件则是编译时由 <code>src/backend/catalog/genbki.pl</code> 生成的一个头文件，该文件中包含了系统表属性列的编号定义。例如，<code>pg_play</code> 系统表生成的内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * pg_play_d.h</span></span><br><span class="line"><span class="comment"> *    Macro definitions for pg_play</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group</span></span><br><span class="line"><span class="comment"> * Portions Copyright (c) 1994, Regents of the University of California</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTES</span></span><br><span class="line"><span class="comment"> *  ******************************</span></span><br><span class="line"><span class="comment"> *  *** DO NOT EDIT THIS FILE! ***</span></span><br><span class="line"><span class="comment"> *  ******************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  It has been GENERATED by src/backend/catalog/genbki.pl</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PG_PLAY_D_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_PLAY_D_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PlayRelationId 2023</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Anum_pg_play_playid 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Anum_pg_play_playname 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Natts_pg_play 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>							<span class="comment">/* PG_PLAY_D_H */</span></span></span><br></pre></td></tr></table></figure>

<h2 id="系统表编译配置"><a href="#系统表编译配置" class="headerlink" title="系统表编译配置"></a>系统表编译配置</h2><p>如上所述，我们添加了系统表定义，现在我们要做的就是将其添加到编译环境中，从而使得 PostgreSQL 在编译时可以去处理我们定义的 <code>pg_play</code> 系统表。在 <code>src/backend/catalog/Makefile</code> 文件中有一个 <code>CATALOG_HEADERS</code> 目标，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CATALOG_HEADERS := \</span><br><span class="line">         pg_proc.h pg_type.h pg_attribute.h pg_class.h \</span><br><span class="line">         pg_attrdef.h pg_constraint.h pg_inherits.h pg_index.h pg_operator.h \</span><br><span class="line">         pg_opfamily.h pg_opclass.h pg_am.h pg_amop.h pg_amproc.h \</span><br><span class="line">         pg_language.h pg_largeobject_metadata.h pg_largeobject.h pg_aggregate.h \</span><br><span class="line">         pg_statistic_ext.h \</span><br><span class="line">         pg_statistic.h pg_rewrite.h pg_trigger.h pg_event_trigger.h pg_description.h \</span><br><span class="line">         pg_cast.h pg_enum.h pg_namespace.h pg_conversion.h pg_depend.h \</span><br><span class="line">         pg_database.h pg_db_role_setting.h pg_tablespace.h pg_pltemplate.h \</span><br><span class="line">         pg_authid.h pg_auth_members.h pg_shdepend.h pg_shdescription.h \</span><br><span class="line">         pg_ts_config.h pg_ts_config_map.h pg_ts_dict.h \</span><br><span class="line">         pg_ts_parser.h pg_ts_template.h pg_extension.h \</span><br><span class="line">         pg_foreign_data_wrapper.h pg_foreign_server.h pg_user_mapping.h \</span><br><span class="line">         pg_foreign_table.h pg_policy.h pg_replication_origin.h \</span><br><span class="line">         pg_default_acl.h pg_init_privs.h pg_seclabel.h pg_shseclabel.h \</span><br><span class="line">         pg_collation.h pg_partitioned_table.h pg_range.h pg_transform.h \</span><br><span class="line">         pg_sequence.h pg_publication.h pg_publication_rel.h pg_subscription.h \</span><br><span class="line">         pg_subscription_rel.h pg_play.h</span><br></pre></td></tr></table></figure>

<p>我们在末尾我们新建的 <code>pg_play</code> 系统表头文件。现在，我们在重新编译、安装并初始化数据库即可看到我们新建的 <code>pg_play</code> 系统表。如下图所示：</p>
<img src="/2019/08/postgresql-new-catalog/pg_play_catalog.png" class="" title="pg_play 系统表">

<h2 id="默认元组添加"><a href="#默认元组添加" class="headerlink" title="默认元组添加"></a>默认元组添加</h2><p>如果我们需要想 <code>pg_play</code> 系统表中添加一些默认元组，我们可以创建一个 <code>pg_play.dat</code> 的文件，其内容如下：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># pg_play.dat</span></span><br><span class="line"><span class="comment">#    Initial contents of the pg_play system catalog.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># src/include/catalog/pg_play.dat</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line"></span><br><span class="line">&#123; <span class="string">playid =&gt;</span> <span class="string">&#x27;2&#x27;</span>, <span class="string">playname =&gt;</span> <span class="string">&#x27;Play&#x27;</span> &#125;,</span><br><span class="line">&#123; <span class="string">playid =&gt;</span> <span class="string">&#x27;3&#x27;</span>, <span class="string">playname =&gt;</span> <span class="string">&#x27;with&#x27;</span> &#125;,</span><br><span class="line">&#123; <span class="string">playid =&gt;</span> <span class="string">&#x27;4&#x27;</span>, <span class="string">playname =&gt;</span> <span class="string">&#x27;PostgreSQL&#x27;</span> &#125;,</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>然后需要在 <code>src/backend/catalog/Makefile</code> 文件的 <code>POSTGRES_BKI_DATA</code> 目标中添加 <code>pg_play.dat</code>。最后重新编译、安装并初始化数据库即可。</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ol>
<li>该方法适合于 PostgreSQL 11 以及后续版本，PostgreSQL 10 及之前的版本可能存在略微差异，但大致相同。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 优化 setitimer 系统调用</title>
    <url>/2020/08/postgresql-optimize-setitimer-system-calls/</url>
    <content><![CDATA[<p>当我们在使用 PostgreSQL 数据库并启用 <code>statement_timeout</code> 时，可以看到 <code>setitimer()</code> 函数的调用次数明显偏多。本文分析了 <a href="https://www.postgresql.org/message-id/CA%2BhUKG%2Bo6pbuHBJSGnud%3DTadsuXySWA7CCcPgCt2QE9F6_4iHQ%40mail.gmail.com">Thomas Munro 给出的关于 <code>setitimer()</code> 函数的优化</a>。</p>
<a id="more"></a>

<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>为了方便分析，我们首先需要有一个基本的基准测试。我们使用下面的命令初始化数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ initdb -D pgdata</span><br><span class="line">$ pg_ctl -l log -D pgdata start</span><br><span class="line">$ createdb testdb</span><br><span class="line">$ pgbench -i -s 10 testdb</span><br></pre></td></tr></table></figure>

<p>接着修改配置 <code>statement_timeout</code>，将其设置为 <code>10s</code>，可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ psql postgres -c &quot;ALTER SYSTEM SET statement_timeout TO &#39;10s&#39;&quot;</span><br><span class="line">$ pg_ctl -l log -D pgdata start</span><br></pre></td></tr></table></figure>

<p>接着我们使用 <code>pgbench -T60 -Mprepared -S testdb</code> 来进行测试，我们在另一个终端中通过 <code>strace</code> 来分析系统调用，可以得到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ strace -c -p 31561</span><br><span class="line">strace: Process 31561 attached</span><br><span class="line">% time     seconds  usecs&#x2F;call     calls    errors syscall</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"> 41.11    0.334739           1    424545           sendto</span><br><span class="line"> 26.54    0.216100           1    424449           recvfrom</span><br><span class="line"> 24.33    0.198094           0    424448           setitimer</span><br><span class="line">  8.02    0.065268           1     71339           pread64</span><br><span class="line">  0.00    0.000000           0         1           epoll_ctl</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line">100.00    0.814201               1344782           total</span><br></pre></td></tr></table></figure>

<p>从结果可以看到，整个测试过程中 <code>setitimer()</code> 系统调用调用了 424448 次。</p>
<h2 id="补丁测试"><a href="#补丁测试" class="headerlink" title="补丁测试"></a>补丁测试</h2><p>接下来，我们将 patch 应用到 PostgreSQL 中，重新编译，并进行测试，其结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ strace -c -p 1375</span><br><span class="line">% time     seconds  usecs&#x2F;call     calls    errors syscall</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"> 54.16    0.351467           1    520065           sendto</span><br><span class="line"> 35.17    0.228279           0    519963           recvfrom</span><br><span class="line"> 10.67    0.069251           1     88036           pread64</span><br><span class="line">  0.00    0.000001           0         6           rt_sigreturn</span><br><span class="line">  0.00    0.000000           0         5           setitimer</span><br><span class="line">  0.00    0.000000           0         1           epoll_ctl</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line">100.00    0.648998               1128076           total</span><br></pre></td></tr></table></figure>

<p>从结果可以看到，此时的 <code>setitimer()</code> 系统调用仅调用了 5 次，远比之前的次数低。从最终的统计结果来看，应用了补丁程序的 PostgreSQL 整个测试过程中的系统调用比原有的系统调用降低了约 16%。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这个补丁程序的思路其实非常简单，实现起来也不复杂，整个 diff 文件不足 100 行。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">diff --git a/src/backend/utils/misc/timeout.c b/src/backend/utils/misc/timeout.c</span><br><span class="line">index f1c9518b0c..b5027815db 100644</span><br><span class="line"><span class="comment">--- a/src/backend/utils/misc/timeout.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/misc/timeout.c</span></span><br><span class="line">@@ -51,6 +51,13 @@ static bool all_timeouts_initialized = false;</span><br><span class="line"> static volatile int num_active_timeouts = 0;</span><br><span class="line"> static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];</span><br><span class="line"></span><br><span class="line"><span class="addition">+/*</span></span><br><span class="line"><span class="addition">+ * State used to avoid installing a new timer interrupt when the previous one</span></span><br><span class="line"><span class="addition">+ * hasn&#x27;t fired yet, but isn&#x27;t too late.</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"><span class="addition">+static TimestampTz sigalrm_due_at = PG_INT64_MAX;</span></span><br><span class="line"><span class="addition">+static volatile sig_atomic_t sigalrm_delivered = false;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> /*</span><br><span class="line">  * Flag controlling whether the signal handler is allowed to do anything.</span><br><span class="line">  * We leave this &quot;false&quot; when we&#x27;re not expecting interrupts, just in case.</span><br><span class="line">@@ -195,12 +202,13 @@ schedule_alarm(TimestampTz now)</span><br><span class="line"> 		struct itimerval timeval;</span><br><span class="line"> 		long		secs;</span><br><span class="line"> 		int			usecs;</span><br><span class="line"><span class="addition">+		TimestampTz	nearest_timeout;</span></span><br><span class="line"></span><br><span class="line"> 		MemSet(&amp;timeval, 0, sizeof(struct itimerval));</span><br><span class="line"></span><br><span class="line"> 		/* Get the time remaining till the nearest pending timeout */</span><br><span class="line"><span class="deletion">-		TimestampDifference(now, active_timeouts[0]-&gt;fin_time,</span></span><br><span class="line"><span class="deletion">-							&amp;secs, &amp;usecs);</span></span><br><span class="line"><span class="addition">+		nearest_timeout = active_timeouts[0]-&gt;fin_time;</span></span><br><span class="line"><span class="addition">+		TimestampDifference(now, nearest_timeout, &amp;secs, &amp;usecs);</span></span><br><span class="line"></span><br><span class="line"> 		/*</span><br><span class="line"> 		 * It&#x27;s possible that the difference is less than a microsecond;</span><br><span class="line">@@ -244,9 +252,18 @@ schedule_alarm(TimestampTz now)</span><br><span class="line"> 		 */</span><br><span class="line"> 		enable_alarm();</span><br><span class="line"></span><br><span class="line"><span class="addition">+		/*</span></span><br><span class="line"><span class="addition">+		 * Try to avoid having to set the interval timer, if we already know</span></span><br><span class="line"><span class="addition">+		 * that there is an undelivered signal due at the same time or sooner.</span></span><br><span class="line"><span class="addition">+		 */</span></span><br><span class="line"><span class="addition">+		if (nearest_timeout &gt;= sigalrm_due_at &amp;&amp; !sigalrm_delivered)</span></span><br><span class="line"><span class="addition">+			return;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 		/* Set the alarm timer */</span><br><span class="line"> 		if (setitimer(ITIMER_REAL, &amp;timeval, NULL) != 0)</span><br><span class="line"> 			elog(FATAL, &quot;could not enable SIGALRM timer: %m&quot;);</span><br><span class="line"><span class="addition">+		sigalrm_due_at = nearest_timeout;</span></span><br><span class="line"><span class="addition">+		sigalrm_delivered = false;</span></span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">@@ -266,6 +283,8 @@ handle_sig_alarm(SIGNAL_ARGS)</span><br><span class="line"> &#123;</span><br><span class="line"> 	int			save_errno = errno;</span><br><span class="line"></span><br><span class="line"><span class="addition">+	sigalrm_delivered = true;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	/*</span><br><span class="line"> 	 * Bump the holdoff counter, to make sure nothing we call will process</span><br><span class="line"> 	 * interrupts directly. No timeout handler should do that, but these</span><br><span class="line">@@ -591,8 +610,9 @@ disable_timeouts(const DisableTimeoutParams *timeouts, int count)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line"><span class="deletion">- * Disable SIGALRM and remove all timeouts from the active list,</span></span><br><span class="line"><span class="deletion">- * and optionally reset their timeout indicators.</span></span><br><span class="line"><span class="addition">+ * Remove all timeouts from the active list, and optionally reset their timeout</span></span><br><span class="line"><span class="addition">+ * indicators.  Leave any existing itimer installed, because it may allow us to</span></span><br><span class="line"><span class="addition">+ * avoid having to set it again soon.</span></span><br><span class="line">  */</span><br><span class="line"> void</span><br><span class="line"> disable_all_timeouts(bool keep_indicators)</span><br><span class="line">@@ -601,20 +621,6 @@ disable_all_timeouts(bool keep_indicators)</span><br><span class="line"></span><br><span class="line"> 	disable_alarm();</span><br><span class="line"></span><br><span class="line"><span class="deletion">-	/*</span></span><br><span class="line"><span class="deletion">-	 * Only bother to reset the timer if we think it&#x27;s active.  We could just</span></span><br><span class="line"><span class="deletion">-	 * let the interrupt happen anyway, but it&#x27;s probably a bit cheaper to do</span></span><br><span class="line"><span class="deletion">-	 * setitimer() than to let the useless interrupt happen.</span></span><br><span class="line"><span class="deletion">-	 */</span></span><br><span class="line"><span class="deletion">-	if (num_active_timeouts &gt; 0)</span></span><br><span class="line"><span class="deletion">-	&#123;</span></span><br><span class="line"><span class="deletion">-		struct itimerval timeval;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-		MemSet(&amp;timeval, 0, sizeof(struct itimerval));</span></span><br><span class="line"><span class="deletion">-		if (setitimer(ITIMER_REAL, &amp;timeval, NULL) != 0)</span></span><br><span class="line"><span class="deletion">-			elog(FATAL, &quot;could not disable SIGALRM timer: %m&quot;);</span></span><br><span class="line"><span class="deletion">-	&#125;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"> 	num_active_timeouts = 0;</span><br><span class="line"></span><br><span class="line"> 	for (i = 0; i &lt; MAX_TIMEOUTS; i++)</span><br></pre></td></tr></table></figure>

<p>其基本思想是通过 alarm 来取代频繁地调用 <code>setitimer()</code> 函数，而不是针对每个 timeout 都去调用 <code>setitimer()</code> 函数，这真的是将性能挖掘到了极限啊！</p>
<p>变量 <code>sigalrm_due_at</code> 记录了最近一个定时器的到期时间，<code>sigalrm_delivered</code> 则记录是否已经触发了 sigalrm 信号。当最近的定时器的超时时间大于或等于 <code>sigalrm_due_at</code> 并且不存在没有交付的定时器时，它将不会对其调用 <code>setitimer()</code> 来设置定时器。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 行级安全策略的使用</title>
    <url>/2019/07/postgresql-row-level-security-policy/</url>
    <content><![CDATA[<p>今天朋友咨询了下面一个问题：</p>
<blockquote>
<p>一个信息系统中包含全省的数据，但是各个市州可以访问自己的数据，而不能访问其他市州的数据。<br>例如，四川省下辖的成都市、绵阳市等有自己的数据，它们可以使用自己的用户登陆并更新自己的数据，<br>而不能修改其他市的数据（不可见）；而四川省级别的用户则对下辖的所有市的数据均可见。</p>
</blockquote>
<p>在我初看这个问题时，PostgreSQL 的行级安全策略 (Row Security Policy) 浮现在我的脑海中。PostgreSQL 的行级安全策略可以基于每个用户限制正常查询可以返回哪些行，或者由数据修改命令插入，更新或删除哪些行。默认情况下，PostgreSQL 中的表是不具备任何策略的。</p>
<a id="more"></a>

<h2 id="启用行级安全策略"><a href="#启用行级安全策略" class="headerlink" title="启用行级安全策略"></a>启用行级安全策略</h2><p>基于上述问题，假设我们有如下的表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> city_info (city <span class="built_in">text</span>, people <span class="built_in">int</span>);</span><br></pre></td></tr></table></figure>

<p>默认情况下是没有启用行级安全策略，我们可以使用如下命令在该表上启用该特性：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> city_info <span class="keyword">ENABLE</span> <span class="keyword">ROW</span> <span class="keyword">LEVEL</span> <span class="keyword">SECURITY</span>;</span><br></pre></td></tr></table></figure>

<p>为了测试，我们先创建三个用户，它们分别为 <code>admin</code>, <code>chengdu</code> 以及 <code>mianyang</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE ROLE admin WITH LOGIN;</span><br><span class="line">CREATE ROLE chengdu WITH LOGIN;</span><br><span class="line">CREATE ROLE mianyang WITH LOGIN;</span><br><span class="line">ALTER TABLE city_info OWNER TO admin;</span><br></pre></td></tr></table></figure>

<p>接着，我们插入两条测试数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> city_info <span class="keyword">VALUES</span> (<span class="string">&#x27;chengdu&#x27;</span>, <span class="number">100</span>), (<span class="string">&#x27;mianyang&#x27;</span>, <span class="number">80</span>);</span><br></pre></td></tr></table></figure>

<h2 id="创建策略"><a href="#创建策略" class="headerlink" title="创建策略"></a>创建策略</h2><p>现在，我们为其创建策略使得相应的市只能访问其对应的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">POLICY</span> city_policy <span class="keyword">ON</span> city_info <span class="keyword">USING</span> (city = <span class="keyword">current_user</span>);</span><br></pre></td></tr></table></figure>

<p>在创建好策略之后，我们使用 <code>chengdu</code> 用户登陆并查询数据时出现如下提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR:  permission denied for relation city_info</span><br></pre></td></tr></table></figure>

<p>这是由于我们还没有对用户授权。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> city_info <span class="keyword">TO</span> chengdu;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> city_info <span class="keyword">TO</span> mianyang;</span><br></pre></td></tr></table></figure>

<h2 id="验证方案"><a href="#验证方案" class="headerlink" title="验证方案"></a>验证方案</h2><p>在授权完成之后，我们就可以查询数据了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ psql -U chengdu postgres</span><br><span class="line">psql (10.4)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres&#x3D;&gt; select * from city_info ;</span><br><span class="line">  city   | people</span><br><span class="line">---------+--------</span><br><span class="line"> chengdu |    100</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>而我们使用 <code>admin</code> 用户登陆则可以查询所有数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ psql -U admin postgres</span><br><span class="line">psql (10.4)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres&#x3D;&gt; select * from city_info ;</span><br><span class="line">   city   | people</span><br><span class="line">----------+--------</span><br><span class="line"> chengdu  |    100</span><br><span class="line"> mianyang |     80</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>当我们尝试使用 <code>mianyang</code> 用户去修改数据时只能修改其可见的数据；而原本属于 <code>chengdu</code> 用户的数据是不会被修改的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ psql -U mianyang postgres</span><br><span class="line">psql (10.4)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres&#x3D;&gt; select * from city_info ;</span><br><span class="line">   city   | people</span><br><span class="line">----------+--------</span><br><span class="line"> mianyang |     80</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;&gt; update city_info set people &#x3D; 90;</span><br><span class="line">UPDATE 1</span><br><span class="line">postgres&#x3D;&gt; select * from city_info ;</span><br><span class="line">   city   | people</span><br><span class="line">----------+--------</span><br><span class="line"> mianyang |     90</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.postgresql.org/docs/10/ddl-rowsecurity.html">https://www.postgresql.org/docs/10/ddl-rowsecurity.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 常用命令集合</title>
    <url>/2018/12/postgresql-skills/</url>
    <content><![CDATA[<p>本文主要收集日常工作中经常使用的 PostgreSQL 相关的命令；其中，主要包含相关的系统函数、使用技巧等。本文将持续更新！！！</p>
<p><strong>备注：</strong> 主要基于 PostgreSQL 10 及其后续版本。</p>
<a id="more"></a>

<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul>
<li><p>查看数据库大小</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT pg_database_size(&#39;table_name&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看数据表大小</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT pg_relation_size(&#39;table_name&#39;);</span><br></pre></td></tr></table></figure></li>
<li><p>查看数据表大小</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT pg_table_size(&#39;table_name&#39;);</span><br></pre></td></tr></table></figure>

<p>  <strong>注意：</strong> <code>pg_relation_size</code> 与 <code>pg_table_size</code> 的区别在于 <code>pg_table_size</code> 将获取数据表的 TOAST 表、空闲空间映射表 (FSM) 和可见性表 (但不包括索引表) 的大小；而 <code>pg_relation_size</code> 可以跟一个 fork 类型的参数 (可取的值为 main, fsm, vm, init) 来获取关系表的部分数据大小，默认为 main 类型，此外 <code>pg_relation_size</code> 也可以用于获取索引表的大小。</p>
</li>
<li><p>获取数据表大小 (包括索引和 TOAST 表)</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT pg_total_relation_size(&#39;table_name&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将数据转为易于人们阅读的格式</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT pg_size_pretty(pg_relation_size(&#39;table_name&#39;));</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看对应的表空间的路径</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT pg_tablespace_location(oid);</span><br></pre></td></tr></table></figure>

<p>  其中，<code>oid</code> 为表空间的对象 ID。我们可以通过 <code>SELECT oid FROM pg_tablespace;</code> 来查询获得。</p>
</li>
<li><p>查看表对应的文件路径</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT pg_relation_filepath(oid);</span><br></pre></td></tr></table></figure></li>
<li><p>获取当前事务 ID 编号</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT txid_current();</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前 WAL 日志的写入位置</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT pg_current_wal_lsn();          -- version 10 or later</span><br><span class="line">SELECT pg_current_xlog_location();    -- before version 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前 WAL 日志的插入位置</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT pg_current_wal_insert_lsn();          -- version 10 or later</span><br><span class="line">SELECT pg_current_xlog_insert_location();    -- before version 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取日志所在的 WAL 日志文件</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT pg_walfile_name(lsn);     -- version 10 or later</span><br><span class="line">SELECT pg_xlogfile_name(lsn);    -- before version 10</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li><p><code>max_wal_size (integer)</code></p>
<p>  该参数指定 WAL 日志做 CHECKPOINT 时的最大的 WAL 日志大小。该参数不是强制性的限制，在某些特殊情况下可能会超过该值，例如 <code>archive_command</code> 命令失败或者过高的 <code>wal_keep_segments</code>。若该参数设置过高会影响系统崩溃时的恢复时间。</p>
</li>
<li><p><code>min_wal_size (integer)</code></p>
<p>  主要 WAL 日志的磁盘使用率低于此设置，那么旧的 WAL 日志文件将被回收用于后续的 CHECKPOINT 使用。它可以确保有足够的磁盘空间来存放 WAL 日志记录。</p>
</li>
<li><p><code>checkpoint_completion_target (floating point)</code></p>
<p>  该参数指定 CHECKPOINT 完成的目标，作为 CHECKPOINT 之间的总时间的一部分。该参数可以用于缓解两个 CHECKPOINT 之间的 I/O 负载。</p>
</li>
</ul>
<h3 id="psql-使用"><a href="#psql-使用" class="headerlink" title="psql 使用"></a>psql 使用</h3><ul>
<li><p>查看 <code>\d</code> 以及其他反斜杠命令对应的 SQL 语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ psql -E</span><br><span class="line">-----------------------------</span><br><span class="line">postgres&#x3D;# \set ECHO_HIDDEN on</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><ul>
<li><p>oid2name</p>
<p>  该工具可以方便的查看数据库对象与 OID 的关系。我们可以通过如下方式查看数据库的 OID。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> oid2name</span></span><br><span class="line">All databases:</span><br><span class="line">    Oid  Database Name  Tablespace</span><br><span class="line">----------------------------------</span><br><span class="line">  12405       postgres  pg_default</span><br><span class="line">  12404      template0  pg_default</span><br><span class="line">      1      template1  pg_default</span><br></pre></td></tr></table></figure>

<p>  此外，我们也可以通过该命令查看表的 filenode。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> oid2name -d postgres -t foo</span></span><br><span class="line">From database &quot;postgres&quot;:</span><br><span class="line">  Filenode  Table Name</span><br><span class="line">----------------------</span><br><span class="line">     16466         foo</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li><p>查询数据库事务提交率</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> xact_commit::<span class="built_in">float</span> / (xact_commit + xact_rollback) <span class="keyword">AS</span> xact_commit_rate</span><br><span class="line"><span class="keyword">FROM</span> pg_stat_database <span class="keyword">WHERE</span> datname = <span class="string">&#x27;postgres&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询数据库缓存命中率</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> blks_hit::<span class="built_in">float</span> / (blks_hit + blks_read) <span class="keyword">AS</span> blks_hit_rate</span><br><span class="line"><span class="keyword">FROM</span> pg_stat_database <span class="keyword">WHERE</span> datname = <span class="string">&#x27;postgres&#x27;</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.postgresql.org/docs/current/functions-admin.html">https://www.postgresql.org/docs/current/functions-admin.html</a><br>[2] <a href="https://www.postgresql.org/docs/current/app-psql.html">https://www.postgresql.org/docs/current/app-psql.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 12 流复制配置</title>
    <url>/2020/02/postgresql-stream-replication/</url>
    <content><![CDATA[<p>PostgreSQL 12 的流复制与之前的版本有所不同，主要有以下几点区别：</p>
<ol>
<li>PG12 将原有的属于 <code>recovery.conf</code> 配置文件中配置项迁移到了 <code>postgresql.conf</code> 文件中，在新系统中如果存在 <code>recovery.conf</code> 文件，数据库将无法启动；</li>
<li>文件 <code>recovery.signal</code> 和 <code>standby.signal</code> 用于切换数据库为非主（non-primary）模式；</li>
<li><code>trigger_file</code> 被修改为 <code>promote_trigger_file</code>，<del>并且只能在 <code>postgresql.conf</code></del> 可在配置文件或服务器命令行进行配置；</li>
<li>最后，<code>standby_mode</code> 参数被移除了。</li>
</ol>
<p>详细说明请<a href="https://www.postgresql.org/docs/12/release-12.html">移步官网</a>。本文将在 Ubuntu 18.04 LTS 下搭建 PG12 的流复制系统。</p>
<a id="more"></a>

<h2 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h2><p>我们在主节点下载 PostgreSQL 12.2 源码，并采用如下命名进行编译安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=<span class="variable">$HOME</span>/pg12.2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make -j 4 &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>

<p>随后将其拷贝到从节点。为了方便我们可以先配置环境变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$HOME</span>/pg12.2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt;END &gt; pg12.2-env.sh</span></span><br><span class="line">export PGHOME=$PWD</span><br><span class="line">export PGDATA=\$PGHOME/pgdata</span><br><span class="line">export PATH=\$PGHOME/bin:\$PATH</span><br><span class="line">export LD_LIBRARY_PATH=\$PGHOME/lib:\$LD_LIBRARY_PATH</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> pg12.2-env.sh</span></span><br></pre></td></tr></table></figure>

<p>我们接下来将在主节点 192.168.56.3 和从节点 192.168.56.101 上搭建 PostgreSQL 流复制。</p>
<h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><p>在主节点上初始化并启动数据库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> initdb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pg_ctl -l <span class="built_in">log</span> start</span></span><br></pre></td></tr></table></figure>

<h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><p>接着，我们需要修改监听地址，当修改之后需要重启。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> psql -c <span class="string">&quot;ALTER SYSTEM SET listen_addresses TO &#x27;*&#x27;&quot;</span> postgres</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pg_ctl -l <span class="built_in">log</span> restart</span></span><br></pre></td></tr></table></figure>
<p>我们可以不必在主节点上设置任何其他参数来进行简单的复制设置，因为默认设置已经适用。</p>
<p>现在，我们需要一个用户用于流复制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> psql -c <span class="string">&quot;CREATE USER replicator WITH REPLICATION ENCRYPTED PASSWORD &#x27;P@ssw0rd&#x27;&quot;</span> postgres</span></span><br></pre></td></tr></table></figure>

<p>最后，我们需要配置连接以便从节点可以连接主节点进行复制，我需要修改 <code>pg_hba.conf</code> 配置文件。如果我们允许故障切换，那么可能还需要主节点可以连接从节点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;host replication replicator 192.168.56.0/24 md5&quot;</span> &gt;&gt; <span class="variable">$PGDATA</span>/pg_hba.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> psql -c <span class="string">&quot;SELECT pg_reload_conf()&quot;</span> postgres</span></span><br></pre></td></tr></table></figure>

<h2 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h2><p>现在，我们可以在从节点使用 <code>pg_basebackup</code> 来做一个主库的基础备份。当我们创建备份时可以指定 <code>-R</code> 选项在数据目录中生成特定于复制的文件和配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> <span class="variable">$HOME</span>/pg12.2/pg12.2-env.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pg_basebackup -h 192.168.56.3 -U replicator -D <span class="variable">$PGDATA</span> -R -Fp -Xs -P</span></span><br><span class="line">Password:</span><br><span class="line">23652/23652 kB (100%), 1/1 tablespace</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls <span class="variable">$PGDATA</span></span></span><br><span class="line">PG_VERSION    pg_commit_ts   pg_logical    pg_serial     pg_subtrans  pg_xact</span><br><span class="line">backup_label  pg_dynshmem    pg_multixact  pg_snapshots  pg_tblspc    postgresql.auto.conf</span><br><span class="line">base          pg_hba.conf    pg_notify     pg_stat       pg_twophase  postgresql.conf</span><br><span class="line">global        pg_ident.conf  pg_replslot   pg_stat_tmp   pg_wal       standby.signal</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat <span class="variable">$PGDATA</span>/postgresql.auto.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Do not edit this file manually!</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> It will be overwritten by the ALTER SYSTEM <span class="built_in">command</span>.</span></span><br><span class="line">listen_addresses = &#x27;*&#x27;</span><br><span class="line">primary_conninfo = &#x27;user=replicator password=&#x27;&#x27;P@ssw0rd&#x27;&#x27; host=192.168.56.3 port=5432 sslmode=disable sslcompression=0 gssencmode=disable krbsrvname=postgres target_session_attrs=any&#x27;</span><br></pre></td></tr></table></figure>

<p>从下面我们可以看到，备库有一个名为 <code>standby.signal</code> 的文件，该文件没有任何内容，它仅仅是用于 PostgreSQL 确定其状态。如果该文件不存在，我们应该在备库上创建该文件。</p>
<p>此外，我们还需要注意到 <code>postgresql.auto.conf</code> 文件中的 <code>primary_conninfo</code> 参数，该参数在 PG12 之前是存放在 <code>recovery.conf</code> 文件中，并且还有一个参数 <code>standby_mode = on</code>。</p>
<h2 id="启动备库"><a href="#启动备库" class="headerlink" title="启动备库"></a>启动备库</h2><p>现在我们使用下面的命令启动备库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pg_ctl -l <span class="built_in">log</span> start</span></span><br></pre></td></tr></table></figure>

<p>我们可以在主库上查看流复制相关信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# \x</span><br><span class="line">Expanded display is on.</span><br><span class="line">postgres&#x3D;# select * from pg_stat_replication ;</span><br><span class="line">-[ RECORD 1 ]----+------------------------------</span><br><span class="line">pid              | 31970</span><br><span class="line">usesysid         | 16385</span><br><span class="line">usename          | replicator</span><br><span class="line">application_name | walreceiver</span><br><span class="line">client_addr      | 192.168.56.101</span><br><span class="line">client_hostname  |</span><br><span class="line">client_port      | 60384</span><br><span class="line">backend_start    | 2020-02-19 23:07:21.410168+08</span><br><span class="line">backend_xmin     |</span><br><span class="line">state            | streaming</span><br><span class="line">sent_lsn         | 0&#x2F;3000148</span><br><span class="line">write_lsn        | 0&#x2F;3000148</span><br><span class="line">flush_lsn        | 0&#x2F;3000148</span><br><span class="line">replay_lsn       | 0&#x2F;3000148</span><br><span class="line">write_lag        |</span><br><span class="line">flush_lag        |</span><br><span class="line">replay_lag       |</span><br><span class="line">sync_priority    | 0</span><br><span class="line">sync_state       | async</span><br><span class="line">reply_time       | 2020-02-19 23:07:31.644624+08</span><br></pre></td></tr></table></figure>

<p>我们可以看到，默认情况下 PG 采用异步复制。</p>
<h2 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h2><p>我们接下来可以修改 <code>synchronous_standby_names</code> 从而使从节点由异步节点改变为同步节点。首先我们在主节点上做如下改变：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ psql -c &quot;ALTER SYSTEM SET synchronous_standby_names TO &#39;standby&#39;&quot; postgres</span><br><span class="line">$ psql -c &quot;SELECT pg_reload_conf()&quot; postgres</span><br></pre></td></tr></table></figure>

<p>接着，在从节点修改 <code>primary_conninfo</code> 参数，并在其中加入 <code>application_name=standby</code>，并重启，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat $PGDATA&#x2F;postgresql.auto.conf</span><br><span class="line"># Do not edit this file manually!</span><br><span class="line"># It will be overwritten by the ALTER SYSTEM command.</span><br><span class="line">listen_addresses &#x3D; &#39;*&#39;</span><br><span class="line">primary_conninfo &#x3D; &#39;user&#x3D;replicator password&#x3D;&#39;&#39;P@ssw0rd&#39;&#39; host&#x3D;192.168.56.3 port&#x3D;5432 sslmode&#x3D;disable sslcompression&#x3D;0 gssencmode&#x3D;disable krbsrvname&#x3D;postgres target_session_attrs&#x3D;any application_name&#x3D;standby&#39;</span><br><span class="line"></span><br><span class="line">$ pg_ctl -l log restart</span><br></pre></td></tr></table></figure>

<p>接下来我们可以在主节点进行验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# select * from pg_stat_replication ;</span><br><span class="line">-[ RECORD 1 ]----+------------------------------</span><br><span class="line">pid              | 32052</span><br><span class="line">usesysid         | 16385</span><br><span class="line">usename          | replicator</span><br><span class="line">application_name | standby</span><br><span class="line">client_addr      | 192.168.56.101</span><br><span class="line">client_hostname  |</span><br><span class="line">client_port      | 60386</span><br><span class="line">backend_start    | 2020-02-19 23:18:30.358057+08</span><br><span class="line">backend_xmin     |</span><br><span class="line">state            | streaming</span><br><span class="line">sent_lsn         | 0&#x2F;3025410</span><br><span class="line">write_lsn        | 0&#x2F;3025410</span><br><span class="line">flush_lsn        | 0&#x2F;3025410</span><br><span class="line">replay_lsn       | 0&#x2F;3025410</span><br><span class="line">write_lag        | 00:00:00.001529</span><br><span class="line">flush_lag        | 00:00:00.001529</span><br><span class="line">replay_lag       | 00:00:00.001529</span><br><span class="line">sync_priority    | 1</span><br><span class="line">sync_state       | sync</span><br><span class="line">reply_time       | 2020-02-19 23:18:30.480227+08</span><br></pre></td></tr></table></figure>

<h2 id="提升从节点"><a href="#提升从节点" class="headerlink" title="提升从节点"></a>提升从节点</h2><p>当主节点掉线时，我们可能希望将从节点提升为主节点，此时，我们需要使用到 <code>promote_trigger_file</code> 参数。</p>
<p>首先，我们在主节点和从节点看看它们各自的状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ postgres&#x3D;# select pg_is_in_recovery();  -- 主节点</span><br><span class="line"> pg_is_in_recovery</span><br><span class="line">-------------------</span><br><span class="line"> f</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# select pg_is_in_recovery();    -- 从节点</span><br><span class="line"> pg_is_in_recovery</span><br><span class="line">-------------------</span><br><span class="line"> t</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>接着，我们在从节点的 <code>postgresql.conf</code> 文件中加入 <code>promote_trigger_file=/tmp/.tfile</code> 配置，这是，当主节点掉线时，我们在从节点创建 <code>/tmp/.tfile</code> 文件，那么从节点将自动提升为主。</p>
<p>如果我们在主节点没有掉线的情况下，创建了 <code>/tmp/.tfile</code> 这个触发文件，那么此时从节点将创建一个新的时间线，从而导致主从不一致。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/12/release-12.html">https://www.postgresql.org/docs/12/release-12.html</a><br>[2] <a href="https://www.postgresql.org/docs/12/runtime-config-replication.html#GUC-PROMOTE-TRIGGER-FILE">https://www.postgresql.org/docs/12/runtime-config-replication.html#GUC-PROMOTE-TRIGGER-FILE</a><br>[3] <a href="https://www.percona.com/blog/2019/10/11/how-to-set-up-streaming-replication-in-postgresql-12/">https://www.percona.com/blog/2019/10/11/how-to-set-up-streaming-replication-in-postgresql-12/</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 系统属性添加</title>
    <url>/2019/08/postgresql-system-attribute/</url>
    <content><![CDATA[<p>PostgreSQL 在插入数据的时候除了维护用户的属性列外，还有几个隐藏的系统属性列，如 <code>ctid</code>、<code>xmin</code> 和 <code>xmax</code> 等。如下图所示：</p>
<img src="/2019/08/postgresql-system-attribute/sysattr.png" class="" title="PostgreSQL 系统属性">

<p>从上图中我们可以看到，系统属性列其编号（即 <code>attnum</code> ）为负数，而用户自定义的属性列其编号则为正数（由 1 开始）。本文将介绍如何在 PostgreSQL 中添加自定义系统属性。</p>
<a id="more"></a>

<h2 id="属性列"><a href="#属性列" class="headerlink" title="属性列"></a>属性列</h2><p>PostgreSQL 为每个属性列都在系统表 <code>pg_attribute</code> 中记录了一个元组，<a href="https://www.postgresql.org/docs/12/catalog-pg-attribute.html">见官网文档</a>。这里我们需要对几个常见的列有所认识，这也是本文后续要使用到的。</p>
<style>
table th:nth-of-type(1) {
    width: 15%;
}
table th:nth-of-type(2) {
    width: 80%;
}
</style>

<table>
<thead>
<tr>
<th>属性列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>attname</strong></td>
<td>属性列的名称。</td>
</tr>
<tr>
<td><strong>atttypid</strong></td>
<td>属性列的数据类型的 OID，引用 <code>pg_type</code> 表的 <code>oid</code> 字段（外键约束）。</td>
</tr>
<tr>
<td><strong>attlen</strong></td>
<td>此属性列的数据类型长度，<code>pg_type</code> 表的 <code>typlen</code> 字段的副本。</td>
</tr>
<tr>
<td><strong>attnum</strong></td>
<td>属性列编号数。用户定义的普通属性列的编号从 1 开始。系统属性列列（例如 <code>ctid</code>）则为负数。</td>
</tr>
<tr>
<td><strong>attcacheoff</strong></td>
<td>存储中始终为 -1，但是当加载到内存中的行描述符时，可能会更新该行描述符以缓存行中属性的偏移量。</td>
</tr>
<tr>
<td><strong>atttypmod</strong></td>
<td>记录在创建表时提供的特定于类型的数据（例如，<code>varchar</code> 类型的最大长度）。它被传递给特定类型的输入函数和长度强制函数。对于不需要 <code>atttypmod</code> 的类型，该值通常为 -1。</td>
</tr>
<tr>
<td><strong>attbyval</strong></td>
<td>数据类型是否按值传递，<code>pg_type</code> 表的 <code>typbyval</code> 字段的副本。</td>
</tr>
<tr>
<td><strong>attstorage</strong></td>
<td>通常是此列类型的 <code>pg_type</code> 表的 <code>typstorage</code> 字段的副本。对于 TOAST-able 数据类型，可以在创建列后更改此值以控制存储策略。</td>
</tr>
<tr>
<td><strong>attalign</strong></td>
<td>数据类型的对其方式，<code>pg_type</code> 表的 <code>typalign</code> 的副本。<br/><code>c</code> 表示按照 <code>char</code> 类型对齐（即不需要对齐）；<code>s</code> 按 <code>short</code> 类型对齐（在大多数机器上是 2 字节对齐）；<code>i</code> 表示按照 <code>int</code> 类型对齐（通常是 4 字节对齐）；<code>d</code> 表示按照 <code>double</code> 类型对齐（通常是 8 字节对齐，但并不全是）。</td>
</tr>
<tr>
<td><strong>attnotnull</strong></td>
<td>该属性列是否具有非空约束。</td>
</tr>
<tr>
<td><strong>attislocal</strong></td>
<td>该属性列在表中是本地定义。请注意，属性列可以是本地定义并同时继承。</td>
</tr>
</tbody></table>
<p>其实整个属性列都是通过 <code>FormData_pg_attribute</code> 结果来记录的，它定义在 <code>src/include/catalog/pg_attribute.h</code> 头文件中。</p>
<h2 id="系统属性"><a href="#系统属性" class="headerlink" title="系统属性"></a>系统属性</h2><p>PostgreSQL 的系统属性是在 <code>src/backend/catalog/heap.c</code> 源文件中定义的，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FormData_pg_attribute a1 = &#123;</span><br><span class="line">    .attname = &#123;<span class="string">&quot;ctid&quot;</span>&#125;,</span><br><span class="line">    .atttypid = TIDOID,</span><br><span class="line">    .attlen = <span class="keyword">sizeof</span>(ItemPointerData),</span><br><span class="line">    .attnum = SelfItemPointerAttributeNumber,</span><br><span class="line">    .attcacheoff = <span class="number">-1</span>,</span><br><span class="line">    .atttypmod = <span class="number">-1</span>,</span><br><span class="line">    .attbyval = <span class="literal">false</span>,</span><br><span class="line">    .attstorage = <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">    .attalign = <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">    .attnotnull = <span class="literal">true</span>,</span><br><span class="line">    .attislocal = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FormData_pg_attribute a2 = &#123;</span><br><span class="line">    .attname = &#123;<span class="string">&quot;xmin&quot;</span>&#125;,</span><br><span class="line">    .atttypid = XIDOID,</span><br><span class="line">    .attlen = <span class="keyword">sizeof</span>(TransactionId),</span><br><span class="line">    .attnum = MinTransactionIdAttributeNumber,</span><br><span class="line">    .attcacheoff = <span class="number">-1</span>,</span><br><span class="line">    .atttypmod = <span class="number">-1</span>,</span><br><span class="line">    .attbyval = <span class="literal">true</span>,</span><br><span class="line">    .attstorage = <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">    .attalign = <span class="string">&#x27;i&#x27;</span>,</span><br><span class="line">    .attnotnull = <span class="literal">true</span>,</span><br><span class="line">    .attislocal = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FormData_pg_attribute a6 = &#123;</span><br><span class="line">    .attname = &#123;<span class="string">&quot;tableoid&quot;</span>&#125;,</span><br><span class="line">    .atttypid = OIDOID,</span><br><span class="line">    .attlen = <span class="keyword">sizeof</span>(Oid),</span><br><span class="line">    .attnum = TableOidAttributeNumber,</span><br><span class="line">    .attcacheoff = <span class="number">-1</span>,</span><br><span class="line">    .atttypmod = <span class="number">-1</span>,</span><br><span class="line">    .attbyval = <span class="literal">true</span>,</span><br><span class="line">    .attstorage = <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">    .attalign = <span class="string">&#x27;i&#x27;</span>,</span><br><span class="line">    .attnotnull = <span class="literal">true</span>,</span><br><span class="line">    .attislocal = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FormData_pg_attribute *SysAtt[] = &#123;&amp;a1, &amp;a2, &amp;a3, &amp;a4, &amp;a5, &amp;a6&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，属性列的编号是通过宏来定义的，例如 <code>TableOidAttributenumber</code>，这些宏的定义在 <code>src/include/access/sysattr.h</code> 头文件中定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attribute numbers for the system-defined attributes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SelfItemPointerAttributeNumber                  (-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MinTransactionIdAttributeNumber                 (-2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MinCommandIdAttributeNumber                     (-3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxTransactionIdAttributeNumber                 (-4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxCommandIdAttributeNumber                     (-5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TableOidAttributeNumber                         (-6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FirstLowInvalidHeapAttributeNumber              (-7)</span></span><br></pre></td></tr></table></figure>

<p><code>atttypid</code> 则是在 <code>src/include/catalog/pg_type.dat</code> 文件中声明，并在编译时由 perl 转换为 <code>pg_type_d.h</code> 文件中的宏定义。</p>
<p>最终这些系统属性列将被保存在 <code>SysAttr</code> 全局数组中。用户在建立表时，PostgreSQL 通过 <code>AddNewAttributeTuples</code> 函数向 <code>pg_attribute</code> 插入属性列信息，随后在加入系统属性信息，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; natts; i++)</span><br><span class="line">&#123;</span><br><span class="line">    attr = TupleDescAttr(tupdesc, i);</span><br><span class="line">    <span class="comment">/* Fill in the correct relation OID */</span></span><br><span class="line">    attr-&gt;attrelid = new_rel_oid;</span><br><span class="line">    <span class="comment">/* Make sure this is OK, too */</span></span><br><span class="line">    attr-&gt;attstattarget = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    InsertPgAttributeTuple(rel, attr, indstate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add dependency info */</span></span><br><span class="line">    myself.classId = RelationRelationId;</span><br><span class="line">    myself.objectId = new_rel_oid;</span><br><span class="line">    myself.objectSubId = i + <span class="number">1</span>;</span><br><span class="line">    referenced.classId = TypeRelationId;</span><br><span class="line">    referenced.objectId = attr-&gt;atttypid;</span><br><span class="line">    referenced.objectSubId = <span class="number">0</span>;</span><br><span class="line">    recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The default collation is pinned, so don&#x27;t bother recording it */</span></span><br><span class="line">    <span class="keyword">if</span> (OidIsValid(attr-&gt;attcollation) &amp;&amp;</span><br><span class="line">        attr-&gt;attcollation != DEFAULT_COLLATION_OID)</span><br><span class="line">    &#123;</span><br><span class="line">        referenced.classId = CollationRelationId;</span><br><span class="line">        referenced.objectId = attr-&gt;attcollation;</span><br><span class="line">        referenced.objectSubId = <span class="number">0</span>;</span><br><span class="line">        recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Next we add the system attributes.  Skip OID if rel has no OIDs. Skip</span></span><br><span class="line"><span class="comment"> * all for a view or type relation.  We don&#x27;t bother with making datatype</span></span><br><span class="line"><span class="comment"> * dependencies here, since presumably all these types are pinned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (relkind != RELKIND_VIEW &amp;&amp; relkind != RELKIND_COMPOSITE_TYPE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) lengthof(SysAtt); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FormData_pg_attribute attStruct;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;attStruct, SysAtt[i], <span class="keyword">sizeof</span>(FormData_pg_attribute));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Fill in the correct relation OID in the copied tuple */</span></span><br><span class="line">        attStruct.attrelid = new_rel_oid;</span><br><span class="line"></span><br><span class="line">        InsertPgAttributeTuple(rel, &amp;attStruct, indstate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建系统属性列"><a href="#创建系统属性列" class="headerlink" title="创建系统属性列"></a>创建系统属性列</h2><p>现在，我们对系统属性列的工作方式有所了解了，接下来就可以创建自定义系统属性列。首先我们声明一个属性列的编号，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InfomaskAttributeNumber                         (-7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FirstLowInvalidHeapAttributeNumber              (-8)</span></span><br></pre></td></tr></table></figure>

<p><strong>注意；</strong> 不要忘记更新 <code>FirstLowInvalidHeapAttributeNumber</code> 的值。</p>
<p>接着，我们需要声明属性列，并将其添加到 <code>SysAtt</code> 数组中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FormData_pg_attribute a7 = &#123;</span><br><span class="line">        .attname = &#123;<span class="string">&quot;infomask&quot;</span>&#125;,</span><br><span class="line">        .atttypid = INT2OID,</span><br><span class="line">        .attlen = <span class="keyword">sizeof</span>(uint16),</span><br><span class="line">        .attnum = InfomaskAttributeNumber,</span><br><span class="line">        .attcacheoff = <span class="number">-1</span>,</span><br><span class="line">        .atttypmod = <span class="number">-1</span>,</span><br><span class="line">        .attbyval = <span class="literal">true</span>,</span><br><span class="line">        .attstorage = <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">        .attalign = <span class="string">&#x27;i&#x27;</span>,</span><br><span class="line">        .attnotnull = <span class="literal">true</span>,</span><br><span class="line">        .attislocal = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FormData_pg_attribute *SysAtt[] = &#123;&amp;a1, &amp;a2, &amp;a3, &amp;a4, &amp;a5, &amp;a6, &amp;a7&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，我们就基本完成了属性列的添加。当然，为了能够查询，我还需要在两个地方做修改，它们均位于 <code>src/backend/access/common/heaptuple.c</code> 文件中。首先在函数 <code>heap_attisnull</code> 中增加我们的属性列：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">heap_attisnull(HeapTuple tup, <span class="keyword">int</span> attnum, TupleDesc tupleDesc)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We allow a NULL tupledesc for relations not expected to have missing</span></span><br><span class="line"><span class="comment">         * values, such as catalog relations and indexes.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Assert(!tupleDesc || attnum &lt;= tupleDesc-&gt;natts);</span><br><span class="line">        <span class="keyword">if</span> (attnum &gt; (<span class="keyword">int</span>) HeapTupleHeaderGetNatts(tup-&gt;t_data))</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (tupleDesc &amp;&amp; TupleDescAttr(tupleDesc, attnum - <span class="number">1</span>)-&gt;atthasmissing)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (attnum &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (HeapTupleNoNulls(tup))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> att_isnull(attnum - <span class="number">1</span>, tup-&gt;t_data-&gt;t_bits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (attnum)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> TableOidAttributeNumber:</span><br><span class="line">                <span class="keyword">case</span> SelfItemPointerAttributeNumber:</span><br><span class="line">                <span class="keyword">case</span> MinTransactionIdAttributeNumber:</span><br><span class="line">                <span class="keyword">case</span> MinCommandIdAttributeNumber:</span><br><span class="line">                <span class="keyword">case</span> MaxTransactionIdAttributeNumber:</span><br><span class="line">                <span class="keyword">case</span> MaxCommandIdAttributeNumber:</span><br><span class="line">                <span class="keyword">case</span> InfomaskAttributeNumber:</span><br><span class="line">                        <span class="comment">/* these are never null */</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        elog(ERROR, <span class="string">&quot;invalid attnum: %d&quot;</span>, attnum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，在 <code>heap_getsysattr</code> 函数中添加如何获取 <code>infomask</code> 的值，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Datum</span><br><span class="line">heap_getsysattr(HeapTuple tup, <span class="keyword">int</span> attnum, TupleDesc tupleDesc, <span class="keyword">bool</span> *isnull)</span><br><span class="line">&#123;</span><br><span class="line">        Datum           result;</span><br><span class="line"></span><br><span class="line">        Assert(tup);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Currently, no sys attribute ever reads as NULL. */</span></span><br><span class="line">        *isnull = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (attnum)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> SelfItemPointerAttributeNumber:</span><br><span class="line">                        <span class="comment">/* pass-by-reference datatype */</span></span><br><span class="line">                        result = PointerGetDatum(&amp;(tup-&gt;t_self));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MinTransactionIdAttributeNumber:</span><br><span class="line">                        result = TransactionIdGetDatum(HeapTupleHeaderGetRawXmin(tup-&gt;t_data));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MaxTransactionIdAttributeNumber:</span><br><span class="line">                        result = TransactionIdGetDatum(HeapTupleHeaderGetRawXmax(tup-&gt;t_data));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MinCommandIdAttributeNumber:</span><br><span class="line">                <span class="keyword">case</span> MaxCommandIdAttributeNumber:</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * cmin and cmax are now both aliases for the same field, which</span></span><br><span class="line"><span class="comment">                         * can in fact also be a combo command id.  XXX perhaps we should</span></span><br><span class="line"><span class="comment">                         * return the &quot;real&quot; cmin or cmax if possible, that is if we are</span></span><br><span class="line"><span class="comment">                         * inside the originating transaction?</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        result = CommandIdGetDatum(HeapTupleHeaderGetRawCommandId(tup-&gt;t_data));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TableOidAttributeNumber:</span><br><span class="line">                        result = ObjectIdGetDatum(tup-&gt;t_tableOid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> InfomaskAttributeNumber:</span><br><span class="line">                        result = UInt16GetDatum(tup-&gt;t_data-&gt;t_infomask);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        elog(ERROR, <span class="string">&quot;invalid attnum: %d&quot;</span>, attnum);</span><br><span class="line">                        result = <span class="number">0</span>;                     <span class="comment">/* keep compiler quiet */</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，编译、初始化并启动数据库，效果如下图所示：</p>
<img src="/2019/08/postgresql-system-attribute/result.png" class="" title="效果图">


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/12/catalog-pg-attribute.html">https://www.postgresql.org/docs/12/catalog-pg-attribute.html</a><br>[2] <a href="https://www.postgresql.org/docs/12/catalog-pg-type.html">https://www.postgresql.org/docs/12/catalog-pg-type.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 自定义系统函数</title>
    <url>/2019/11/postgresql-system-function/</url>
    <content><![CDATA[<p>本文主要介绍如何实现一个系统函数，类似于 <code>pg_backend_pid()</code> 的系统函数。PostgreSQL 所有的系统函数都记录在 <code>pg_proc</code> 系统表中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# select oid,proname from pg_proc where proname &#x3D; &#39;pg_backend_pid&#39;;</span><br><span class="line"> oid  |    proname</span><br><span class="line">------+----------------</span><br><span class="line"> 2026 | pg_backend_pid</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="系统表-pg-proc"><a href="#系统表-pg-proc" class="headerlink" title="系统表 pg_proc"></a>系统表 <code>pg_proc</code></h2><p>关于系统表 <a href="https://www.postgresql.org/docs/11/catalog-pg-proc.html">pg_proc</a> 都详细介绍可以查看官方文档，这里简要介绍一些本文使用到的一些属性列。</p>
<style>
table th:nth-of-type(1) {
    width: 15%;
}
table th:nth-of-type(2) {
    width: 10%;
}
</style>

<table>
<thead>
<tr>
<th>属性列</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>oid</td>
<td>oid</td>
<td>行标识符，用于标识函数</td>
</tr>
<tr>
<td>proname</td>
<td>name</td>
<td>函数名</td>
</tr>
<tr>
<td>pronamespace</td>
<td>oid</td>
<td>包含该函数的命令空间的标识符</td>
</tr>
<tr>
<td>proowner</td>
<td>oid</td>
<td>该函数的拥有者</td>
</tr>
<tr>
<td>prorows</td>
<td>float4</td>
<td>估计的结果行数 (如果 <code>proretset</code> 为 <code>false</code> 则为零)</td>
</tr>
<tr>
<td>proretset</td>
<td>bool</td>
<td>函数返回一个集合（即指定数据类型的多个值）</td>
</tr>
<tr>
<td>provolatile</td>
<td>char</td>
<td>函数的结果是否取决于输入参数，或受外部因素影响<br><code>i</code> - 不变的函数，对于相同的输入始终有相同的输出。<br><code>s</code> - 稳定的函数，其结果（对于固定输入）在扫描中不会改变。<br> <code>v</code> - 易失的函数，其结果可能随时更改，这样做的副作用是无法优化对它们的调用。</td>
</tr>
<tr>
<td>proparallel</td>
<td>char</td>
<td>该函数是否可以在并行模式下安全运行<br><code>s</code> - 可以安全地在并行模式下不受限制地运行功能。<br><code>r</code> - 可以在并行模式下运行的函数，但是它们的执行仅限于并行组领导者，并行工作进程无法调用这些功能。<br><code>u</code> - 在并行模式下不安全的函数，此类函数的存在会强制执行串行执行计划。</td>
</tr>
<tr>
<td>pronargs</td>
<td>int2</td>
<td>输入参数的个数</td>
</tr>
<tr>
<td>pronargdefaults</td>
<td>int2</td>
<td>具有默认值的参数个数</td>
</tr>
<tr>
<td>prorettype</td>
<td>oid</td>
<td>返回值的数据类型</td>
</tr>
<tr>
<td>proargtypes</td>
<td>oidvector</td>
<td>函数参数数据类型数组，这仅包括输入函数</td>
</tr>
<tr>
<td>proallargtypes</td>
<td>oid[]</td>
<td>函数参数数据类型数组，这包含所有参数（输入、输出参数）</td>
</tr>
<tr>
<td>proargmodes</td>
<td>char[]</td>
<td>函数参数的模式数组，<code>i</code> - INPUT 参数，<code>o</code> - OUTPUT 参数，<code>b</code> - INPUT/OUTPUT 参数，<code>v</code> - VARIADIC 参数，<code>t</code> - TABLE 参数。根据实现语言/调用约定，它可能是解释语言功能的实际源代码，链接符号，文件名或几乎所有其他内容。</td>
</tr>
<tr>
<td>prosrc</td>
<td>text</td>
<td>函数处理程序如何调用函数根据实现语言/调用约定，它可能是解释语言功能的实际源代码，链接符号，文件名或几乎所有其他内容</td>
</tr>
</tbody></table>
<p>我们上面提到的 <code>pg_backend_pid</code> 函数的各个属性如下所示：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&#123; <span class="string">oid =&gt;</span> <span class="string">&#x27;2026&#x27;</span>, <span class="string">descr =&gt;</span> <span class="string">&#x27;statistics: current backend PID&#x27;</span>,</span><br><span class="line">  <span class="string">proname =&gt;</span> <span class="string">&#x27;pg_backend_pid&#x27;</span>, <span class="string">provolatile =&gt;</span> <span class="string">&#x27;s&#x27;</span>, <span class="string">proparallel =&gt;</span> <span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">  <span class="string">prorettype =&gt;</span> <span class="string">&#x27;int4&#x27;</span>, <span class="string">proargtypes =&gt;</span> <span class="string">&#x27;&#x27;</span>, <span class="string">prosrc =&gt;</span> <span class="string">&#x27;pg_backend_pid&#x27;</span> &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上述内容来自 <code>src/include/catalog/pg_proc.dat</code> 文件，该文件中定义的系统函数的相关信息，在编译时，PostgreSQL 将会使用 Perl 对其进行转换，并最终插入到 <code>pg_proc</code> 系统表中。</p>
<h2 id="PostgreSQL-函数调用约定"><a href="#PostgreSQL-函数调用约定" class="headerlink" title="PostgreSQL 函数调用约定"></a>PostgreSQL 函数调用约定</h2><p>PostgreSQL 通过函数调用约定来抑制传递参数和返回结果的复杂性。其定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Datum <span class="title">funcname</span><span class="params">(PG_FUNCTION_ARGS)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例如，<code>pg_backend_pid()</code> 函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Datum</span><br><span class="line">pg_backend_pid(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">    PG_RETURN_INT32(MyProcPid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过 <code>PG_GETARG_xxx()</code> 的宏来获取对应类型的参数；在非严格函数中，需要使用 <code>PG_ARGNULL_xxx()</code> 宏来事先检查参数是否为空；同时我们可以使用 <code>PG_RETURN_xxx()</code> 宏来返回结果。<code>PG_GETARG_xxx()</code> 接受一个数字参数，该参数表示我们需要获取那个参数，参数从零开始；<code>PG_RETURN_xxx()</code> 的参数是实际返回的值。这些宏都定义在 <code>src/include/fmgr.h</code> 文件中。</p>
<h2 id="自定义系统函数"><a href="#自定义系统函数" class="headerlink" title="自定义系统函数"></a>自定义系统函数</h2><p>现在，我们可以来实现一个自定义的系统函数。PostgreSQL 提供了一个系统函数 <code>sha256(bytea)</code> 来计算 SHA256 哈希值。在本文中，我们将新 <code>sha256(text)</code> 类型的函数来计算 SHA256 哈希值。其源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a SHA256 hash of a text value and return it as hex string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Datum</span><br><span class="line">sha256_text(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>       i, j;</span><br><span class="line">    text     *in_text = PG_GETARG_TEXT_PP(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">size_t</span>    len;</span><br><span class="line">    uint8     hexsum[PG_SHA256_DIGEST_LENGTH];</span><br><span class="line">    <span class="keyword">char</span>      digest[PG_SHA256_DIGEST_STRING_LENGTH];</span><br><span class="line">    pg_sha256_ctx    sha256_ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Calculate the length of the buffer using varlena metadata */</span></span><br><span class="line">    len = VARSIZE_ANY_EXHDR(in_text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get the hash result */</span></span><br><span class="line">    pg_sha256_init(&amp;sha256_ctx);</span><br><span class="line">    pg_sha256_update(&amp;sha256_ctx, (uint8 *) VARDATA_ANY(in_text), len);</span><br><span class="line">    pg_sha256_final(&amp;sha256_ctx, hexsum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; PG_SHA256_DIGEST_LENGTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *hex = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line">        digest[j++] = hex[(hexsum[i] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xF</span>];</span><br><span class="line">        digest[j++] = hex[hexsum[i] &amp; <span class="number">0xF</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    digest[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    PG_RETURN_TEXT_P(cstring_to_text(digest));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将其定义在 <code>src/backend/utils/adt/cryptohashes.c</code> 文件中，该文件包含了常用的哈希算法。接着我们需要在 <code>src/include/catalog/pg_proc.dat</code> 文件中添加 <code>sha256_text</code> 的实现，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&#123; <span class="string">oid =&gt;</span> <span class="string">&#x27;3420&#x27;</span>, <span class="string">descr =&gt;</span> <span class="string">&#x27;SHA-256 hash&#x27;</span>,</span><br><span class="line">  <span class="string">proname =&gt;</span> <span class="string">&#x27;sha256&#x27;</span>, <span class="string">proleakproof =&gt;</span> <span class="string">&#x27;t&#x27;</span>, <span class="string">prorettype =&gt;</span> <span class="string">&#x27;bytea&#x27;</span>,</span><br><span class="line">  <span class="string">proargtypes =&gt;</span> <span class="string">&#x27;bytea&#x27;</span>, <span class="string">prosrc =&gt;</span> <span class="string">&#x27;sha256_bytea&#x27;</span> &#125;,</span><br><span class="line">&#123; <span class="string">oid =&gt;</span> <span class="string">&#x27;3423&#x27;</span>, <span class="string">descr =&gt;</span> <span class="string">&#x27;SHA256 hash&#x27;</span>,</span><br><span class="line">  <span class="string">proname =&gt;</span> <span class="string">&#x27;sha256&#x27;</span>, <span class="string">proleakproof =&gt;</span> <span class="string">&#x27;t&#x27;</span>, <span class="string">prorettype =&gt;</span> <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">  <span class="string">proargtypes =&gt;</span> <span class="string">&#x27;text&#x27;</span>, <span class="string">prosrc =&gt;</span> <span class="string">&#x27;sha256_text&#x27;</span> &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>oid</code> 是不能重复的，我们可以使用 <code>src/include/catalog/unused_oids</code> 来获取一个未使用的 <code>oid</code>。</p>
<p>经过上述步骤，我们就完整的创建了一个 PostgreSQL 系统函数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# select sha256(&#39;hello&#39;);</span><br><span class="line">                              sha256</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"> 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# postgres&#x3D;# select sha256(&#39;hello&#39;::bytea);</span><br><span class="line">                               sha256</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"> \x2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>当然，这个示例只是为了演示而做的。但是，根据这个示例，我们可以轻易的实现我们需要的系统函数。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/11/catalog-pg-proc.html">https://www.postgresql.org/docs/11/catalog-pg-proc.html</a><br>[2] <a href="https://www.postgresql.org/docs/11/xfunc-c.html">https://www.postgresql.org/docs/11/xfunc-c.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 数据库系统标识符</title>
    <url>/2020/06/postgresql-system-identifier/</url>
    <content><![CDATA[<p>我们都知道 PostgreSQL 针对每个数据库集群实例，都会有一个唯一的标识符 - __system identifier__。那么这个标识符是如何生成的呢？本文将对其进行简要的分析。</p>
<a id="more"></a>

<p>通过分析 initdb 的源码，我们并不能找到相关的信息，但是我们发现 initdb 是通过 postgres 来进行数据库相关的初始化工作的，在函数 <code>bootstrap_template1()</code> 中有如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * run the BKI script in bootstrap mode to create template1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">bootstrap_template1(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Also ensure backend isn&#x27;t confused by this environment var: */</span></span><br><span class="line">    unsetenv(<span class="string">&quot;PGCLIENTENCODING&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(cmd, <span class="keyword">sizeof</span>(cmd),</span><br><span class="line">             <span class="string">&quot;\&quot;%s\&quot; --boot -x1 -X %u %s %s %s&quot;</span>,</span><br><span class="line">             backend_exec,</span><br><span class="line">             wal_segment_size_mb * (<span class="number">1024</span> * <span class="number">1024</span>),</span><br><span class="line">             data_checksums ? <span class="string">&quot;-k&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             boot_options,</span><br><span class="line">             debug ? <span class="string">&quot;-d 5&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PG_CMD_OPEN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (line = bki_lines; *line != <span class="literal">NULL</span>; line++)</span><br><span class="line">    &#123;</span><br><span class="line">        PG_CMD_PUTS(*line);</span><br><span class="line">        <span class="built_in">free</span>(*line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PG_CMD_CLOSE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(bki_lines);</span><br><span class="line"></span><br><span class="line">    check_ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们仅使用 <code>initdb -D pgdata</code> 来初始化数据库实例，那么它实际上会调用 <code>postgres --boot -x1 -X 16777216  -F</code> 来进行初始化。</p>
<p>接下来我们对 postgres 进行分析发现，它将在 <code>BootStrapXLOG()</code> 函数中初始化数据库标识符，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">BootStrapXLOG(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    CheckPoint  checkPoint;</span><br><span class="line">    <span class="keyword">char</span>       *buffer;</span><br><span class="line">    XLogPageHeader page;</span><br><span class="line">    XLogLongPageHeader longpage;</span><br><span class="line">    XLogRecord *record;</span><br><span class="line">    <span class="keyword">char</span>       *recptr;</span><br><span class="line">    <span class="keyword">bool</span>        use_existent;</span><br><span class="line">    uint64      sysidentifier;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    pg_crc32c   crc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Select a hopefully-unique system identifier code for this installation.</span></span><br><span class="line"><span class="comment">     * We use the result of gettimeofday(), including the fractional seconds</span></span><br><span class="line"><span class="comment">     * field, as being about as unique as we can easily get.  (Think not to</span></span><br><span class="line"><span class="comment">     * use random(), since it hasn&#x27;t been seeded and there&#x27;s no portable way</span></span><br><span class="line"><span class="comment">     * to seed it other than the system clock value...)  The upper half of the</span></span><br><span class="line"><span class="comment">     * uint64 value is just the tv_sec part, while the lower half contains the</span></span><br><span class="line"><span class="comment">     * tv_usec part (which must fit in 20 bits), plus 12 bits from our current</span></span><br><span class="line"><span class="comment">     * PID for a little extra uniqueness.  A person knowing this encoding can</span></span><br><span class="line"><span class="comment">     * determine the initialization time of the installation, which could</span></span><br><span class="line"><span class="comment">     * perhaps be useful sometimes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    sysidentifier = ((uint64) tv.tv_sec) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    sysidentifier |= ((uint64) tv.tv_usec) &lt;&lt; <span class="number">12</span>;</span><br><span class="line">    sysidentifier |= getpid() &amp; <span class="number">0xFFF</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看到，PostgreSQL 通过 <code>gettimeofday()</code> 函数来获取当前的时间，随后将 <code>tv.tv_sec</code><br>作为标识符的高 32 位，将 <code>tv.tv_usec</code> 作为标识符的低 32 位中的高 20 位，最后将当前进程的 ID 作为标识符的低 12 位，从而构造一个唯一的数据库实例标识符。这样我们就可以通过下面的方式获取到实例的初始化时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# select to_timestamp(system_identifier &gt;&gt; 32) from pg_control_system();</span><br><span class="line">      to_timestamp</span><br><span class="line">------------------------</span><br><span class="line"> 2019-12-12 22:20:59+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 临时表</title>
    <url>/2019/08/postgresql-temporary-table/</url>
    <content><![CDATA[<p>本文主要介绍 PostgreSQL 数据库中的临时表 (Temporary Table)。临时表将在会话结束或者当前事务结束时被删除。PostgreSQL 支持临时表和永久存储表 (Permanent Table) 具有相同的名称，如果出现这种情况，那么只有在临时表被删除之后才能看到永久表或者你可以指定 schema 来明确需要查询的是永久表。此外，在临时表上建立的索引同样也是临时的。</p>
<a id="more"></a>

<h2 id="创建临时表"><a href="#创建临时表" class="headerlink" title="创建临时表"></a>创建临时表</h2><p>在 PostgreSQL 中，我们可以通过下面的语法来创建临时表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE temp_table_name (</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者，我们可以将 <code>TEMPORARY</code> 替换为 <code>TEMP</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TEMP TABLE temp_table_name (</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>所有的临时表只能在他所在的会话中可见。我们来看一个示列，首先创建一个 <code>test</code> 的数据库，随后在里面创建一个 <code>temp_test</code> 的临时表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# CREATE DATABASE test;</span><br><span class="line">CREATE DATABASE</span><br><span class="line">postgres&#x3D;# \c test</span><br><span class="line">You are now connected to database &quot;test&quot; as user &quot;japin&quot;.</span><br><span class="line">test&#x3D;# CREATE TEMP TABLE temp_test (id INT, name VARCHAR(10), age INT);</span><br><span class="line">CREATE TABLE</span><br><span class="line">test&#x3D;# SELECT * FROM temp_test;</span><br><span class="line"> id | name | age</span><br><span class="line">----+------+-----</span><br><span class="line">(0 rows)</span><br><span class="line"></span><br><span class="line">test&#x3D;#</span><br></pre></td></tr></table></figure>

<p>接着，我们重新开启一个会话连接到到 <code>test</code> 数据库并查询 <code>temp_test</code> 临时表中的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# \c test</span><br><span class="line">You are now connected to database &quot;test&quot; as user &quot;japin&quot;.</span><br><span class="line">test&#x3D;# SELECT * FROM temp_test;</span><br><span class="line">ERROR:  relation &quot;temp_test&quot; does not exist</span><br><span class="line">LINE 1: SELECT * FROM temp_test;</span><br><span class="line">                      ^</span><br><span class="line">test&#x3D;#</span><br></pre></td></tr></table></figure>
<p>正如你看到的，第二个会话中没有 <code>temp_test</code> 这个关系表，因此可以说明临时表只在当前会话可见。现在我们尝试断开第一个会话连接并重新连接到 <code>test</code> 数据库查看一下该临时表是否还存在。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test&#x3D;# \q</span><br><span class="line">japin@ww-it:~&#x2F;Codes&#x2F;tinydb$ psql -d test</span><br><span class="line">psql (10.4)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">test&#x3D;# SELECT * FROM temp_test;</span><br><span class="line">ERROR:  relation &quot;temp_test&quot; does not exist</span><br><span class="line">LINE 1: SELECT * FROM temp_test;</span><br><span class="line">                      ^</span><br><span class="line">test&#x3D;#</span><br></pre></td></tr></table></figure>

<p>从上面可以看到临时表 <code>temp_test</code> 以及不存在了，这说明它在会话结束之后就被数据库回收了。</p>
<h2 id="临时表表名"><a href="#临时表表名" class="headerlink" title="临时表表名"></a>临时表表名</h2><p>PostgreSQL 支持临时表与永久表具有相同的表名，虽然通常不推荐这样做，但是难免出现抽风的情况 :(。如果数据库中包含相同名字的临时表和永久表，那么执行查询时将会在临时表中取数据而不是在永久表中取数据。当然，我们通过指定 schema 来显示的指明从永久表中取数据。考虑如下情况：</p>
<p>首先，我们在 <code>test</code> 数据库中创建一个 <code>customers</code> 的永久表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test&#x3D;# CREATE TABLE customers (id INT, name VARCHAR(10), age INT);</span><br><span class="line">CREATE TABLE</span><br><span class="line">test&#x3D;# INSERT INTO customers VALUES (1, &#39;japin&#39;, 20), (2, &#39;tom&#39;, 20);</span><br><span class="line">INSERT 0 2</span><br><span class="line">test&#x3D;# SELECT * FROM customers;</span><br><span class="line"> id | name  | age</span><br><span class="line">----+-------+-----</span><br><span class="line">  1 | japin |  20</span><br><span class="line">  2 | tom   |  20</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">test&#x3D;#</span><br></pre></td></tr></table></figure>

<p>接着，我们在创建一个相同名字的临时表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test&#x3D;# CREATE TEMP TABLE customers (id INT, name VARCHAR(10), age INT);</span><br><span class="line">CREATE TABLE</span><br><span class="line">test&#x3D;# SELECT * FROM customers;</span><br><span class="line"> id | name | age</span><br><span class="line">----+------+-----</span><br><span class="line">(0 rows)</span><br><span class="line"></span><br><span class="line">test&#x3D;#</span><br></pre></td></tr></table></figure>

<p>此时，我们在从 <code>customers</code> 表中查询时便没有数据记录了，这说明临时表 <code>customers</code> 将永久表 <code>customers</code> 覆盖了。我们通过 <code>\d+</code> 命令查看数据库中的关系表，它同样不包含永久表 <code>customers</code> 的信息，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test&#x3D;# \d+</span><br><span class="line">                       List of relations</span><br><span class="line">  Schema   |   Name    | Type  | Owner |  Size   | Description</span><br><span class="line">-----------+-----------+-------+-------+---------+-------------</span><br><span class="line"> pg_temp_3 | customers | table | japin | 0 bytes |</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">test&#x3D;#</span><br></pre></td></tr></table></figure>

<p>由上述结果可知，临时表是存放在 <code>pg_temp_3</code> 的 sechma 中，而我们创建的永久表则是存放在 <code>public</code> schema 中，因此，我们可以通过指定 schema 来查看永久表 <code>customers</code> 中的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test&#x3D;# SELECT * FROM public.customers;</span><br><span class="line"> id | name  | age</span><br><span class="line">----+-------+-----</span><br><span class="line">  1 | japin |  20</span><br><span class="line">  2 | tom   |  20</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">test&#x3D;#</span><br></pre></td></tr></table></figure>

<h2 id="删除临时表"><a href="#删除临时表" class="headerlink" title="删除临时表"></a>删除临时表</h2><p>临时表的删除与永久表没有区别，它们都是通过 <code>DROP TABLE</code> 语句实现的。例如，我们要删除 <code>customers</code> 临时表可以使用如下的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE customers;</span><br></pre></td></tr></table></figure>

<p>此时，我们便可以看到永久表 <code>customers</code> 了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test&#x3D;# \d+</span><br><span class="line">                       List of relations</span><br><span class="line"> Schema |   Name    | Type  | Owner |    Size    | Description</span><br><span class="line">--------+-----------+-------+-------+------------+-------------</span><br><span class="line"> public | customers | table | japin | 8192 bytes |</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">test&#x3D;#</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/10/sql-createtable.html">https://www.postgresql.org/docs/10/sql-createtable.html</a><br>[2] <a href="http://www.postgresqltutorial.com/postgresql-temporary-table/">http://www.postgresqltutorial.com/postgresql-temporary-table/</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PyInstaller 打包 PyQt5 失败 - 执行脚本失败</title>
    <url>/2019/07/pyinstaller-package-pyqt5-error-on-Qt5Core/</url>
    <content><![CDATA[<p>最近用 Python 帮人写一个程序，主体工作完成之后，利用 PyQt 写了一个界面，通过命令行运行一切正常，然后，利用 PyInstaller 打包成一个单独的可执行文件时，问题就来了:( 。我使用打包命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyinstaller -F -w xxx.py</span><br></pre></td></tr></table></figure>

<p>运行可执行文件时，弹出的对话框显示如下信息，此外就没有别的其它信息了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;failed to execute script xxx&quot;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><table>
<thead>
<tr>
<th>类别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>Windows 10</td>
</tr>
<tr>
<td>PyQt5</td>
<td>5.13.0</td>
</tr>
<tr>
<td>Python</td>
<td>3.7.4</td>
</tr>
<tr>
<td>PyInstaller</td>
<td>3.5</td>
</tr>
</tbody></table>
<h2 id="问题追溯"><a href="#问题追溯" class="headerlink" title="问题追溯"></a>问题追溯</h2><p>但从上面的错误无法得到更多的信息，因此，我尝试使用 <code>-c</code> 的打包方式，即在程序后端运行一个终端。其打包命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyinstaller -F -c xxx.py</span><br></pre></td></tr></table></figure>

<p>这是再次运行，可以后终端中看到如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;gui.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    from PyQt5.QtCore import Qt</span><br><span class="line">  File &quot;c:\python37-32\lib\site-packages\PyInstaller\loader\pyimod03_importers.py&quot;, line 627, in exec_module</span><br><span class="line">    exec(bytecode, module.__dict__)</span><br><span class="line">  File &quot;site-packages\PyQt5\__init__.py&quot;, line 41, in &lt;module&gt;</span><br><span class="line">  File &quot;site-packages\PyQt5\__init__.py&quot;, line 33, in find_qt</span><br><span class="line">ImportError: unable to find Qt5Core.dll on PATH</span><br><span class="line">[6852] Failed to execute script gui</span><br></pre></td></tr></table></figure>

<p>此时，问题就比较明显了，程序运行时缺少 <code>Qt5Core.dll</code> 动态库。此时，我尝试把 <code>Qt5Core.dll</code> 文件拷贝到当前目录后，再次运行依然出现上述问题。</p>
<p>搜索时发现这个问题还是个普遍问题，大家都遇到了，具体参考<a href="https://github.com/pyinstaller/pyinstaller/issues/4293">这里</a>。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在 PyQt5.13 中，其 <code>__init__.py</code> 文件内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Copyright (c) 2019 Riverbank Computing Limited &lt;info@riverbankcomputing.com&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file is part of PyQt5.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file may be used under the terms of the GNU General Public License</span></span><br><span class="line"><span class="comment"># version 3.0 as published by the Free Software Foundation and appearing in</span></span><br><span class="line"><span class="comment"># the file LICENSE included in the packaging of this file.  Please review the</span></span><br><span class="line"><span class="comment"># following information to ensure the GNU General Public License version 3.0</span></span><br><span class="line"><span class="comment"># requirements will be met: http://www.gnu.org/copyleft/gpl.html.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you do not wish to use this file under the terms of the GPL version 3.0</span></span><br><span class="line"><span class="comment"># then you may purchase a commercial license.  For more information contact</span></span><br><span class="line"><span class="comment"># info@riverbankcomputing.com.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span></span><br><span class="line"><span class="comment"># WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_qt</span>():</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">    path = os.environ[<span class="string">&#x27;PATH&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    dll_dir = os.path.dirname(__file__) + <span class="string">&#x27;\\Qt\\bin&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(dll_dir + <span class="string">&#x27;\\Qt5Core.dll&#x27;</span>):</span><br><span class="line">        path = dll_dir + <span class="string">&#x27;;&#x27;</span> + path</span><br><span class="line">        os.environ[<span class="string">&#x27;PATH&#x27;</span>] = path</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> dll_dir <span class="keyword">in</span> path.split(<span class="string">&#x27;;&#x27;</span>):</span><br><span class="line">            <span class="keyword">if</span> os.path.isfile(dll_dir + <span class="string">&#x27;\\Qt5Core.dll&#x27;</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ImportError(<span class="string">&quot;unable to find Qt5Core.dll on PATH&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.add_dll_directory(dll_dir)</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find_qt()</span><br><span class="line"><span class="keyword">del</span> find_qt</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，错误是在 <code>raise ImportError(&quot;unable to find Qt5Core.dll on PATH&quot;)</code> 这里报出来。这段代码的大致意思就是在系统的环境变量 PATH 路径下去找 <code>Qt5Core.dll</code> 文件，而实际上这个文件并不在 PATH 路径下。</p>
<p>我们在使用 PyInstaller 打包时，指定 <code>-F</code> 选项理论上是会将 <code>Qt5Core.dll</code> 文件打包进可执行文件的，但是由于 PyQT5.13 默认在系统 PATH 路径下查找，因此出错了。</p>
<p>我们可以将下面的内容注释掉，然后一切运行正常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else:</span><br><span class="line">    raise ImportError(&quot;unable to find Qt5Core.dll on PATH&quot;)</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以使用之前版本的代码替换现有代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os <span class="keyword">as</span> _os</span><br><span class="line"></span><br><span class="line">_path = _os.path.dirname(__file__) + <span class="string">&#x27;\\Qt\\bin;&#x27;</span> + _os.environ[<span class="string">&#x27;PATH&#x27;</span>]</span><br><span class="line">_os.environ[<span class="string">&#x27;PATH&#x27;</span>] = _path</span><br></pre></td></tr></table></figure>

<p>经过修改后，再次打包运行一切正常。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://github.com/pyinstaller/pyinstaller/issues/4293#issuecomment-507254991">https://github.com/pyinstaller/pyinstaller/issues/4293#issuecomment-507254991</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyQt5</tag>
        <tag>PyInstaller</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5 信号槽自定义参数</title>
    <url>/2019/04/pyqt5-signal-slot/</url>
    <content><![CDATA[<p>我们知道 PyQt5 利用信号和槽在对象之间传递数据，当特定的事件发生时，信号将通过 <code>emit</code> 发出，槽则负责响应该信号。QT 中的对象已经包含了非常多信号的定义。本文对信号槽的使用不做具体介绍，感兴趣的朋友可以参考<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/signals_slots.html">这里</a>，我在这里主要记录如何对信号传递用户自定义参数。</p>
<a id="more"></a>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面我想给出一个典型的示例程序，在这个程序中我只是简单的添加一个按钮，然后给出按钮被按下的次数，完整的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QLabel</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QWidget</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QPushButton</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QHBoxLayout</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QMainWindow</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApp</span>(<span class="params">QMainWindow</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.clicknum = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        hbox = QHBoxLayout()</span><br><span class="line">        self.label = QLabel(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">        self.button = QPushButton(<span class="string">&#x27;click me&#x27;</span>)</span><br><span class="line">        self.button.clicked.connect(self.clickMe)</span><br><span class="line">        hbox.addWidget(self.button)</span><br><span class="line">        hbox.addWidget(self.label)</span><br><span class="line">        widget = QWidget()</span><br><span class="line">        widget.setLayout(hbox)</span><br><span class="line">        self.setCentralWidget(widget)</span><br><span class="line">        self.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clickMe</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.clicknum &gt; <span class="number">1</span>:</span><br><span class="line">            message = <span class="string">&#x27;click: &#123;0&#125; times&#x27;</span>.format(self.clicknum)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            message = <span class="string">&#x27;click: &#123;0&#125; time&#x27;</span>.format(self.clicknum)</span><br><span class="line"></span><br><span class="line">        self.label.setText(message)</span><br><span class="line">        self.clicknum += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    testapp = TestApp()</span><br><span class="line">    sys.exit(app.exec_())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的程序非常简单，就是记录从程序开始运行到结束时一共按了多少次按钮。</p>
<img src="/2019/04/pyqt5-signal-slot/simple-test.png" class="">

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>其实此处我主要是为了演示而特意给出这个不太符合常理的做法 (相当的无厘头)。下面请看代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QLabel</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QWidget</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QPushButton</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QHBoxLayout</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QMainWindow</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApp</span>(<span class="params">QMainWindow</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.clicknum = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        hbox = QHBoxLayout()</span><br><span class="line">        self.label = QLabel(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">        self.button = QPushButton(<span class="string">&#x27;click me&#x27;</span>)</span><br><span class="line">        self.button.clicked.connect(<span class="keyword">lambda</span>: self.clickMe(self.clicknum))</span><br><span class="line">        hbox.addWidget(self.button)</span><br><span class="line">        hbox.addWidget(self.label)</span><br><span class="line">        widget = QWidget()</span><br><span class="line">        widget.setLayout(hbox)</span><br><span class="line">        self.setCentralWidget(widget)</span><br><span class="line">        self.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clickMe</span>(<span class="params">self, clicknum</span>):</span></span><br><span class="line">        <span class="keyword">if</span> clicknum &gt; <span class="number">1</span>:</span><br><span class="line">            message = <span class="string">&#x27;click: &#123;0&#125; times&#x27;</span>.format(clicknum)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            message = <span class="string">&#x27;click: &#123;0&#125; time&#x27;</span>.format(clicknum)</span><br><span class="line"></span><br><span class="line">        self.label.setText(message)</span><br><span class="line">        self.clicknum += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    testapp = TestApp()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们将按钮所关联的槽使用 <code>lambda</code> 方式给出，并为它赋予了一个参数。这样每次在信号被触发时，<code>self.clicknum</code> 的值都将被传递过去。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://eli.thegreenplace.net/2011/04/25/passing-extra-arguments-to-pyqt-slot/">Passing extra arguments to PyQt slots</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyQt5</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 多语言国际化支持</title>
    <url>/2018/11/python-internationalization-support/</url>
    <content><![CDATA[<!--
GNU gettext 是国际化 (i18n) 开发古老而成熟的解决方案。它可以用于本地化任何类型的应用程序，并且在支持不同区域设置和规则方面十分灵活。在本文中，我们将介绍如何使用 Python 标准库中自带的 gettext 模块来实现程序的多语言支持。
-->


<p>Python 的 gettext 模块为应用程序提供了国际化 (Internationalization, I18N) 和本地化 (Localization, L10N) 的服务。该模块提供了两类 APIs：(a) 支持 GNU gettext 的基本 API；(b) 适合 Python 的并且基于类的 API。本文主要针对第二类 API 进行介绍。</p>
<p>为了向 Python 程序提供多语言消息，我们需要按以下步骤进行：</p>
<ol>
<li>使用包装函数对程序中所有可以翻译的字符串进行标记；</li>
<li>使用 xgettext 在标记的文件上生成原始消息目录或 POT 文件；</li>
<li>将 POT 文件复制到特定的区域设置目录并进行翻译（需要使用专用的编辑器）；</li>
<li>导入并使用 gettext 模块，以便正确转换消息字符串。</li>
</ol>
<a id="more"></a>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>为了更好的理解整个过程，我们需要一个想要本地化的示例程序。我们的示例程序目录结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i18n&#x2F;</span><br><span class="line">+-- locales</span><br><span class="line">|   +-- en_US</span><br><span class="line">|   |   +-- LC_MESSAGES</span><br><span class="line">|   +-- zh_CN</span><br><span class="line">|       +-- LC_MESSAGES</span><br><span class="line">+-- src</span><br><span class="line">    +-- main.py</span><br></pre></td></tr></table></figure>

<p>目录 <code>locales</code> 用于存放多国语言之间的翻译文件，<code>src</code> 则用于存放源码文件。正如上文所述，我们需要标记程序中待翻译的字符串，为了实现这一点，我们将需要翻译的字符串放在 <code>_()</code> 中。文件 main.py 的内容如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Internationalization test.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gettext</span><br><span class="line">_ = gettext.gettext</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printSomeMessages</span>():</span></span><br><span class="line">    print(_(<span class="string">&quot;Hello world!&quot;</span>))</span><br><span class="line">    print(_(<span class="string">&quot;This is a translate message.&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    printSomeMessages()</span><br></pre></td></tr></table></figure>

<p>注意，我们引入了 gettext 模块并将 <code>_</code> 赋值为 <code>gettext.gettext</code>。这样可以保证我们的程序可以正常运行。</p>
<h2 id="生成原始翻译消息"><a href="#生成原始翻译消息" class="headerlink" title="生成原始翻译消息"></a>生成原始翻译消息</h2><p>为了自动化在整个应用程序中从包装字符串生成原始可翻译消息的过程，gettext 库的作者提供了一组工具用于解析源文件并提取需要翻译的消息。最初，GNU gettext 仅支持 C/C++ 源码，但是它的扩展程序 xgettext 支持多种语言的源码，包括 Python，Lisp，Java 等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> i18n</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xgettext -o locales/en_US/LC_MESSAGES/base.po_en src/*.py</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xgettext -o locales/zh_CN/LC_MESSAGES/base.po_zh src/*.py</span></span><br></pre></td></tr></table></figure>

<p>原始信息 (两个文件内容一致) 如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># SOME DESCRIPTIVE TITLE.</span><br><span class="line"># Copyright (C) YEAR THE PACKAGE&#39;S COPYRIGHT HOLDER</span><br><span class="line"># This file is distributed under the same license as the PACKAGE package.</span><br><span class="line"># FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, YEAR.</span><br><span class="line">#</span><br><span class="line">#, fuzzy</span><br><span class="line">msgid &quot;&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br><span class="line">&quot;Project-Id-Version: PACKAGE VERSION\n&quot;</span><br><span class="line">&quot;Report-Msgid-Bugs-To: \n&quot;</span><br><span class="line">&quot;POT-Creation-Date: 2018-11-04 10:24+0800\n&quot;</span><br><span class="line">&quot;PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n&quot;</span><br><span class="line">&quot;Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;\n&quot;</span><br><span class="line">&quot;Language-Team: LANGUAGE &lt;LL@li.org&gt;\n&quot;</span><br><span class="line">&quot;Language: \n&quot;</span><br><span class="line">&quot;MIME-Version: 1.0\n&quot;</span><br><span class="line">&quot;Content-Type: text&#x2F;plain; charset&#x3D;CHARSET\n&quot;</span><br><span class="line">&quot;Content-Transfer-Encoding: 8bit\n&quot;</span><br><span class="line"></span><br><span class="line">#: src&#x2F;main.py:11</span><br><span class="line">msgid &quot;Hello world!&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br><span class="line"></span><br><span class="line">#: src&#x2F;main.py:12</span><br><span class="line">msgid &quot;This is a translate message.&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>在得到原始翻译消息之后，我们就可以通过编辑生成的 <code>*.po</code> 文件进行翻译工作了。这里需要注意的是 PO 文件具有自己的格式，因此尽量使用专用的 PO 文件编辑器进行修改。我个人使用的 Emacs + po-mode 进行编辑。</p>
<p>翻译 locales/en_US/LC_MESSAGES/base.po_en 为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># I18N.</span><br><span class="line"># Copyright (C) 2018 Japin Li</span><br><span class="line"># This file is distributed under the same license as the I18N package.</span><br><span class="line"># Japin Li &lt;japinli@hotmail.com&gt;, 2018.</span><br><span class="line">#</span><br><span class="line">#, fuzzy</span><br><span class="line">msgid &quot;&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br><span class="line">&quot;Project-Id-Version: 0.0.1\n&quot;</span><br><span class="line">&quot;Report-Msgid-Bugs-To: \n&quot;</span><br><span class="line">&quot;POT-Creation-Date: 2018-11-04 10:24+0800\n&quot;</span><br><span class="line">&quot;PO-Revision-Date: 2018-11-04 10:26+0800\n&quot;</span><br><span class="line">&quot;Last-Translator: Japin Li &lt;japinli@hotmail.com&gt;\n&quot;</span><br><span class="line">&quot;Language-Team: English &lt;LL@li.org&gt;\n&quot;</span><br><span class="line">&quot;Language: \n&quot;</span><br><span class="line">&quot;MIME-Version: 1.0\n&quot;</span><br><span class="line">&quot;Content-Type: text&#x2F;plain; charset&#x3D;ASCII\n&quot;</span><br><span class="line">&quot;Content-Transfer-Encoding: 8bit\n&quot;</span><br><span class="line"></span><br><span class="line">#: src&#x2F;main.py:11</span><br><span class="line">msgid &quot;Hello world!&quot;</span><br><span class="line">msgstr &quot;Hello world!&quot;</span><br><span class="line"></span><br><span class="line">#: src&#x2F;main.py:12</span><br><span class="line">msgid &quot;This is a translate message.&quot;</span><br><span class="line">msgstr &quot;This is a translate message.&quot;</span><br></pre></td></tr></table></figure>

<p>翻译 locales/zh_CN/LC_MESSAGES/base.po_zh 为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># I18N.</span><br><span class="line"># Copyright (C) 2018 Japin Li</span><br><span class="line"># This file is distributed under the same license as the I18N package.</span><br><span class="line"># Japin Li &lt;japinli@hotmail.com&gt;, 2018.</span><br><span class="line">#</span><br><span class="line">#, fuzzy</span><br><span class="line">msgid &quot;&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br><span class="line">&quot;Project-Id-Version: 0.0.1\n&quot;</span><br><span class="line">&quot;Report-Msgid-Bugs-To: \n&quot;</span><br><span class="line">&quot;POT-Creation-Date: 2018-11-04 10:24+0800\n&quot;</span><br><span class="line">&quot;PO-Revision-Date: 2018-11-04 10:37+0800\n&quot;</span><br><span class="line">&quot;Last-Translator: Japin Li &lt;japinli@hotmail.com&gt;\n&quot;</span><br><span class="line">&quot;Language-Team: Chinese &lt;LL@li.org&gt;\n&quot;</span><br><span class="line">&quot;Language: \n&quot;</span><br><span class="line">&quot;MIME-Version: 1.0\n&quot;</span><br><span class="line">&quot;Content-Type: text&#x2F;plain; charset&#x3D;UTF-8\n&quot;</span><br><span class="line">&quot;Content-Transfer-Encoding: 8bit\n&quot;</span><br><span class="line"></span><br><span class="line">#: src&#x2F;main.py:11</span><br><span class="line">msgid &quot;Hello world!&quot;</span><br><span class="line">msgstr &quot;你好世界！&quot;</span><br><span class="line"></span><br><span class="line">#: src&#x2F;main.py:12</span><br><span class="line">msgid &quot;This is a translate message.&quot;</span><br><span class="line">msgstr &quot;这是一个翻译消息。&quot;</span><br></pre></td></tr></table></figure>

<p>上述翻译需要注意中文的编码要选择 <code>UTF-8</code>，至于其他的诸如 PACKAGE VERSION，COPYRIGHT 等可以根据自己需要进行填写。当翻译完成之后，我们需要将 <code>*.po</code> 文件通过 msgfmt 最终转换为 <code>*.mo</code> 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> i18n</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> msgfmt -o locales/en_US/LC_MESSAGES/base.mo locales/en_US/LC_MESSAGES/base.po_en</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> msgfmt -o locales/zh_CN/LC_MESSAGES/base.mo locales/zh_CN/LC_MESSAGES/base.po_zh</span></span><br></pre></td></tr></table></figure>

<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>我们修改 src/main.py 文件为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Internationalization test.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gettext</span><br><span class="line">_ = gettext.gettext</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printSomeMessages</span>():</span></span><br><span class="line">    print(_(<span class="string">&quot;Hello world!&quot;</span>))</span><br><span class="line">    print(_(<span class="string">&quot;This is a translate message.&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">localedir=os.path.dirname(os.path.abspath(sys.argv[<span class="number">0</span>])) + <span class="string">&#x27;/../locales&#x27;</span></span><br><span class="line">zh_CN = gettext.translation(<span class="string">&#x27;base&#x27;</span>, localedir, languages=[<span class="string">&#x27;zh_CN&#x27;</span>]);</span><br><span class="line">zh_CN.install()</span><br><span class="line">_ = zh_CN.gettext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    printSomeMessages()</span><br></pre></td></tr></table></figure>

<p>其中 <code>getext.translation</code> 函数有三个较为重要的参数。</p>
<ul>
<li>domain - 该参数的名字需要与生成的 <code>*.mo</code> 的文件名匹配。</li>
<li>localedir - 创建的 locales 目录的路径</li>
<li>languages - 需要载入的语言代码</li>
</ul>
<p>最终文件目录结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i18n&#x2F;</span><br><span class="line">+-- locales</span><br><span class="line">|   +-- en_US</span><br><span class="line">|   |   +-- LC_MESSAGES</span><br><span class="line">|   |       +-- base.mo</span><br><span class="line">|   |       +-- base.po_en</span><br><span class="line">|   +-- zh_CN</span><br><span class="line">|       +-- LC_MESSAGES</span><br><span class="line">|           +-- base.mo</span><br><span class="line">|           +-- base.po_zh</span><br><span class="line">+-- src</span><br><span class="line">    +-- main.py</span><br></pre></td></tr></table></figure>

<p>你可以在 <a href="https://github.com/japinli/i18n">github</a> 上下载整个工程文件。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://phraseapp.com/blog/posts/translate-python-gnu-gettext/">https://phraseapp.com/blog/posts/translate-python-gnu-gettext/</a><br>[2] <a href="https://docs.python.org/2/library/gettext.html#class-based-api">https://docs.python.org/2/library/gettext.html#class-based-api</a></p>
<hr>

<p><strong>P.S.</strong> Internationalization 简写为 I18N 是因为在单词第一个字母 I 和最后一个字母 N 之间有 18 个字符。Localization 亦是如此。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Seafile 与 OnlyOffice 在线预览 Office 文档</title>
    <url>/2020/05/seafile-with-onlyoffice/</url>
    <content><![CDATA[<p>最近，在公司采用 Seafile 搭建了一个文件服务器，并结合 OnlyOffice 实现在线预览功能。本文简要记录一下这个过程中所遇到的问题。</p>
<a id="more"></a>

<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>我使用了三台机器来构建整个系统，一台 nginx 服务器，用来作为前端代理；一台 Seafile 服务器用于存放文档；一台 OnlyOffice 服务器用来实现在线预览 Office 文档。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先，我们按照 <a href="https://cloud.seafile.com/published/seafile-manual-cn/deploy/using_mysql.md">Seafile 官方给出的部署方式</a>安装 Seafile 服务器，然后采用 <a href="https://cloud.seafile.com/published/seafile-manual-cn/deploy/deploy_with_nginx.md">Nginx 来代理 Seafile 的请求</a>，最后使用 <a href="https://cloud.seafile.com/published/seafile-manual-cn/deploy/only_office.md">OnlyOffice 实现在线预览</a>。</p>
<p><strong>备注：</strong> OnlyOffice 在线预览需要开源版本 6.1.0+ 的 Seafile，本文采用的是 Seafile 7.0.5 版本。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="预览文件下载失败"><a href="#预览文件下载失败" class="headerlink" title="预览文件下载失败"></a>预览文件下载失败</h3><p>在安装好之后，通过 Seafile 域名可以正常访问，并且访问 <code>http://example.seafile.com/onlyoffice/welcome</code> 可以得到 <code>Document Server is running</code> 结果，但是在打开 Word 文档预览时却提示下载失败。这是由于我使用域名来访问 Seafile，但是在 ccnet.conf 配置文件的 SERVICE_URL 配置却是 IP 地址格式导致的。我们可以在 Web 页面进行修改，也可以通过配置文件修改将其修改为域名形式即可，见参考文献 [2]。</p>
<h3 id="预览文件暂时无法访问"><a href="#预览文件暂时无法访问" class="headerlink" title="预览文件暂时无法访问"></a>预览文件暂时无法访问</h3><p>随后，我又遇到文件暂时无法访问的问题，这同样是由于域名导致的，我采用 docker 的方式安装 OnlyOffice，通过查看日志（如下所示）发现它无法解析域名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2020-05-16T01:11:42.235] [ERROR] nodeJS - dnsLookup error: hostname &#x3D; example.seafile.com</span><br><span class="line">Error: getaddrinfo ENOTFOUND example.seafile.com</span><br><span class="line">    at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:56:26)</span><br></pre></td></tr></table></figure>

<p>因此，我们需要在 docker 中添加正确的域名解析即可。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://cloud.seafile.com/published/seafile-manual-cn/home.md">https://cloud.seafile.com/published/seafile-manual-cn/home.md</a><br>[2] <a href="https://bbs.seafile.com/t/topic/4528/2">https://bbs.seafile.com/t/topic/4528/2</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Seafile</tag>
      </tags>
  </entry>
  <entry>
    <title>Greenplum 数据库 semctl 失败之无效参数</title>
    <url>/2019/07/semctl-failed-invalid-argument/</url>
    <content><![CDATA[<p>在编译完成之后对 Greenplum 数据库进行安装测试时遇到如下问题，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psql: FATAL:  semctl(592740353, 7, SETVAL, 0) failed: Invalid argument (pg_sema.c:151)</span><br></pre></td></tr></table></figure>

<p>从而导致数据库启动失败，从错误结果来看应该是与信号量相关。那么具体是怎么回事呢？</p>
<p>文献 <a href="https://wiki.postgresql.org/wiki/Systemd">[1]</a> 中给出了关于这个错误的详细说明，问题是由 System V IPC 对象导致的。</p>
<p>配置文件 <code>logind.conf</code> 中的 <code>RemoveIPC</code> 参数控制着 System V IPC 对象是否在用户完全退出的情况下被清除（系统用户排除在外）。在 <code>systemd 212</code> 版本之后这个选项默认是开启的，即 <code>RemoveIPC=yes</code>。仍在被使用的共享内存段不会被清理，因此 <code>systemd</code> 不会去清理正在使用的共享内存段；但是信号量没有进程附加的概念，因此，当用户退出或进程终止时，即便该信号量正在被使用也会被清理（这里的理解不一定正确，建议直接看原文）。</p>
<a id="more"></a>

<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在了解了问题的本质之后，我们来看看如何解决这个问题。正如前面所说的，系统用户可以免除这个问题的困扰，那么我们的第一种方法就是建立一个系统用户，然后使用这个用户来运行数据库（<code>useradd -r</code> 命令）。</p>
<p>不过，还是比较推荐第二种方式，即修改 <code>RemoveIPC</code> 为 <code>RemoveIPC=no</code>，随后重启 <code>systemd-logind</code>。Ubuntu 下的做法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;RemoveIPC&#x3D;no&quot; &gt;&gt; &#x2F;etc&#x2F;systemd&#x2F;logind.conf</span><br><span class="line">$ systemctl restart systemd-logind</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://wiki.postgresql.org/wiki/Systemd">https://wiki.postgresql.org/wiki/Systemd</a><br>[2] <a href="https://www.postgresql.org/message-id/flat/1481075896588-5933635.post%40n3.nabble.com">https://www.postgresql.org/message-id/flat/1481075896588-5933635.post%40n3.nabble.com</a><br>[3] <a href="https://www.postgresql.org/message-id/CAK7tEys9-O4BTERbs3Xuk2BfFNNd55u2sM9j5R2Fi7v6BHjrQw@mail.gmail.com">BUG #13818: PostgreSQL crashes after cronjob runs as “postgres”</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Greenplum</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX 查看命令的定义</title>
    <url>/2019/04/show-LaTeX-command-definition/</url>
    <content><![CDATA[<p>最近在使用 LaTeX 撰写文档时需要重定义一个命令的，但是我想要知道该命令的原始定义时怎样的，经过查找发现 LaTeX 在这方面做得还是很不错的。目前，我知道有两种方式可以获取命令的定义：(a) 在文档中使用 <code>\show\command</code>；(b) 在命令行中使用 <code>texdef command</code>。</p>
<a id="more"></a>

<h2 id="show-查看命令定义"><a href="#show-查看命令定义" class="headerlink" title="\show 查看命令定义"></a><code>\show</code> 查看命令定义</h2><p>下面是一个完整的文档示例，在该文档中，我们通过 <code>\show\section</code> 来查看 <code>\section</code> 的定义。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">show</span></span><span class="tag">\<span class="name">section</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>上述代码非常简单，当我们通过 <code>latex</code> 编译时可以得到以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ latex test.tex</span><br><span class="line">This is pdfTeX, Version 3.14159265-2.6-1.40.19 (TeX Live 2018) (preloaded format&#x3D;latex)</span><br><span class="line"> restricted \write18 enabled.</span><br><span class="line"> entering extended mode</span><br><span class="line"> (.&#x2F;test.tex</span><br><span class="line"> LaTeX2e &lt;2018-04-01&gt; patch level 5</span><br><span class="line"> (&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2018&#x2F;texmf-dist&#x2F;tex&#x2F;latex&#x2F;base&#x2F;article.cls</span><br><span class="line"> Document Class: article 2014&#x2F;09&#x2F;29 v1.4h Standard LaTeX document class</span><br><span class="line"> (&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2018&#x2F;texmf-dist&#x2F;tex&#x2F;latex&#x2F;base&#x2F;size10.clo)) (.&#x2F;test.aux)</span><br><span class="line"> &gt; \section&#x3D;\long macro:</span><br><span class="line"> -&gt;\@startsection &#123;section&#125;&#123;1&#125;&#123;\z@ &#125;&#123;-3.5ex \@plus -1ex \@minus -.2ex&#125;&#123;2.3ex \@p</span><br><span class="line"> lus .2ex&#125;&#123;\normalfont \Large \bfseries &#125;.</span><br><span class="line"> l.3 \show\section</span><br><span class="line"></span><br><span class="line"> ?</span><br></pre></td></tr></table></figure>

<p>注意第 10 行的输出，<code>\section=\long macro:</code> 这里就是关于 <code>\section</code> 命令的定义。</p>
<h2 id="texdef-查看命令定义"><a href="#texdef-查看命令定义" class="headerlink" title="texdef 查看命令定义"></a><code>texdef</code> 查看命令定义</h2><p><code>texdef</code> 时一个 shell 命令，我们可以直接在 shell 中执行，例如，我们想看 <code>\section</code> 命令的定义，可以在 shell 中输入 <code>texdef section</code>，其输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ texdef section</span><br><span class="line"></span><br><span class="line">\section:</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<p>为什么 <code>section</code> 命令没有定义？这里的例子其实与上面的稍微有点不一样，上面我们使用的是 <code>latex</code> 来编译的，而 <code>texdef</code> 查看的是原 <code>TeX</code> 命令的定义而非 <code>LaTeX</code> 命令的定义，因此我们需要将其换为 <code>latexdef</code>，其结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ latexdef section</span><br><span class="line"></span><br><span class="line">\section:</span><br><span class="line">\long macro:-&gt;\@startsection &#123;section&#125;&#123;1&#125;&#123;\z@ &#125;&#123;-3.5ex \@plus -1ex \@minus -.2ex&#125;&#123;2.3ex \@plus .2ex&#125;&#123;\normalfont \Large \bfseries &#125;</span><br></pre></td></tr></table></figure>

<p><code>latexdef</code> 命令提供了很多选项给用户选择，关于如何使用 <code>latexdef</code> 请使用 <code>latexdef --help</code> 查看帮助手册。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://tex.stackexchange.com/questions/36955/display-source-for-a-command">https://tex.stackexchange.com/questions/36955/display-source-for-a-command</a></p>
]]></content>
      <categories>
        <category>排版</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 中 ROUND 函数的使用</title>
    <url>/2019/03/sql-rounding/</url>
    <content><![CDATA[<p>在某些情况下我们可能需要对实数进行四舍五入，在 SQL 中我们可以通过 <code>ROUND</code> 函数来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># SELECT ROUND(123.456)</span><br><span class="line"> round</span><br><span class="line">-------</span><br><span class="line">   123</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"># SELECT ROUND(123.567)</span><br><span class="line"> round</span><br><span class="line">-------</span><br><span class="line">   124</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>我们还可以给 <code>ROUND</code> 函数指定第二个参数，它表示四舍五入的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># SELECT ROUND(123.456, 1)</span><br><span class="line"> round</span><br><span class="line">-------</span><br><span class="line"> 123.5</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"># SELECT ROUND(123.567, -2)</span><br><span class="line"> round</span><br><span class="line">-------</span><br><span class="line">   100</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 查询结果转为 JSON 格式</title>
    <url>/2019/09/turning-query-results-into-json-in-postgresql/</url>
    <content><![CDATA[<img src="/2019/09/turning-query-results-into-json-in-postgresql/postgresql-weekly.png" class="">

<p>您知道 Postgres 提供了一个函数将查询结果集转为 JSON 数据类型吗？这个函数是 <code>row_to_json</code>。</p>
<a id="more"></a>

<p>我们先创建一个表，它包含两个用户记录以以及一个 <code>interests</code> 的属性列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> people</span><br><span class="line">	(<span class="keyword">name</span> <span class="built_in">text</span>, age <span class="built_in">int</span>, interests <span class="built_in">text</span>[]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> people (<span class="keyword">name</span>, age, interests)</span><br><span class="line">	<span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Jon&#x27;</span>, <span class="number">12</span>, <span class="built_in">ARRAY</span> [<span class="string">&#x27;Golf&#x27;</span>, <span class="string">&#x27;Food&#x27;</span>]),</span><br><span class="line">    (<span class="string">&#x27;Jane&#x27;</span>, <span class="number">45</span>, <span class="built_in">ARRAY</span> [<span class="string">&#x27;Art&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p><code>row_to_json</code> 函数最基本的使用方法是使用 <code>ROW</code> 行构造器，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> row_to_json(<span class="keyword">ROW</span>(<span class="keyword">name</span>, age, interests)) <span class="keyword">FROM</span> people;</span><br><span class="line">                row_to_json</span><br><span class="line"><span class="comment">-------------------------------------------</span></span><br><span class="line"> &#123;&quot;f1&quot;:&quot;Jon&quot;,&quot;f2&quot;:12,&quot;f3&quot;:[&quot;Golf&quot;,&quot;Food&quot;]&#125;</span><br><span class="line"> &#123;&quot;f1&quot;:&quot;Jane&quot;,&quot;f2&quot;:45,&quot;f3&quot;:[&quot;Art&quot;]&#125;</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>针对表中不同的类型，在最后的输出中都做了相应的转换，但是属性列的名称在输出中并没有体现出来。幸运的是我们可以通过子查询的方式来实现：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> row_to_json(q1) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> people <span class="keyword">LIMIT</span> <span class="number">1</span>) q1;</span><br><span class="line">                     row_to_json</span><br><span class="line"><span class="comment">-----------------------------------------------------</span></span><br><span class="line"> &#123;&quot;name&quot;:&quot;Jon&quot;,&quot;age&quot;:12,&quot;interests&quot;:[&quot;Golf&quot;,&quot;Food&quot;]&#125;</span><br><span class="line">(1 rows)</span><br></pre></td></tr></table></figure>

<p>虽然与我们的示例无关，但我们还是需要提一下，<code>row_to_json</code> 提供了一个可选的参数 <code>prettifies</code> 用于格式化输出，想要启用它，您可以在上面的示例中使用 <code>row_to_json(q1, true)</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> row_to_json(q1, <span class="literal">true</span>) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> people <span class="keyword">LIMIT</span> <span class="number">1</span>) q1;</span><br><span class="line">          row_to_json</span><br><span class="line"><span class="comment">-------------------------------</span></span><br><span class="line"> &#123;&quot;name&quot;:&quot;Jon&quot;,               +</span><br><span class="line">  &quot;age&quot;:12,                   +</span><br><span class="line">  &quot;interests&quot;:[&quot;Golf&quot;,&quot;Food&quot;]&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p>[1] <a href="https://postgresweekly.com/issues/322">https://postgresweekly.com/issues/322</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 笔记本盖住不挂机</title>
    <url>/2020/03/ubuntu-lid-switch-action/</url>
    <content><![CDATA[<p>我有一台旧笔记本装有 Ubuntu 18.04 系统，希望把它当作一个服务器，这时我就需要在盖住笔记本时系统不休眠。</p>
<p>Ubuntu 系统中提供了 Login Manager 来管理这些行为，它的配置文件为 /etc/systemd/logind.conf。通过<br><code>man logind.conf</code> 我们可以看到其详细说明。</p>
<p>其中有一项 <code>HandleLidSwitch</code>，它控制了笔记本盖住的行为，默认情况下是 <code>suspend</code>，我们可以将其修改为 <code>ignore</code> 即可以实现我们的目的。例如，我们修改 /etc/system/logind.conf 文件中的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#HandleLidSwitch&#x3D;suspend</span><br></pre></td></tr></table></figure>

<p>行修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HandleLidSwitch&#x3D;ignore</span><br></pre></td></tr></table></figure>

<p>然后重启 systemd-logind 服务即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo service systemd-logind restart</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 修改 I/O 调度算法</title>
    <url>/2019/03/ubuntu-modify-io-scheduler/</url>
    <content><![CDATA[<p>Linux I/O 调度器控制着内核读写磁盘的工作方式。系统管理员可以通过更改调度器来自定义磁盘调度算法，从而优化系统性能。有三种调度程序可供选择，每种调度程序都有其优点。这些调度器是：</p>
<ul>
<li><p><strong>Noop</strong> - 电梯调度算法，最简单的调度算法，该算法基于先进先出队列 (FIFO) 实现，所有的 I/O 请求都符合先进先出规则，适合于 SSD 设备。</p>
</li>
<li><p><strong>Deadline</strong> - 绝对保障算法，它为读和写分别创建了 FIFO 队列，当内核收到请时，先尝试合并，不能合并则尝试排序或放入队列中，并且尽量保证在请求到达最终期限时进行调度，避免有一些请求长时间不能得到处理。该调度器适合虚拟机所在宿主机器或 I/O 压力比较重的场景，例如数据库服务器。</p>
</li>
<li><p><strong>Completely Fair Queuing, CFQ</strong> - 绝对公平调度算法，它为每个进程和线程单独创建一个队列来管理该进程的 I/O 请求，然后为每个队列分配访问磁盘的时间片。时间片的长度以及允许队列提交的请求数取决于给定进程的 I/O 优先级。该调度器比较适合于通用服务器。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="查询当前调度器"><a href="#查询当前调度器" class="headerlink" title="查询当前调度器"></a>查询当前调度器</h2><p>首先，我们需要知道系统目前使用的是哪种 I/O 调度器。假设我们有一块名为 <code>sda</code> 的磁盘，那么我们可以通过如下命令查看该磁盘使用的调度器类别。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/block/sda/queue/scheduler</span></span><br><span class="line">noop [deadline] cfq</span><br></pre></td></tr></table></figure>

<p>从上面可以看到我们的系统在 <code>sda</code> 磁盘上支持 <code>noop</code>，<code>deadline</code> 和 <code>cfq</code> 三种调度器，而默认采用的是 <code>deadline</code> 调度器。</p>
<h2 id="修改调度器"><a href="#修改调度器" class="headerlink" title="修改调度器"></a>修改调度器</h2><p>Ubuntu 系统提供了两种方式来修改调度器：a) 临时修改；b) 永久修改。临时修改的方式在系统重启后将会恢复到默认设置。通常，我们可以通过临时修改的方式来确定哪种调度器能带来更大的性能提升，然后在永久的修改为这种调度器。</p>
<p>我们可以通过下面的命令将系统的调度器临时的修改为 <code>noop</code> 类型：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo <span class="built_in">echo</span> noop &gt; /sys/block/sda/queue/scheduler</span></span><br></pre></td></tr></table></figure>

<p>通过上述方式修改不需要重启机器而是立马生效。如果你需要永久的修改调度器，那么你需要修改 GRUB 的配置文件，即编辑配置文件 <code>/etc/default/grub</code> 修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT&#x3D;&quot;quiet splash&quot;</span><br></pre></td></tr></table></figure>

<p>为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT&#x3D;&quot;quiet splash elevator&#x3D;noop&quot;</span><br></pre></td></tr></table></figure>

<p>通过这种方式修改我们需要重启机器以使修改生效，当然我们可以结合临时修改的方式，从而避免重启。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 谭峰，张文升《PostgreSQL 实战》<br>[2] <a href="https://www.techrepublic.com/article/how-to-change-the-linux-io-scheduler-to-fit-your-needs/">How to change the linux io scheduler to fit your needs</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 插件编写</title>
    <url>/2018/12/write-postgresql-extension/</url>
    <content><![CDATA[<p>PostgreSQL 标榜自己为最先进 (Most Advance) 的开源关系数据库，它支持大部分 SQL 标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL 可以用许多方法扩展，比如，通过增加新的数据类型、函数、操作符、聚集函数、索引。PostgreSQL 被设计为易于扩展，因此通过插件我们可以很容易的扩展 PostgreSQL 数据库。本文就从编写一个简单的斐波那契的数据库扩展来介绍 PostgreSQL 插件的编写。</p>
<a id="more"></a>

<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>斐波那契数列 (Fibonacci sequence)，又称黄金分割数列、因数学家列昂纳多·斐波那契 (Leonardoda Fibonacci) 以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、…… 在数学上，斐波纳契数列以如下被以递推的方法定义<sup>1</sup>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0, F(1) &#x3D; 1, F(n) &#x3D; F(n - 1) + F(n - 2) (n &gt;&#x3D; 2, n ∈ N)</span><br></pre></td></tr></table></figure>

<h2 id="PostgreSQL-扩展插件的框架"><a href="#PostgreSQL-扩展插件的框架" class="headerlink" title="PostgreSQL 扩展插件的框架"></a>PostgreSQL 扩展插件的框架</h2><p>我们为了使 PostgreSQL 可以通过 <code>CREATE EXTENSION</code> 命令加载插件，我们的扩展插件至少需要两个文件：一个名为 <code>extension_name.control</code> 的控制文件和一个名为 <code>extension--version.sql</code> 的扩展 SQL 脚本文件。其中控制文件中包含了扩展插件名、版本等基本信息。现在让我们创建这两个文件。</p>
<p>我们的 fibonacci 扩展插件的控制文件 (fibonacci.control) 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># fibonacci extension</span><br><span class="line">comment &#x3D; &#39;fibonacci extension&#39;</span><br><span class="line">default_version &#x3D; &#39;0.0.1&#39;</span><br><span class="line">relocatable &#x3D; true</span><br></pre></td></tr></table></figure>

<p>我们将使用 PL/pgSQL 来实现这个插件 (fibonacci–0.0.1.sql)，其内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- complain if script is sourced in psql, rather than via CREATE EXTENSION</span><br><span class="line">\echo Use &quot;CREATE EXTENSION fibonacci&quot; to load this file. \quit</span><br><span class="line">CREATE FUNCTION fibonacci(n INTEGER)</span><br><span class="line">RETURNS INTEGER</span><br><span class="line">LANGUAGE plpgsql IMMUTABLE STRICT</span><br><span class="line">    AS $$</span><br><span class="line">    DECLARE</span><br><span class="line">        counter INTEGER :&#x3D; 0;</span><br><span class="line">        i INTEGER :&#x3D; 0;</span><br><span class="line">        j INTEGER :&#x3D; 1;</span><br><span class="line">    BEGIN</span><br><span class="line"></span><br><span class="line">        IF n &lt; 1 THEN</span><br><span class="line">            RETURN 0;</span><br><span class="line">        END IF;</span><br><span class="line"></span><br><span class="line">        WHILE counter &lt; n LOOP</span><br><span class="line">            counter :&#x3D; counter + 1;</span><br><span class="line">            SELECT j, i + j INTO i, j;</span><br><span class="line">        END LOOP;</span><br><span class="line"></span><br><span class="line">        RETURN i;</span><br><span class="line">    END;</span><br><span class="line">    $$;</span><br></pre></td></tr></table></figure>

<p>自 PostgreSQL 9.1 之后，PostgreSQL 提供了 PGXS 用于构建其插件，大部分构建插件的环境变量都可以通过 pg_config 得到重用。接下来我们为 fibonacci 插件添加一个 Makefile 文件用于安装插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXTENSION &#x3D; fibonacci        # the extensions name</span><br><span class="line">DATA &#x3D; fibonacci--0.0.1.sql  # script files to install</span><br><span class="line"></span><br><span class="line"># postgres build stuff</span><br><span class="line">PG_CONFIG &#x3D; pg_config</span><br><span class="line">PGXS :&#x3D; $(shell $(PG_CONFIG) --pgxs)</span><br><span class="line">include $(PGXS)</span><br></pre></td></tr></table></figure>

<p>接下来我们便可以通过 <code>make install</code> 来安装插件。最后，我们在数据库中执行如下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres@database:~&#x2F;postgresql-10.4&#x2F;fib$ psql postgres</span><br><span class="line">psql (10.4)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# create extension fibonacci ;</span><br><span class="line">CREATE EXTENSION</span><br><span class="line">postgres&#x3D;# select fibonacci(10);</span><br><span class="line"> fibonacci</span><br><span class="line">-----------</span><br><span class="line">        55</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;#</span><br></pre></td></tr></table></figure>

<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>现在我们完成了基本的插件功能，但是任何程序都应该包含测试用例以便验证程序的正确性。我们可以很方便的为 PostgreSQL 添加回归测试，在执行完 <code>make install</code> 命令之后利用 <code>make installcheck</code> 运行插件的回归测试。PostgreSQL 将回归测试脚本放在插件目录的 <code>sql/</code> 文件中，每个测试文件都对应一个期望结果的输出文件并放置在插件目录的 <code>expected/</code> 文件中，测试脚本与期望结果具有相同的名字，唯一不同的是期望结果的文件的后缀名为 <code>.out</code>。命令 <code>make installcheck</code> 执行 <code>psql</code> 目录下的所有脚本并且将输出的结果与 <code>expected</code> 目录中的文件进行比较。任何不同的结果都将被写入 <code>regression.diffs</code> 文件。现在，我们为插件添加测试用例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres@database:~&#x2F;postgresql-10.4&#x2F;fib$ cat sql&#x2F;fibonacci_test.sql</span><br><span class="line">CREATE EXTENSION fibonacci;</span><br><span class="line">SELECT fibonacci(0);</span><br><span class="line">SELECT fibonacci(1);</span><br><span class="line">SELECT fibonacci(2);</span><br><span class="line">SELECT fibonacci(3);</span><br><span class="line">SELECT fibonacci(4);</span><br><span class="line">SELECT fibonacci(5);</span><br><span class="line">SELECT fibonacci(6);</span><br><span class="line">SELECT fibonacci(7);</span><br><span class="line">SELECT fibonacci(8);</span><br><span class="line">SELECT fibonacci(9);</span><br><span class="line">SELECT fibonacci(10);</span><br><span class="line">SELECT fibonacci(11);</span><br><span class="line">SELECT fibonacci(12);</span><br><span class="line">SELECT fibonacci(13);</span><br><span class="line">SELECT fibonacci(14);</span><br><span class="line">SELECT fibonacci(15);</span><br><span class="line">SELECT fibonacci(16);</span><br><span class="line">SELECT fibonacci(17);</span><br><span class="line">SELECT fibonacci(18);</span><br><span class="line">SELECT fibonacci(19);</span><br><span class="line">SELECT fibonacci(20);</span><br></pre></td></tr></table></figure>

<p>同时，我们需要修改 <code>Makefile</code> 文件，以便其能执行回归测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXTENSION &#x3D; fibonacci        # the extensions name</span><br><span class="line">DATA &#x3D; fibonacci--0.0.1.sql  # script files to install</span><br><span class="line">REGRESS &#x3D; fibonacci_test     # our test script file (without extension)</span><br><span class="line"></span><br><span class="line"># postgres build stuff</span><br><span class="line">PG_CONFIG &#x3D; pg_config</span><br><span class="line">PGXS :&#x3D; $(shell $(PG_CONFIG) --pgxs)</span><br><span class="line">include $(PGXS)</span><br></pre></td></tr></table></figure>

<p>现在，我们执行 <code>make install &amp;&amp; make installcheck</code> 时，回归测试将会失败，这是由于我们还没有指定期望的输出结果。但是，我们发现目录下多了一个 <code>results</code> 目录，并且该目录下包含 <code>fibonacci_test.out</code> 和 <code>fibonacci_test.out.diff</code> 两个文件。为了简便，我们在这里创建一个 <code>expected</code> 目录，并将 <code>fibonacci_test.out</code> 拷贝到该目录下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres@database:~&#x2F;postgresql-10.4&#x2F;fib$ mkdir expected</span><br><span class="line">postgres@database:~&#x2F;postgresql-10.4&#x2F;fib$ mv results&#x2F;fibonacci_test.out expected&#x2F;</span><br><span class="line">postgres@database:~&#x2F;postgresql-10.4&#x2F;fib$ make installcheck</span><br><span class="line">&#x2F;home&#x2F;postgres&#x2F;postgresql-10.4&#x2F;lib&#x2F;pgxs&#x2F;src&#x2F;makefiles&#x2F;..&#x2F;..&#x2F;src&#x2F;test&#x2F;regress&#x2F;pg_regress --inputdir&#x3D;.&#x2F; --bindir&#x3D;&#39;&#x2F;home&#x2F;postgres&#x2F;postgresql-10.4&#x2F;bin&#39;    --dbname&#x3D;contrib_regression fibonacci_test</span><br><span class="line">(using postmaster on Unix socket, default port)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; dropping database &quot;contrib_regression&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">DROP DATABASE</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; creating database &quot;contrib_regression&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">CREATE DATABASE</span><br><span class="line">ALTER DATABASE</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; running regression test queries        &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">test fibonacci_test           ... ok</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> All 1 tests passed.</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">postgres@database:~&#x2F;postgresql-10.4&#x2F;fib$</span><br></pre></td></tr></table></figure>

<p>我们测试求 <code>[1,30]</code> 的斐波那契数列，其运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# SELECT i, fibonacci(i) FROM generate_series(1,30) i;</span><br><span class="line"> i  | fibonacci</span><br><span class="line">----+-----------</span><br><span class="line">  1 |         1</span><br><span class="line">  2 |         1</span><br><span class="line">  3 |         2</span><br><span class="line">  4 |         3</span><br><span class="line">  5 |         5</span><br><span class="line">  6 |         8</span><br><span class="line">  7 |        13</span><br><span class="line">  8 |        21</span><br><span class="line">  9 |        34</span><br><span class="line"> 10 |        55</span><br><span class="line"> 11 |        89</span><br><span class="line"> 12 |       144</span><br><span class="line"> 13 |       233</span><br><span class="line"> 14 |       377</span><br><span class="line"> 15 |       610</span><br><span class="line"> 16 |       987</span><br><span class="line"> 17 |      1597</span><br><span class="line"> 18 |      2584</span><br><span class="line"> 19 |      4181</span><br><span class="line"> 20 |      6765</span><br><span class="line"> 21 |     10946</span><br><span class="line"> 22 |     17711</span><br><span class="line"> 23 |     28657</span><br><span class="line"> 24 |     46368</span><br><span class="line"> 25 |     75025</span><br><span class="line"> 26 |    121393</span><br><span class="line"> 27 |    196418</span><br><span class="line"> 28 |    317811</span><br><span class="line"> 29 |    514229</span><br><span class="line"> 30 |    832040</span><br><span class="line">(30 rows)</span><br><span class="line"></span><br><span class="line">Time: 12.432 ms</span><br><span class="line">postgres&#x3D;#</span><br></pre></td></tr></table></figure>

<h2 id="利用-C-语言优化性能"><a href="#利用-C-语言优化性能" class="headerlink" title="利用 C 语言优化性能"></a>利用 C 语言优化性能</h2><p>上面我们使用 PL/pgSQL 为 PostgreSQL 编写了斐波那契插件，从上面的运行时间看基本还算可以。但是，我们还可以通过 C 语言来重写这个插件从而提高其性能。下面给出了 C 语言版的斐波那契插件的实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * fibonacci.c</span></span><br><span class="line"><span class="comment"> *   Fibonacci extension for PostgreSQL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;postgres.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;fmgr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">PG_MODULE_MAGIC;</span><br><span class="line"></span><br><span class="line"><span class="function">Datum <span class="title">fibonacci</span><span class="params">(PG_FUNCTION_ARGS)</span></span>;</span><br><span class="line"></span><br><span class="line">PG_FUNCTION_INFO_V1(fibonacci);</span><br><span class="line"></span><br><span class="line">Datum</span><br><span class="line">fibonacci(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">    int32 arg = PG_GETARG_INT32(<span class="number">0</span>);</span><br><span class="line">    int32 i = <span class="number">0</span>;</span><br><span class="line">    int32 j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arg &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        PG_RETURN_INT32(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (arg--) &#123;</span><br><span class="line">        int32 t = j;</span><br><span class="line">        j = i + j;</span><br><span class="line">        i = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PG_RETURN_INT32(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>postgres.h</code> 文件包含了 PostgreSQL 的一些基本的编程接口，该文件需要在每个声明 Postgres 函数的 C 源文件中出现。</li>
<li><code>fmgr.h</code> 包含了 <code>PG_GETARG_XXX</code> 和 <code>PG_RETURN_XXX</code> 的一系列宏定义。</li>
<li><code>PG_MODULE_MAGIC</code> 是一个魔术块，它用于确保将动态加载的目标文件加载到兼容的服务器中。</li>
</ul>
<p>现在，我们利用 C 语言重写了斐波那契插件；接着，我们需要修改安装脚本文件 <code>fibonacci--0.0.1.sql</code> 和 <code>Makefile</code> 文件。为了便于区分，我们将 C 语言实现的版本命名为 <code>0.0.2</code>，因此我们创建一个 <code>fibonacci--0.0.2.sql</code> 的安装脚本，其内容如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- complain if script is sourced in psql, rather than via CREATE EXTENSION</span></span><br><span class="line">\echo <span class="keyword">Use</span> <span class="string">&quot;CREATE EXTENSION fibonacci&quot;</span> <span class="keyword">to</span> <span class="keyword">load</span> this file. \quit</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> fibonacci(n <span class="built_in">INTEGER</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">INTEGER</span> <span class="keyword">AS</span> <span class="string">&#x27;$libdir/fibonacci&#x27;</span></span><br><span class="line"><span class="keyword">LANGUAGE</span> C IMMUTABLE <span class="keyword">STRICT</span>;</span><br></pre></td></tr></table></figure>

<p>接下来修改 <code>Makefile</code> 文件使其能正常编译我们的 fibonacci 插件的源文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXTENSION &#x3D; fibonacci        # the extensions name</span><br><span class="line">DATA &#x3D; fibonacci--0.0.2.sql  # script files to install</span><br><span class="line">REGRESS &#x3D; fibonacci_test     # our test script file (without extension)</span><br><span class="line">MODULES &#x3D; fibonacci</span><br><span class="line"></span><br><span class="line"># postgres build stuff</span><br><span class="line">PG_CONFIG &#x3D; pg_config</span><br><span class="line">PGXS :&#x3D; $(shell $(PG_CONFIG) --pgxs)</span><br><span class="line">include $(PGXS)</span><br></pre></td></tr></table></figure>

<p>注意，我们还需要修改 <code>fibonacci.control</code> 文件中的 <code>default_version</code> 为 <code>0.0.2</code>。现在我们便可以通过 <code>make install &amp;&amp; make installcheck</code> 来安装插件了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postgres&#x3D;# SELECT i, fibonacci(i) FROM generate_series(1,30) i;</span><br><span class="line"> i  | fibonacci</span><br><span class="line">----+-----------</span><br><span class="line">  1 |         1</span><br><span class="line">  2 |         1</span><br><span class="line">  3 |         2</span><br><span class="line">  4 |         3</span><br><span class="line">  5 |         5</span><br><span class="line">  6 |         8</span><br><span class="line">  7 |        13</span><br><span class="line">  8 |        21</span><br><span class="line">  9 |        34</span><br><span class="line"> 10 |        55</span><br><span class="line"> 11 |        89</span><br><span class="line"> 12 |       144</span><br><span class="line"> 13 |       233</span><br><span class="line"> 14 |       377</span><br><span class="line"> 15 |       610</span><br><span class="line"> 16 |       987</span><br><span class="line"> 17 |      1597</span><br><span class="line"> 18 |      2584</span><br><span class="line"> 19 |      4181</span><br><span class="line"> 20 |      6765</span><br><span class="line"> 21 |     10946</span><br><span class="line"> 22 |     17711</span><br><span class="line"> 23 |     28657</span><br><span class="line"> 24 |     46368</span><br><span class="line"> 25 |     75025</span><br><span class="line"> 26 |    121393</span><br><span class="line"> 27 |    196418</span><br><span class="line"> 28 |    317811</span><br><span class="line"> 29 |    514229</span><br><span class="line"> 30 |    832040</span><br><span class="line">(30 rows)</span><br><span class="line"></span><br><span class="line">Time: 2.280 ms</span><br><span class="line">postgres&#x3D;#</span><br></pre></td></tr></table></figure>

<p>从运行时间上看，C 语言版的斐波那契要比 PL/pgSQL 的运行速度快大约 80%。</p>
<p><strong>备注：</strong> 由于 C 语言插件在 PostgreSQL 中采用动态库的形式载入的，因此我们需要修改配置文件中的 <code>shared_preload_libraries</code> 参数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了如何使用 plpgsql 编写 PostgreSQL 的扩展插件，PostgreSQL 有两个基本的文件：</p>
<ul>
<li>extension.control - 插件控制文件</li>
<li>extension–version.sql - 用于创建扩展的脚本文件</li>
</ul>
<p>此外，我们可能还需要 <code>sql</code> 和 <code>expected</code> 目录用于存放回归测试用例及其结果。最后，为了提高插件的运行效率，我们将原来的 PL/pgSQL 版本采用 C 语言来实现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin">斐波那契数列</a><br>[2] <a href="http://big-elephants.com/2015-10/writing-postgres-extensions-part-i/">Writing Postgres Extensions - the Basics</a><br>[3] <a href="https://www.postgresql.org/docs/10/xfunc-c.html">PostgreSQL - C-Language Functions</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言数据类型</title>
    <url>/2019/06/C-data-types/</url>
    <content><![CDATA[<p>C 语言的数据类型可以分为七种，它们分别是原始类型（内建类型）、枚举类型、联合类型、结构体、数组、指针以及不完全类型。此外，本文还介绍了类型限定符、存储类型说明符以及类型重命名。</p>
<a id="more"></a>

<h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><p>C 语言提供的原始数据类型可以分为三类：a. 整数类型；b. 实数类型；c. 复数类型。接下来的部分将详细介绍这三类数据类型。</p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整数数据类型的大小范围从 8-bit 到 32-bit 之间。在 C99 标准中扩展到了 64-bit。我们应该使用整数数据类型来存储整数值，当然我们也可以用 <code>char</code> 类型来存储字符。下表给出了这些整数类型的最小范围，在不同的平台上这个范围可能还会更大。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>比特位</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>signed char</td>
<td>8</td>
<td>-128</td>
<td>127</td>
</tr>
<tr>
<td>unsigned char</td>
<td>8</td>
<td>0</td>
<td>255</td>
</tr>
<tr>
<td>char</td>
<td>8</td>
<td>-128/0</td>
<td>127/255</td>
</tr>
<tr>
<td>short int</td>
<td>16</td>
<td>-32,768</td>
<td>32,767</td>
</tr>
<tr>
<td>unsigned short int</td>
<td>16</td>
<td>0</td>
<td>65,535</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>-2,147,483,648</td>
<td>2,147,483,647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>32</td>
<td>0</td>
<td>4,294,967,295</td>
</tr>
<tr>
<td>long int</td>
<td>32/64</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned long int</td>
<td>32/64</td>
<td></td>
<td></td>
</tr>
<tr>
<td>long long int</td>
<td>64</td>
<td>-9,223,372,036,854,775,808</td>
<td>9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>unsigned long long int</td>
<td>64</td>
<td>0</td>
<td>18,446,744,073,709,551,615</td>
</tr>
</tbody></table>
<ul>
<li><strong>char</strong> - 该数据类型被定义为 <code>signed char</code> 或者 <code>unsigned char</code> 类型，这取决于不同的系统平台。</li>
<li><strong>short int</strong> - 该数据类型可以写为 <code>short</code>、<code>signed short int</code> 或 <code>signed short</code>。</li>
<li><strong>unsigned short int</strong> - 该数据类型可以简写为 <code>unsigned short</code>。</li>
<li><strong>int</strong> - 该数据类型可以写为 <code>signed int</code> 或 <code>signed</code>。</li>
<li><strong>unsigned int</strong> - 该数据类型可以简写为 <code>unsigned</code>。</li>
<li><strong>long int</strong> - 该数据类型的长度取决于您的系统，他可以是 32-bit 或 64-bit。它可以写为 <code>signed long int</code>、<code>signed long</code> 或 <code>long</code>。</li>
<li><strong>unsigned long int</strong> - 该数据类型与 <code>long int</code> 数据类型相似。它可以简写为 <code>unsigned long</code>。</li>
<li><strong>long long int</strong> - 该数据类型并非 C89 标准所定义，它是 C99 或 GNU C 标准中的一部分。它可以被写为 <code>signed long long int</code>、<code>signed long long</code> 或 <code>long long</code>。</li>
<li><strong>unsigned long long int</strong> - 该数据类型与 <code>long long int</code> 数据类型相似。它可以简写为 <code>unsigned long long</code>。</li>
</ul>
<h3 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h3><p>C 语言提供了三种类型用于表示小数（浮点数）。尽管目前来树这些类型的大小和范围在大多数计算机上都是一致的，但是历史上它们还是因为系统类型不一而存在差异。这些类型的最大值和最小值在 <code>float.h</code> 文件中通过宏的方式定义。</p>
<ul>
<li><code>float</code> - 三种浮点数类型中取值范围最小的类型（如果它们的大小不一致的情况）。其最小值由 <code>FLT_MIN</code> 给出，并且最小值不能大于 1e-37；最大值则由 <code>FLT_MAX</code> 给出，并且不能小于 1e37。</li>
<li><code>double</code> - 该数据类型至少应与 <code>float</code> 类型一样大，甚至可能超过 <code>float</code> 类型。其最小值和最大值分别由 <code>DBL_MIN</code> 和 <code>DBL_MAX</code> 给出。</li>
<li><code>long double</code> - 该数据类型至少应与 <code>float</code> 类型一样大，甚至可能超过 <code>float</code> 类型。其最小值和最大值分别由 <code>LDBL_MIN</code> 和 <code>LDBL_MAX</code> 给出。</li>
</ul>
<p>所有的浮点类型均为有符号，如果尝试使用无符号浮点类型，如 <code>unsigned float</code> 则会导致编译时错误。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat test.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned float a &#x3D; 0.0;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">$ gcc test.c</span><br><span class="line">test.c:6:3: error: &#39;float&#39; cannot be signed or unsigned</span><br><span class="line">  unsigned float a &#x3D; 0.0;</span><br><span class="line">  ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure>

<p>C 语言提供的实数是具有有限精度，因此，它并不能精确的表示所有实数。大多数采用 GCC 编译的计算机系统都采用二进制来表示实数，这就以为着它不能精确的表示某些数，例如 4.2。为此，在对浮点数进行比较时尽量不要使用 <code>==</code> 操作符，而是检测该数是否在可以容忍的误差范围内。</p>
<h3 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h3><p>GCC 在 C89 的基础上引入了复数类型，同样的，C99 中也增加了复数类型，但是它们之间由许多不同之处。接下来我们将先介绍标准库中的复数类型，随后再介绍 GNU 扩展中的复数类型。</p>
<h4 id="标准复数类型"><a href="#标准复数类型" class="headerlink" title="标准复数类型"></a>标准复数类型</h4><p>复数类型在 C99 标准中引入，它有以下三种类型：</p>
<ul>
<li><code>float _Complex</code></li>
<li><code>double _Complex</code></li>
<li><code>long double _Complex</code></li>
</ul>
<p>该类型以下划线和大写字母开头主要是为了避免与现有程序冲突。在 C99 标准库的 <code>&lt;complex.h&gt;</code> 头文件中定义了一系列宏使得复数的使用更为方便。例如，<code>complex</code> 将被扩展为 <code>_Complex</code>，这使得形如 <code>double complex</code> 的变量声明看起来更自然一些; <code>I</code> 为 <code>const float _Complex</code> 类型的常量，用以表示复数的虚数部分的单位，也可以写作 <code>i</code>。</p>
<p><code>&lt;complex.h&gt;</code> 头文件还包含了许多用于复数计算的函数，如 <code>creal</code> 和 <code>cimag</code> 分别用于获取复数的实数部分和虚数部分。</p>
<h4 id="GNU-扩展的复数类型"><a href="#GNU-扩展的复数类型" class="headerlink" title="GNU 扩展的复数类型"></a>GNU 扩展的复数类型</h4><p>GCC 也为 C89 标准引入了复数类型。它与标准的复数类型拼写不太一样。其形式如下所示：</p>
<ul>
<li><code>__complex__ float</code></li>
<li><code>__complex__ double</code></li>
<li><code>__complex__ long double</code></li>
</ul>
<p>GCC 复数类型的扩展不仅限于复数类型，因此你可以定义复数字符类型和复数整型类型；实际上 <code>__complex__</code> 可以应用于任何原始类型之上。例如：</p>
<ul>
<li><code>__complex__ float</code> - 该数据类型包含两个部分，实数部分和虚数部分；实数部分和虚数部分均为 <code>float</code> 数据类型。</li>
<li><code>__complex__ int</code> - 该数据类型同样包含两个部分，实数部分和虚数部分；实数部分和虚数部分均为 <code>int</code> 数据类型。</li>
</ul>
<p>在 GCC 扩展中，我们可以使用 <code>__real__</code> 和 <code>__imag__</code> 来获取复数的实数部分和虚数部分。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__complex__ <span class="keyword">float</span> a = <span class="number">4</span> + <span class="number">3</span>i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> b = __real__ a;        <span class="comment">/* b 现在为 4 */</span></span><br><span class="line"><span class="keyword">float</span> c = __imag__ a;        <span class="comment">/* c 现在为 3 */</span></span><br></pre></td></tr></table></figure>

<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型是一种自定义类型，它用于存储整型常量值并通过名称来引用。默认情况下，枚举类型值的数据类型为 <code>signed int</code>；你可以使用 GCC 编译器的 <code>-fshort-enums</code> 选项来使用尽可能小的整型类型。这两种行为都符合 C89 标准，但是在同一个程序中混合使用这些选项可能导致不兼容。</p>
<h3 id="定义枚举类型"><a href="#定义枚举类型" class="headerlink" title="定义枚举类型"></a>定义枚举类型</h3><p>枚举类型通过关键字 <code>enum</code> 进行定义，后面紧跟枚举类型的名称（可以省略，此时为匿名的枚举类型），然后是由逗号分割开的枚举值（枚举值放在括号内），最后是代表结束的分号。如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> friut &#123; grape, cherry, lemon, kiwi &#125;;</span><br></pre></td></tr></table></figure>

<p>上述示例定义了 <code>friut</code> 的枚举类型，它包含 <code>grape</code>，<code>cherry</code>，<code>lemon</code> 和<code>kiwi</code> 四个整型，它们的值分别为 <code>0</code>，<code>1</code>，<code>2</code>，和 <code>3</code>。当然，你也可以指定一个或多个枚举类型的值，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> more_friut &#123; banana = <span class="number">-17</span>, apple, blueberry, mango &#125;;</span><br></pre></td></tr></table></figure>

<p>上述示例中定义的 <code>banana</code> 的值为 <code>17</code>，其它值依次加 <code>1</code>：即 <code>apple = -16</code>，<code>blueberry = -15</code>，<code>mango = -14</code>。除非特别说明，枚举类型的值为前一个值加 <code>1</code>（第一个值默认为 <code>0</code>）。此外，你还可以引用在该枚举中已经定义了的值，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> yet_more_fruit &#123; kumquat, raspberry, peach, plum = peach + <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上述示例中 <code>kumquat = 0</code>，<code>raspberry = 1</code>，<code>peach = 2</code>，<code>plum = 4</code>。</p>
<h3 id="声明枚举类型"><a href="#声明枚举类型" class="headerlink" title="声明枚举类型"></a>声明枚举类型</h3><p>你可以在定义枚举类型的同时声明枚举类型变量，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> fruit &#123; banana, apple, blueberry, mango &#125; my_fruit;</span><br></pre></td></tr></table></figure>

<p>当然，你也可以将定义和变量声明分离开，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> fruit &#123; banana, apple, blueberry, mango &#125;;</span><br><span class="line"><span class="keyword">enum</span> fruit my_fruit;</span><br></pre></td></tr></table></figure>

<p>需要注意的是你不能声明匿名的枚举类型。</p>
<p>虽然它们被视为枚举类型的变量，但是你仍然可以为它们赋值任何整型值包括来自其它枚举类型的值。但是当枚举类型的值确定之后，你就不能再更改它，它们将被视为常量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> fruit &#123; banana, apple, blueberry, mango &#125;;</span><br><span class="line">banana = <span class="number">15</span>;  <span class="comment">/* 你无法为 banana 赋值新值 */</span></span><br></pre></td></tr></table></figure>

<p>枚举类型与 <code>switch</code> 语句结合起来相当有用，这是因为当在 <code>switch</code> 中只处理了部分枚举类型值时，编译器将会给出警告。</p>
<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型同样属于一种自定义类型，它用于在同一内存空间存储多个变量。你可以随时访问这些变量中的任何一个，其实每次我们应该只读取其中一个变量，由它的定义可以看出，当修改这些变量中的某一个时，其它变量也会发生变化。</p>
<h3 id="定义联合类型"><a href="#定义联合类型" class="headerlink" title="定义联合类型"></a>定义联合类型</h3><p>联合类型通过关键字 <code>union</code> 进行定义，后跟由打括号包围起来的联合类型成员，联合类型的成员定义则与普通变量的定义类似。在 <code>union</code> 和开始大括号之间可以指定联合的名称（可选，如果不指定后续则无法引用，除非使用 <code>typedef</code> 语法）。下面是一个简单的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> numbers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="声明联合类型"><a href="#声明联合类型" class="headerlink" title="声明联合类型"></a>声明联合类型</h3><p>如果在定义联合类型时给出了名称，那么我们可以在定义的同时或者定义之后声明联合类型变量。</p>
<h4 id="定义时声明变量"><a href="#定义时声明变量" class="headerlink" title="定义时声明变量"></a>定义时声明变量</h4><p>例如，我们可以采用如下形式在定义联合类型的同时声明变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> numbers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125; first_num, second_num;</span><br></pre></td></tr></table></figure>

<p>上面的示例声明了两个 <code>union numbers</code> 类型的变量：<code>first_num</code> 和 <code>second_num</code>。</p>
<h4 id="定义后声明变量"><a href="#定义后声明变量" class="headerlink" title="定义后声明变量"></a>定义后声明变量</h4><p>当然，我们也可以将定义与变量声明分割开来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> numbers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> numbers first_num, second_num;</span><br></pre></td></tr></table></figure>

<p>上面的形式与定义时声明变量的效果一致。</p>
<h4 id="初始化联合类型成员"><a href="#初始化联合类型成员" class="headerlink" title="初始化联合类型成员"></a>初始化联合类型成员</h4><p>我们在声明变量的时候也可以对其进行初始化操作。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> numbers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> numbers first_num = &#123; <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面的示例将 <code>union numbers</code> 类型的 <code>first_num</code> 变量的第一个成员 <code>i</code> 初始化为 <code>5</code>。除此之外，我们还可以初始化指定的联合类型成员，有两种方式用于初始化联合类型成员。</p>
<ul>
<li><code>member: value</code> - 成员名 + <code>:</code> 的形式，例如：<code>union numbers first_num = &#123; f: 3.14 &#125;;</code>。</li>
<li><code>.member = value</code> - <code>.</code> + 成员名 + <code>=</code> 的形式，例如：<code>union numbers first_num = &#123; .f = 3.14&#125;</code>。</li>
</ul>
<p>当然，我们也可以在定义的同时声明变量并进行初始化。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> numbers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125; first_num = &#123; <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="访问联合类型"><a href="#访问联合类型" class="headerlink" title="访问联合类型"></a>访问联合类型</h3><p>对联合类型的访问通过访问操作符来完成，即将联合类型的变量放在访问操作符的左边，联合类型的成员名放在访问操作符的右边。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">union numbers</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    float f;</span><br><span class="line">&#125;;</span><br><span class="line">union numbers first_num;</span><br><span class="line">first_num.i &#x3D; 3;</span><br><span class="line">first_numb.f &#x3D; 4.123;</span><br></pre></td></tr></table></figure>

<p>需要注意的时，当需改联合类型的 <code>f</code> 成员时，成员 <code>i</code> 的值相应的也发生了改变。</p>
<h3 id="联合类型大小"><a href="#联合类型大小" class="headerlink" title="联合类型大小"></a>联合类型大小</h3><p>联合类型的大小取决于联合类型成员中占空间最大的成员。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">union numbers</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    float f;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该联合类型的大小为 <code>sizeof(float)</code> 的大小，因为 <code>float</code> 比 <code>int</code> 所占空间大。由于在联合中所有的数据成员共享同一地址空间，因此，只需要该空间能存储联合类型中占空间最大的成员即可。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体是由程序员定义数据类型，该数据类型由变量和其它数据类型（可能包含其它结构体）组成。</p>
<h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><p>结构体的定义与联合类型相似，所不同的是结构体的定义使用 <code>struct</code> 关键字。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的定义中我们定义了一个 <code>struct point</code> 的新类型，该类型包含两个成员：<code>x</code> 和 <code>y</code>，它们均为 <code>double</code> 类型。结构体（或联合类型）都可以包含其它结构体或者联合类型，但是不能包含自身。但是，它们可以包含自身类型的指针（参见不完全类型）。</p>
<h3 id="声明结构体变量"><a href="#声明结构体变量" class="headerlink" title="声明结构体变量"></a>声明结构体变量</h3><p>结构体变量的声明与联合类型一样，可以在定义时或定义之后声明。</p>
<h4 id="定义时声明变量-1"><a href="#定义时声明变量-1" class="headerlink" title="定义时声明变量"></a>定义时声明变量</h4><p>与联合类型类似，我们可以在定义结构体时声明变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125; first_point, second_point;</span><br></pre></td></tr></table></figure>

<h4 id="定义后声明变量-1"><a href="#定义后声明变量-1" class="headerlink" title="定义后声明变量"></a>定义后声明变量</h4><p>当然，我们也可以将定义与变量声明分割开来。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">first_point</span>, <span class="title">second_point</span>;</span></span><br></pre></td></tr></table></figure>

<h4 id="初始化结构体变量"><a href="#初始化结构体变量" class="headerlink" title="初始化结构体变量"></a>初始化结构体变量</h4><p>当你在声明结构体变量时可以为结构体成员变量初始化特定的值。如果你没有为结构体提供初始化值，那么它的值取决于是否有静态存储（后续介绍）。如果有，那么整型被初始化为 <code>0</code>，指针类型初始化为 <code>NULL</code>;其它情况下成员变量的值是不确定的。初始化成员变量的一种方式是在大括号中按定义时的顺序给出成员的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">first_point</span> = &#123;</span> <span class="number">5.0</span>, <span class="number">4.0</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>另一种初始化成员变量的方式是按成员变量名进行初始化。采用这种方式进行初始化可以按任意顺序进行初始化，并且可以保留部分成员不初始化。按成员变量名称初始化也有两种方式：</p>
<ul>
<li><code>.member = value</code> - C99 标准以及 GCC 的 C89 扩展。例如：<code>struct point first_point = &#123; .y = 10.0, .x = 5.0 &#125;;</code>。</li>
<li><code>member: value</code> - GNU C 扩展。例如：<code>struct point first_point = &#123; y: 10.0, x: 5.0 &#125;;</code>。</li>
</ul>
<p>同样地，我们可以在定义结构体时声明变量并进行初始化操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125; first_point = &#123; <span class="number">5.0</span>, <span class="number">4.0</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以只初始化部分成员变量。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pointy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pointy</span> <span class="title">first_pointy</span> = &#123;</span> <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>x</code> 被初始化为 <code>5</code>，<code>y</code> 被初始化为 <code>0</code>，<code>p</code> 被初始化为 <code>NULL</code>。这里的规则就是 <code>y</code> 和 <code>p</code> 采用静态存储的初始化规则。</p>
<p>当结构体中包含结构体时，我们同样可以对其进行初始化。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">top_left</span>, <span class="title">bottom_right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">my_rectangle</span> = &#123;</span> &#123;<span class="number">1.0</span>, <span class="number">10.0</span>&#125;, &#123;<span class="number">5.0</span>, <span class="number">4.0</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个 <code>struct rectangle</code> 结构体，它包含两个 <code>struct point</code> 类型的成员变量。在初始化的过程中我们使用大括号来区分不同的结构体成员，其实这个大括号是可以省略的（可读性不强）。</p>
<h3 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h3><p>结构体成员的访问与联合类型相似。例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">first_point</span>;</span></span><br><span class="line"></span><br><span class="line">first_point.x = <span class="number">0.0</span>;</span><br><span class="line">first_point.y = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>

<p>如果结构体中还包含结构体，我们同样可以使用这样方式进行访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">top_left</span>, <span class="title">bottom_right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">my_rectangle</span>;</span></span><br><span class="line"></span><br><span class="line">my_rectangle.top_left.x = <span class="number">0.0</span>;</span><br><span class="line">my_rectangle.top_left.y = <span class="number">5.0</span>;</span><br><span class="line"></span><br><span class="line">my_rectangle.bottom_right.x = <span class="number">10.0</span>;</span><br><span class="line">my_rectangle.bottom_right.y = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><p>在结构体中，我们可以为整型添加一个整数值来告知其不实用标准的字节大小，这种方式被称为位域。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">card</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> suit : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> face_value : <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的示例中定义了两个位域字段：<code>suit</code> 和 <code>face_value</code>，它们的位长度分别为 <code>2-bit</code> 和 <code>4-bit</code>，它们的取值范围分别为 <code>0~3</code> 和 <code>0~15</code>（无符号数）。如果它们被定义为有符号数，则其取值范围分别为 <code>-2~1</code> 和 <code>-8~7</code>。</p>
<p>我们可以采用通项来进行表示，<code>N-bit</code> 的位域字段可以表示的范围为：</p>
<ul>
<li>无符号数 - $[0, 2^N-1]$</li>
<li>有符号数 - $[-\frac{2^N}{2}, \frac{2^N}{2}-1]$</li>
</ul>
<p>我们可以使用匿名的位域字段（即没有名称），这样做的目的主要是为了控制那些位可以使用，然而，这种方式可能移植性不是很好且很少使用。此外，我们还可以定义大小为 <code>0</code> 的位域字段，这表示后续的位域字段不与前面的位域字段使用同一个单元，这通常也是没有多大用处。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zero_bit_test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>    bit1 : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>         : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>    bit2 : <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>上述示例的结构体大小为 8 字节。</li>
<li>你不能对位域字段进行取地址运算 (<code>&amp;</code> 操作符)。</li>
</ol>
<h3 id="结构体大小"><a href="#结构体大小" class="headerlink" title="结构体大小"></a>结构体大小</h3><p>结构体的大小等于结构体中所有成员的大小之和，除此之外，它还可能包含用于特定字节对齐的填充字节。根据不同的计算机类型，某些细节可能不同，但是 4 字节和 8 字节对齐是经常见到的。这样做的目的是为了加快结构体类型的存储访问。</p>
<p>作为 GNU 的扩展，GCC 允许没有成员的结构体，即其大小为 <code>0</code>。如果你想要显示的去掉结构体的填充字节（这可能会降低结构体内存的访问速度），GCC 提供了多种方式。最简单的方式就是通过使用 <code>-fpack-struct</code> 选项。关于更多的填充细节可以参考 GCC 的文档（见扩展阅读 [3]）。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一种允许在连续的内存空间中存储一个或多个元素。C 语言的数组以 0 作为开始索引。</p>
<h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><p>数组的声明由元素的数据类型，数组名以及元素个数组成。例如，<code>int my_array[10];</code>。标准的 C 代码中，数组的元素个数必须为正数。而在 GNU 扩展中，数组的元素个数最小可以为 0。长度为 0 的数组在结构体中作为最后一个成员对于定义变长对象非常有用。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">char</span> contents[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">line</span> *<span class="title">this_line</span> = (<span class="title">struct</span> <span class="title">line</span> *)</span></span><br><span class="line"><span class="class">        <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">line</span>) + <span class="title">this_length</span>);</span></span><br><span class="line">    this_line-&gt;length = this_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个 GNU 扩展是支持使用变量定义数组长度，而在标准 C 中仅支持常量。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">my_function (<span class="keyword">int</span> number)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> my_array[number];</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><p>你可以在声明数组变量的时候给它提供一组初始化值进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[<span class="number">5</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>当然，你也可以只初始化部分值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[<span class="number">5</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例中 <code>my_array</code> 的前三个值分别初始化为 <code>1</code>，<code>2</code>，<code>3</code>，剩余的两个则被初始化为 <code>0</code>。</p>
<p>在 C99 标准或 C89 的 GNU 扩展中支持乱序初始化，即指定需要初始化的元素下标以及初始值。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[<span class="number">5</span>] = &#123; [<span class="number">4</span>] <span class="number">1</span>, [<span class="number">2</span>] <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> my_array[<span class="number">5</span>] = &#123; [<span class="number">4</span>] = <span class="number">1</span>, [<span class="number">2</span>] = <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> my_array[<span class="number">5</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上述三种声明方式的效果是一样的。在 GNU 中，数组还支持范围的初始化，即将一个范围内的值初始化为同一个值。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[<span class="number">100</span>] = &#123; [<span class="number">0</span> ... <span class="number">9</span>] = <span class="number">1</span>, [<span class="number">10</span> ... <span class="number">98</span>] = <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上述示例中将 <code>my_array</code> 的 <code>0</code> 到 <code>9</code> 的值初始化为 <code>1</code>；将下标 <code>10</code> 到 <code>98</code> 的值初始化为 <code>2</code>，同时将最后一个元素初始化为 <code>4</code>。这里需要注意的是在下标与 <code>...</code> 之间必须要有空格。</p>
<p>如果你在初始化是对所有元素都进行了初始化，那么你可以不需要指定数组的大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上述示例中声明了一个长度为 <code>5</code> 的数组，其值被初始化为 <code>0</code>，<code>1</code>，<code>2</code>，<code>3</code>，<code>4</code>。此外，如果你通过元素下标的方式进行初始化，那么数组的长度将是最大的下标加 <code>1</code>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, [<span class="number">99</span>] = <span class="number">99</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上述示例中声明了一个长度为 <code>100</code> 的数组，其前三个值为 <code>0</code>，<code>1</code>，<code>2</code>；最后一个值为 <code>99</code>；其余得知则被初始化为 <code>0</code>。</p>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>数组元素的访问是通过数组变量名以及数组下标的方式进行访问的。这里再次强调数组下标由 <code>0</code> 开始。例如，对 <code>my_array</code> 数组的第一个值赋值，其形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_array[<span class="number">0</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>C 语言中多维数组的声明是在数组的基础之上在加数组符号及其长度，即数组的数组。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> two_dimensions[<span class="number">2</span>][<span class="number">5</span>] = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>上面的示例声明了一个二维数组。多维数组的元素访问与一维数组类型，<code>two_dimensions[0][1] = 4</code>。</p>
<p>需要注意的是在 C 语言中，多维数组是按行的方式进行存储的，即 <code>two_dimensions[0][2]</code> 之后紧跟的元素是 <code>two_dimensions[0][3]</code>，而不是 <code>two_dimensions[1][2]</code>。</p>
<h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><p>你可以使用字符的数组来存储字符串，该数组可以由有符号字符和无符号字符组成。正如前面介绍，当你在声明数组时，你可以指定数组的大小，此时字符串的大小（包括用于表示结束的 <code>null</code> 字符）不能超过数组的大小，如果采用这样方式声明字符串数组，可以不必立即初始化；当然你也可以指定初始化值而不给出数组大小，此时系统将为你分配足够的空间用于存储数组元素。</p>
<p>字符串数组的初始化有两种方式：(a) 使用逗号分割的字符数组；(b) 使用字符串常量。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> blue[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">char</span> yellow[<span class="number">26</span>] = &#123;<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> orange[<span class="number">26</span>] = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> gray[] = &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> salmon[] = <span class="string">&quot;salmon&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>无论是上述那种情况，即便是没有显示的给出结束符（<code>\0</code>），字符数组也将会在字符的结尾添加结束符。需要注意的时，如果采用单个字符数组的方式进行初始化字符串，则末尾的结束符号不一定会有，它可能存在，也可能不存在，因此最好不要依赖这个特性。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> bad_str[<span class="number">4</span>] = &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>当初始化完成之后，你不能通过赋值操作符为其赋予新的字符串，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> lemon[<span class="number">26</span>] = <span class="string">&quot;custard&quot;</span>;</span><br><span class="line">lemon = <span class="string">&quot;steak sauce&quot;</span>;      <span class="comment">/* 失败 */</span></span><br></pre></td></tr></table></figure>

<p>在使用字符数组时可能存在你给定了数组的大小，但是使用了更大的字符串进行初始化；此时超出的部分并不会重写已经写入数组的内容，而你将在编译时得到警告。由于原始数组大小仍然存在，因此超出原始大小的字符串的任何部分都将写入未分配给它的内存位置。</p>
<h3 id="联合类型数组"><a href="#联合类型数组" class="headerlink" title="联合类型数组"></a>联合类型数组</h3><p>你可以像创建基本类型数组一样创建联合类型的数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> numbers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> numbers number_array[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>其初始化的方式为 <code>union numbers number_array[3] = &#123; &#123;3&#125;, &#123;4&#125;, &#123;5&#125; &#125;;</code>。其中数组内部的大括号是可以省略的，其访问形式同普通类型一样。</p>
<h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><p>同样地，你也可以为结构体声明数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">point_array</span>[3];</span></span><br></pre></td></tr></table></figure>

<p>上述示例中声明了一个结构体变量 <code>point_array</code>，该变量包含三个 <code>struct point</code> 元素。当然，我们也可以声明变量的时候同时初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">point_array</span>[3] = &#123;</span> &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>其中，结构体元素的初始化可以省略其中的大括号，而结构体数组的元素访问同联合类型一样。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针保存了存储常量和变量的内存地址。对于任何数据类型，包括基本类型和自定义类型，您都可以创建一个指针来保存该类型实例的内存地址。</p>
<h3 id="声明指针变量"><a href="#声明指针变量" class="headerlink" title="声明指针变量"></a>声明指针变量</h3><p>指针的声明与其它变量声明类型包括数据类型和变量名，数据类型代表了指针所指向的内存空间存储的变量类型。指针的声明需要在数据类型和变量名称之间加上间接运算符，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">data-type * name;</span><br></pre></td></tr></table></figure>

<p>间接运算符之间的空白字符无关紧要。下面的形式与上面的效果是一样的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">data-type *name;</span><br><span class="line">data-type* name;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，当在一个语句中声明多个指针变量时需要在每个变量名之前加上间接运算符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *foo, *bar;  <span class="comment">/* 两个指针 */</span></span><br><span class="line"><span class="keyword">int</span> *baz, quux;   <span class="comment">/* 一个指针以及一个整型变量 */</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化指针变量"><a href="#初始化指针变量" class="headerlink" title="初始化指针变量"></a>初始化指针变量</h3><p>指针变量的初始化需要用到取地址运算符。我们可以在变量声明的时候对其进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> *ip = &amp;i;</span><br></pre></td></tr></table></figure>

<p>存储在指针变量的内容是一个整型值，它表示计算机内存的地址。在声明变量之后如果需要对指针变量进行赋值，此时就不再需要间接运算符了。如果在后续过程中使用了间接运算符，那么改变的将是指针所指向的变量的值而不是指针变量本身。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">int</span> *ip = &amp;i;  <span class="comment">/* 变量 ip 现在存储的是变量 i 的地址 */</span></span><br><span class="line">ip = &amp;j;       <span class="comment">/* 变量 ip 现在存储的是变量 j 的地址 */</span></span><br><span class="line">*ip = &amp;i;      <span class="comment">/* 变量 j 现在存储的是变量 i 的地址 */</span></span><br></pre></td></tr></table></figure>

<p>最要的是如果你没有使用一个对象的地址对指针变量进行初始化，那么它所指向的地方是不确定的，这时使用该指针变量可能导致程序崩溃（通常来说，这种情况被称为__未定义行为 - undefined behavior__）。</p>
<h3 id="联合类型指针"><a href="#联合类型指针" class="headerlink" title="联合类型指针"></a>联合类型指针</h3><p>联合类型的指针变量同原始类型一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> numbers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> numbers foo = &#123;<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">union</span> numbers *number_ptr = &amp;foo;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以通过指针变量实现对联合类型的成员访问，但是我们不能使用常规的成员访问符而需要使用间接成员访问符。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">number_ptr-&gt;i = <span class="number">500</span>;</span><br></pre></td></tr></table></figure>

<h3 id="结构体类型指针"><a href="#结构体类型指针" class="headerlink" title="结构体类型指针"></a>结构体类型指针</h3><p>结构体类型的指针变量与联合类型一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> length, weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">salmon</span> = &#123;</span><span class="number">4.3</span>, <span class="number">5.8</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> *<span class="title">fish_ptr</span> = &amp;<span class="title">salmon</span>;</span></span><br><span class="line"></span><br><span class="line">fish_ptr-&gt;length = <span class="number">5.1</span>;</span><br><span class="line">fish_ptr-&gt;weight = <span class="number">6.3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="不完全类型"><a href="#不完全类型" class="headerlink" title="不完全类型"></a>不完全类型</h2><p>当在定义结构体、联合类型以及枚举类型时不指定其成员（对于枚举类型来说即枚举值），这种类型被称为不完全类型 (incomplete type)。你不可以定义不完全类型的变量，但是可以定义不完全类型的指针。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>;</span></span><br></pre></td></tr></table></figure>

<p>上面定义了一个不完全类型，在给出该类型的完全定义之前，我们不能使用它定义变量，你需要在后续给出该类型的完整定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种不完全类型通常用于链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">singly_linked_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">singly_linked_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="comment">/* 其它元素 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">singly_linked_list</span> *<span class="title">list_head</span>;</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>[1] What Every Computer Scientist Should Know About Floating-Point Arithmetic<br>[2] section 4.2.2 of Donald Knuth’s The Art of Computer Programming.<br>[3] <a href="https://gcc.gnu.org/onlinedocs/gcc-9.1.0/gcc/Code-Gen-Options.html#Code-Gen-Options">https://gcc.gnu.org/onlinedocs/gcc-9.1.0/gcc/Code-Gen-Options.html#Code-Gen-Options</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Data-Types">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Data-Types</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言语句</title>
    <url>/2019/10/C-statements/</url>
    <content><![CDATA[<p>C 语言提供了语句用以控制程序的执行流程。您可以编写不执行任何操作的语句，当然也可以编写执行毫不相关的语句（没有任何意义）。本文主要介绍 C 语言所提供的一些语句类型，它们分别是：</p>
<ol start="0">
<li>空语句 - 即形如 <code>;</code> 这样的语句；</li>
<li>块语句 - 用括号括起来的一组零个或多个语句；</li>
<li>条件语句 - __if__；</li>
<li>返回语句 - __return__；</li>
<li>循环语句 - __do__、__while__、__for__；</li>
<li>开关语句 - <strong>switch__，与 __case</strong> 结合使用；</li>
<li>标签语句 - <strong>labels:__，通常与 __goto</strong> 结合使用；</li>
<li>跳转语句 - __goto__、__break__、__continue__，后两者用于循环语句中；</li>
<li>表达式语句 - 例如 <code>a += 10</code>；</li>
<li>类型定义语句 - __typedef__；</li>
</ol>
<a id="more"></a>

<h2 id="标签语句-（Labels）"><a href="#标签语句-（Labels）" class="headerlink" title="标签语句 （Labels）"></a>标签语句 （Labels）</h2><p>我们可以使用标签来标示一部分源代码，以便后续通过 <strong>goto</strong> 语句来使用。标签由标识符以及紧随其后的冒号组成。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">treet:</span><br></pre></td></tr></table></figure>

<p>标签名不会影响其它标识符名称，例如，我们可以按如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> treet = <span class="number">5</span>;    <span class="comment">/* 名为 treet 的变量 */</span></span><br><span class="line">treet:            <span class="comment">/* 名为 treet 的标签 */</span></span><br></pre></td></tr></table></figure>

<p>在 ISO C 的标准中，标签后面必须跟至少一个语句，可以是空语句。GCC 则支持标签后不带任何语句。在编写可移植性的代码时需要注意这一点。</p>
<h2 id="表达式语句（Expression-Statements）"><a href="#表达式语句（Expression-Statements）" class="headerlink" title="表达式语句（Expression Statements）"></a>表达式语句（Expression Statements）</h2><p>表达式语句通过在表达式末尾附加一个分号构成。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>;</span><br><span class="line"><span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"><span class="number">10</span> &gt;= <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，所有的表达式在执行时都将被求值，但是这些求值结果由于没有保存，因此会被丢弃。编译器可能会忽略这些语句。</p>
<p>仅当表达式语句具有某种副作用（例如存储值，调用函数）或导致程序错误时，它才有用。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x++;</span><br><span class="line">y = x + <span class="number">25</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Hello, user!&quot;</span>);</span><br><span class="line">*cucumber;</span><br></pre></td></tr></table></figure>

<p>如果 <code>cucumber</code> 即不是有效的指针并且被声明为 <code>volatile</code>，那么最后一个语句 <code>*cucumber*</code> 可能会导致潜在的程序错误。</p>
<h2 id="条件语句（if）"><a href="#条件语句（if）" class="headerlink" title="条件语句（if）"></a>条件语句（if）</h2><p>我们可以使用条件语句来根据表达式的真假情况有选择的执行程序的一部分。其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (test)</span><br><span class="line">    then-statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">else</span>-statement</span><br></pre></td></tr></table></figure>

<p>若 <code>test</code> 求值结果为 <code>true</code>，那么程序将执行 <code>then-statment</code> 语句；反之，程序将执行 <code>else-statement</code> 语句。<code>else</code> 部分是可选的。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;x is 10&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果表达式 <code>x == 10</code> 为 <code>true</code>，那么将执行 <code>puts(&quot;x is 10&quot;);</code> 语句。如果表达式 <code>x == 10</code> 为 <code>false</code>，那么 <code>puts(&quot;x is 10&quot;);</code> 将不会被执行。</p>
<p>下面的例子展示了 <code>else</code> 字句的使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;x is 10&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;x is not 10&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们还可以使用一系列 <code>if</code> 语句来测试多个条件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is 1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is 2&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is 3&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is something else&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>下面的函数用于计算给你年份 <code>y</code> 的复活节日期：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">easterDate (<span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> g = (y % <span class="number">19</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = (y / <span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x = ((<span class="number">3</span> * c) / <span class="number">4</span>) - <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> z = (((<span class="number">8</span> * c) + <span class="number">5</span>) / <span class="number">25</span>) - <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> d = ((<span class="number">5</span> * y) / <span class="number">4</span>) - x - <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> e = ((<span class="number">11</span> * g) + <span class="number">20</span> + z - x) % <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((e == <span class="number">25</span>) &amp;&amp; (g &gt; <span class="number">11</span>)) || (e == <span class="number">24</span>))</span><br><span class="line">        e++;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">44</span> - e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">21</span>)</span><br><span class="line">        n += <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    n = n + <span class="number">7</span> - ((d + n) % <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">31</span>)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Easter: %d April %d&quot;</span>, n - <span class="number">31</span>, y);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Easter: %d March %d&quot;</span>, n, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开关语句（switch）"><a href="#开关语句（switch）" class="headerlink" title="开关语句（switch）"></a>开关语句（switch）</h2><p>我们可以使用 <code>switch</code> 语句将一个表达式与其他表达式进行比较，然后根据比较结果执行一系列子语句。其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> compare<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">if</span>-equal-statement<span class="number">-1</span></span><br><span class="line">    <span class="keyword">case</span> compare<span class="number">-2</span>:</span><br><span class="line">        <span class="keyword">if</span>-equal-statement<span class="number">-2</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">default</span>-statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch</code> 语句将 <code>test</code> 表达式的结果与每一个 <code>compare</code> 表达式进行比较，直到它找到与 <code>test</code> 表达式结果相等的 <code>compare</code>。接着，程序将执行这个 <code>compare</code> 表达式之后的语句。所有的 <code>compare</code> 表达式都必须是整型并且为常量整型（即，文字整数或由文字整数构建的表达式）。</p>
<p>我们可以在 <code>switch</code> 语句中给出一个可选的 <code>default</code> 字句。如果 <code>test</code> 表达式与 <code>default</code> 前的 <code>compare</code> 表达式均不匹配时，<code>default</code> 字句后的语句将被执行。通常，<code>default</code> 放在 <code>switch</code> 语句的末尾，但这不是必须的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;x is 0&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;x is 1&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;x is something else&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意每个 <code>case</code> 语句后的 <code>break</code> 语句，这是因为，一旦找到匹配的 <code>case</code> 语句，不仅会执行其后语句，还会执行该 <code>case</code>语句后其它 <code>case</code> 语句下的所有语句。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;x is 0&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;x is 1&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;x is something else&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例代码将输出下面的结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x is <span class="number">0</span></span><br><span class="line">x is <span class="number">1</span></span><br><span class="line">x is something <span class="keyword">else</span></span><br></pre></td></tr></table></figure>

<p>这通常不是我们所期望的。在每个 <code>case</code> 语句的末尾包含一个 <code>break</code> 语句可以将程序流重定向到 <code>switch</code> 语句之后。</p>
<p>GNU C 支持在单个的 <code>case</code> 语句中指定一个连续的整数范围，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> low ... high:</span><br></pre></td></tr></table></figure>

<p>这与包含相同个数的 <code>case</code> 语句具有相同的含义。即：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> low:</span><br><span class="line"><span class="keyword">case</span> low + <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> ...:</span><br><span class="line"><span class="keyword">case</span> high - <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> high:</span><br></pre></td></tr></table></figure>

<p>这个特性同样可以应用于 ASCII 字符集：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> ... <span class="string">&#x27;Z&#x27;</span>:</span><br></pre></td></tr></table></figure>

<p>请注意在 <code>...</code> 周围包含空格，否则可能在与整数一起使用时会出现解析错误。即，我们需要写成<code>case 1 ... 5:</code> 而不是 <code>case 1...5:</code>。</p>
<p>通常我们使用 <code>switch</code> 语句来处理 <code>errno</code> 的各种可能值。</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句可以用于重复的执行某段代码，C 语句提供了三种基本的循环语句，<code>while</code>、<code>do</code> 和 <code>for</code>。接下来我们将分别介绍这三种循环语句。</p>
<h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p><code>while</code> 循环语句在循环开始时进行退出测试，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (test)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<p><code>while</code> 语句首先对 <code>test</code> 表达式求值。若结果为 <code>true</code>，那么将执行 <code>statement</code> 语句，随后再一次对 <code>test</code> 表达式求值；只要 <code>test</code> 表达式为 <code>true</code>，那么将一直执行 <code>statement</code> 语句。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (counter &lt; <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, counter++);</span><br></pre></td></tr></table></figure>

<p>此外，<code>break</code> 语句也可以用于退出当前循环。</p>
<h3 id="do-语句"><a href="#do-语句" class="headerlink" title="do 语句"></a>do 语句</h3><p><code>do</code> 循环语句是在循环末尾进行退出测试，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">while</span> (test)</span><br></pre></td></tr></table></figure>

<p><code>do</code> 语句首先执行 <code>statement</code> 语句，随后对 <code>test</code> 表达式求值。若结果为 <code>true</code>，那么继续执行 <code>statement</code> 语句。<code>statement</code> 仅在 <code>test</code> 表达式结果为 <code>false</code> 的时候退出。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, x++);</span><br><span class="line"><span class="keyword">while</span> (x &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>同样地，我们可以使用 <code>break</code> 语句来提前终止循环。</p>
<h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><p><code>for</code> 循环语句其结构允许简单的变量初始化，表达式测试和变量修改，它可以很方便地进行计数器的循环控制，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialize; test; step)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<p><code>for</code> 语句首先执行 <code>initialize</code> 表达式，接着执行 <code>test</code> 表达式，如 <code>test</code> 表达式结果为 <code>false</code>，那么程序将退出 <code>for</code> 循环。否则，如果 <code>test</code> 表达式结果为 <code>true</code>，则执行 <code>statement</code> 语句。最后对 <code>step</code> 进行求值，循环的下一个迭代再次从 <code>test</code> 表达式开始。</p>
<p>大多数情况下，<code>initialize</code> 将对一个或多个变量赋值，它们通常用作计数器，<code>test</code> 表达式将这些变量与一个预定义的表达式进行比较，而 <code>step</code> 则负责更新这些变量的值。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br></pre></td></tr></table></figure>

<p>首先，它执行 <code>initialize</code> 表达式，将变量 <code>x</code> 初始化为 <code>0</code>，接着，只要 <code>x</code> 的值小于 <code>10</code>，<code>x</code> 的值将在循环体中输出，再接着，<code>x</code> 的值在 <code>step</code> 表达式中自增，并重新计算 <code>test</code> 表达式。</p>
<p><code>for</code> 循环语句中的三个表达式都是可选的，并且它们的任意组合都是有效的。由于第一个 <code>initialize</code> 表达式仅执行一次，因此它是最常被省略的表达式。例如，我们可以将上面的 <code>for</code> 循环改写为如下形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; x &lt; <span class="number">10</span>; x++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br></pre></td></tr></table></figure>

<p>如果我们省略 <code>test</code> 表达式，那么这将是一个无限循环，即死循环（没有在循环体使用 <code>break</code> 或 <code>goto</code> 语句）。这与将 <code>test</code> 设置为 <code>1</code> 或 <code>true</code> 具有相同的效果，它们从不会变成 <code>false</code>。</p>
<p>下面的示例中，<code>for</code> 从 <code>1</code> 开始输出数字随后自增，并且一直进行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; ; x++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br></pre></td></tr></table></figure>

<p>如果省略 <code>step</code> 表达式，那么将没有更新计算的方法（循环体内没有更新）- 这通常不是我们所期望的。例如，下面的示例将一直输出数字 <code>1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= <span class="number">10</span>;)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br></pre></td></tr></table></figure>

<p>需要注意的时，我们不能在 <code>test</code> 表达式中使用逗号运算符来同时检查多个变量，因为逗号运算符通常会将做操作数的结果给丢弃，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>, y = <span class="number">10</span>; x &lt;= <span class="number">10</span>, y &gt;= <span class="number">1</span>; x+=<span class="number">2</span>, y--)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>

<p>其输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">7</span></span><br><span class="line"><span class="number">9</span> <span class="number">6</span></span><br><span class="line"><span class="number">11</span> <span class="number">5</span></span><br><span class="line"><span class="number">13</span> <span class="number">4</span></span><br><span class="line"><span class="number">15</span> <span class="number">3</span></span><br><span class="line"><span class="number">17</span> <span class="number">2</span></span><br><span class="line"><span class="number">19</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过 <code>&amp;&amp;</code> 运算符来测试多个变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>, y = <span class="number">10</span>; x &lt;= <span class="number">10</span> <span class="keyword">and</span> y &gt;= <span class="number">1</span>; x+=<span class="number">2</span>, y--)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>

<p>同样，我们也可以使用 <code>break</code> 语句来终止 <code>for</code> 循环。</p>
<p>这是用于计算平方和的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sum_of_squares(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i++)</span><br><span class="line">        sum += i * i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="块语句（Blocks）"><a href="#块语句（Blocks）" class="headerlink" title="块语句（Blocks）"></a>块语句（Blocks）</h2><p>块语句是用括号括起来的一组零个或多个语句。块语句又被称为__复合语句__。通常，块语句用于 <code>if</code> 语句或循环语句的主体，以将语句进行分组。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= <span class="number">10</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is %d\n&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((x % <span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is even\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is odd\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以在块语句中嵌套块语句，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= <span class="number">10</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x % <span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is %d\n&quot;</span>, x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is even\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is %d\n&quot;</span>, x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is odd\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以在块语句内声明变量；这样的变量是该块语句的局部变量。在 C89 中，声明必须出现在其他语句之前，因此有时为此目的引入一个块语句十分有用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);   <span class="comment">/* 编译错误！变量 x 仅存在于前一个块语句中 */</span></span><br></pre></td></tr></table></figure>

<h2 id="空语句（Null-Statement）"><a href="#空语句（Null-Statement）" class="headerlink" title="空语句（Null Statement）"></a>空语句（Null Statement）</h2><p>空语句仅包含一个分号（<code>;</code>）。空语句不会执行任何操作、它也不会在任何地方存储值，同时它也不会在程序执行时产生额外的开销。</p>
<p>通常，空语句用作循环语句的主体，或用作 <code>for</code> 语句中的一个或多个表达式。例如下面的示例使用空语句作为循环的主体（并且它还计算了 <code>n</code> 的整数平方根，仅是示例而已，没多大作用）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i * i &lt; n; i++)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>下面的例子同样使用空语句作为循环的主体，但同时输出了变量 <code>x</code> 的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= <span class="number">5</span>; <span class="built_in">printf</span>(<span class="string">&quot;x is now %d\n&quot;</span>, x), x++)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>有时，我们需要在标签（该标签之后没有任何其它语句）之后加上一个空语句，从而解决移植性问题。</p>
<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><p>C 语言提供了三种跳转方式，它们分别是 <code>goto</code>、<code>break</code> 和 <code>continue</code>。接下来我们将分别介绍这三种跳转语句。</p>
<h3 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h3><p>我们可以使用 <code>goto</code> 语句来实现无条件的跳转到程序的某个地方，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br></pre></td></tr></table></figure>

<p>我们需要指定一个跳转的标签；当执行 <code>goto</code> 语句时，程序流将跳转到标签所在位置。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> end_of_program;</span><br><span class="line">...</span><br><span class="line">end_of_program:</span><br></pre></td></tr></table></figure>

<p>标签可以是位于 <code>goto</code> 语句所在函数的任意位置，<code>goto</code> 语句不支持跨函数跳转，因此，我们不能使用 <code>goto</code> 语句来跳转到另一函数的标签位置。</p>
<p>我们也可以使用 <code>goto</code> 语句来模拟循环，但是通常不建议那样做，原因有两点：</p>
<ol>
<li>这使得代码难以阅读；</li>
<li>可能导致编译器无法进行优化（GCC 是无法对其进行优化的）。</li>
</ol>
<p>如果可能，我们应尽量使用 <code>for</code>，<code>while</code> 和 <code>do</code> 语句而不是 <code>goto</code> 语句。</p>
<p>GCC 支持 <code>goto</code> 语句跳转到一个由 <code>void *</code> 变量指定的地址处。要想使得其工作，我们需要使用 <code>&amp;&amp;</code> 而不是 <code>&amp;</code> 来获取标签的地址，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Play &#123; ROCK=<span class="number">0</span>, PAPER=<span class="number">1</span>, SCISSORS=<span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">enum</span> Result &#123; WIN, LOSE, DRAW &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> Result <span class="title">turn</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">const</span> jumptable[] = &#123;&amp;&amp;rock, &amp;&amp;paper, &amp;&amp;scissors&#125;;</span><br><span class="line">    <span class="keyword">enum</span> Play opp;                <span class="comment">/* opponent’s play */</span></span><br><span class="line">    <span class="keyword">goto</span> *jumptable[select_option (&amp;opp)];</span><br><span class="line">rock:</span><br><span class="line">    <span class="keyword">return</span> opp == ROCK ? DRAW : (opp == PAPER ? LOSE : WIN);</span><br><span class="line">paper:</span><br><span class="line">    <span class="keyword">return</span> opp == ROCK ? WIN  : (opp == PAPER ? DRAW : LOSE);</span><br><span class="line">scissors:</span><br><span class="line">    <span class="keyword">return</span> opp == ROCK ? LOSE : (opp == PAPER ? WIN  : DRAW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h3><p>我们可以使用 <code>break</code> 语句来终止 <code>while</code>、<code>do</code>、<code>for</code> 或者 <code>switch</code> 语句。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= <span class="number">10</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序将输出 <code>1</code> 到 <code>7</code> 的数字，当 <code>x</code> 自增到 <code>8</code> 时，表达式 <code>x == 8</code> 为 <code>true</code>，那么将执行 <code>break</code> 语句，从而跳转到 <code>for</code> 语句之后。</p>
<p>如果我们将 <code>break</code> 语句放在本身位于循环或 <code>switch</code> 语句内的循环或 <code>switch</code> 语句内时，<code>break</code> 仅终止最里面的循环或 <code>switch</code> 语句。</p>
<h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h3><p>我们可以在循环中使用 <code>continue</code> 语句来终止循环的当前迭代并开始下一次迭代，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sum_of_odd_numbers += x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样地，如果我们将 <code>continue</code> 放在循环内的循环中，<code>continue</code> 只会影响最里层的循环。</p>
<h2 id="返回语句（return）"><a href="#返回语句（return）" class="headerlink" title="返回语句（return）"></a>返回语句（return）</h2><p>我们可以使用 <code>return</code> 语句来结束函数的执行，并将程序控制权返回给调用它的函数，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">return</span>-value;</span><br></pre></td></tr></table></figure>

<p><code>return-value</code> 是一个可选的返回表达式。如果函数的返回类型为 <code>void</code>，那么返回一个表达式是无效的，然而，我们可以使用 <code>return</code> 语句不返回任何值。</p>
<p>如果函数的返回类型与返回值不匹配，并且不能执行自动转换，那么返回的返回值同样是无效的。</p>
<p>如果函数的返回类型不为 <code>void</code> 并且没有指定返回值，那么这个返回语句是有效的，除非调用该函数的上下文环境需要一个返回值，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = cosine(y);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，函数 <code>cosine</code> 是在需要返回值的上下文中调用的，因此可以将该返回值分配给 <code>x</code>。</p>
<p>即使在不需要返回值的情况下，忽略非 <code>void</code> 返回类型函数的返回值并不是一个好主意。当使用 GCC 时，我们可以使用命令行参数 <code>-Wreturn-type</code> 来警告此类忽略了返回值的函数。</p>
<p>以下是具有 <code>void</code> 和非 <code>void</code> 返回类型函数中使用 <code>return</code> 语句的一些示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">print_plus_five(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, x + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">square_value(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型定义语句-typedef"><a href="#类型定义语句-typedef" class="headerlink" title="类型定义语句 (typedef)"></a>类型定义语句 (typedef)</h2><p>我们可以使用 <code>typedef</code> 语句为数据类型创建新的名称，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> old-type-name <span class="keyword">new</span>-type-name</span><br></pre></td></tr></table></figure>

<p><code>old-type-name</code> 是以及存在的类型名，它可能包含多个 <code>token</code> （如，<code>unsigned long int</code>）；<code>new-type-name</code> 则是新定义的类型的名称，它必须是单个的标识符。为类型创建此新名称不会导致旧名称不再存在。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> byte_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> real_number_type;</span><br></pre></td></tr></table></figure>

<p>对于自定义数据类型，可以在定义类型时使用 <code>typedef</code> 为该类型创建新名称。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fish</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> weight;</span><br><span class="line">    <span class="keyword">float</span> length;</span><br><span class="line">    <span class="keyword">float</span> probability_of_being_caught;</span><br><span class="line">&#125; fish_type;</span><br></pre></td></tr></table></figure>

<p>我们也可以对数组进行类型定义，首先要提供元素的类型，然后在类型定义的末尾确定元素数量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> array_of_bytes[<span class="number">5</span>];</span><br><span class="line">array_of_bytes five_bytes = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>为类型选择名称时，应避免以 <code>_t</code> 后缀结束类型名称。编译器允许我们这样做，但是 POSIX 标准保留对标准库类型名称使用 <code>_t</code> 后缀。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Statements">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Statements</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言表达式和运算符</title>
    <url>/2019/06/expressions-and-operators/</url>
    <content><![CDATA[<p>表达式和运算符是组成 C 语言的基本组成部分，本文主要针对表达式和运算符进行讲解，涉及到赋值运算符、算术运算符、比较运算符和逻辑运算符等运算符以及条件表达式、成员访问表达式和函数调用表达式等一系列表达式。</p>
<a id="more"></a>

<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>C 语言中定义一个表达式由一个操作符和零个或多个运算符组成。操作数是诸如常量、变量以及函数调用返回值的类型对象。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span> + <span class="number">2</span></span><br><span class="line">cosine(<span class="number">3.14159</span>)    <span class="comment">/* 我们假设其返回一个浮点类型值 */</span></span><br></pre></td></tr></table></figure>

<p>括号可以用于构造子表达式，如 <code>( 2 * ( ( 3 + 10 ) - ( 2 * 6 ) ) )</code>。在由括号组成的表达式中，首先对最内层的表达式进行求值，即 <code>3 + 10</code> 和 <code>2 * 6</code> 分别求值为 <code>13</code> 和 <code>12</code>；随后进行 <code>13 - 12</code> 的表达式求值，其结果为 <code>1</code>；最后执行 <code>2 * 1</code> 的表达式求值，得出最后结果为 <code>2</code>。从这里可以看出，C 语言的表达式求值顺序是由内到外进行的，而最外层的括号是可以省略的。</p>
<h3 id="函数调用表达式"><a href="#函数调用表达式" class="headerlink" title="函数调用表达式"></a>函数调用表达式</h3><p>对任何具有返回值的函数的调用是一个表达式。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">a = <span class="number">10</span> + function();</span><br></pre></td></tr></table></figure>

<h3 id="成员访问表达式"><a href="#成员访问表达式" class="headerlink" title="成员访问表达式"></a>成员访问表达式</h3><p>您可以使用成员访问运算符 <code>.</code> 来访问联合或结构体的成员。您需要将结构体或联合的变量放在运算符的左边，成员名放在运算符的右边。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">first_point</span>;</span></span><br><span class="line"></span><br><span class="line">first_point.x = <span class="number">0</span>;</span><br><span class="line">first_point.y = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>当然，您也可以通过指针进行访问（使用间接运算符 <code>-&gt;</code>）。<code>x-&gt;y</code> 等同于 <code>(*x)-&gt;y</code>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> length, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">salmon</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> *<span class="title">fish_pointer</span> = &amp;<span class="title">salmon</span>;</span></span><br><span class="line"></span><br><span class="line">fish_pointer-&gt;length = <span class="number">3</span>;</span><br><span class="line">fish_pointer-&gt;weight = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>您可以通过条件运算符来形成一个条件表达式，它将根据第一个操作数的真假来决定是计算第二操作数还是第三个操作数。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a ? b : c;</span><br></pre></td></tr></table></figure>

<p>如果表达式 <code>a</code> 为 <code>true</code>，那么表达式 <code>b</code> 的结果将作为整个表达式的最终结果。否则表达式 <code>c</code> 的结果将作为整个表达式的最终结果。</p>
<p>表达式 <code>b</code> 和 <code>c</code> 必须兼容，即，它们必须是：</p>
<ol>
<li>算术类型；</li>
<li>兼容的结构体或联合类型；</li>
<li>兼容的指针类型（其中一个可能为 <code>NULL</code>）。</li>
</ol>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = (x == <span class="number">5</span>) ? y : z;</span><br></pre></td></tr></table></figure>

<p>如果 <code>x</code> 等于 <code>5</code>，那么 <code>a</code> 将等于 <code>y</code> 的值；否则，<code>a</code> 将等于 <code>z</code> 的值。它可以被视为是一个简短的 <code>if ... else ...</code> 的写法。例如，下面的写法等同于上述写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">5</span>) &#123;</span><br><span class="line">    a = y;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果第一个操作数为 <code>true</code>，那么第三个操作数将不会被执行；同样地，如果第一个操作数为 <code>false</code>，那么第二个操作数将不会被执行。第一个操作数总是会被执行的。</p>
<h3 id="表达式中的语句与声明"><a href="#表达式中的语句与声明" class="headerlink" title="表达式中的语句与声明"></a>表达式中的语句与声明</h3><p>作为 GNU C 的扩展，它允许您在括号中构建复杂的语句。它让您可以在表达式中引入循环、<code>switch</code> 语句以及局部变量。</p>
<p>回想一下，复合语句（也称为块）是由大括号包围的语句序列。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(&#123; <span class="keyword">int</span> y = function (); <span class="keyword">int</span> z;</span><br><span class="line">       <span class="keyword">if</span> (y &gt; <span class="number">0</span>) z = y;</span><br><span class="line">       <span class="keyword">else</span> z = - y;</span><br><span class="line">   z; &#125;)</span><br></pre></td></tr></table></figure>

<p>这是一个求函数 <code>function()</code> 返回值的绝对值的有效表达式（虽然复杂了一点）。</p>
<p>复合语句中的最后一件事应该是一个后跟分号的表达式; 此子表达式的值用作整个构造的值。（如果你在大括号中最后使用了一些其他类型的语句，那么构造的类型为void，因此实际上没有值。）</p>
<p>此功能在使宏定义“安全”时非常有用（因此它们只能评估每个操作数一次）。例如，我们经常在 C 语言中看到如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>

<p>但是上述定义中 <code>a</code> 或者 <code>b</code> 将被执行两次，这就可能导致副作用。在 GNU C 中，如果您知道操作数的类型，您可以定义更为安全的版本（以整型为例）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxint(a,b) \</span></span><br><span class="line">    (&#123;<span class="keyword">int</span> _a = (a), _b = (b); _a &gt; _b ? _a : _b; &#125;)</span><br></pre></td></tr></table></figure>

<p>如果您不知道操作数的类型，您仍然可以这样做，但是您需要使用 <code>typeof</code> 表达式或者类型命名。</p>
<p>常量表达式中不允许嵌入语句，例如枚举常量的值，位字段的宽度或静态变量的初始值。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符指定了操作数上需要执行的操作，运算符可以有一个、两个或者三个操作数，这取决于运算符的类型。</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符（Assignment Operator）将值存储在变量中。C 语言提供了多种赋值运算符的变体。</p>
<p>标准的赋值运算符（<code>=</code>）仅仅是将右操作数的值存放到左操作数指定的变量中。与所有赋值运算符一样，左操作数（通常称为__左值 lvalue__）不能是字面值（literal）或常量值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> y = <span class="number">45.12</span> + <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">int</span> z = (<span class="number">2</span> * (<span class="number">3</span> + function ()));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> bar;</span><br><span class="line">    <span class="keyword">int</span> baz;</span><br><span class="line">&#125; quux = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>不同于下面将要介绍的其它赋值运算符，普通的赋值运算符可以为结构体类型赋值。</p>
<p>复合赋值运算符执行的操作涉及到左操作数和右操作数，并将计算的结果存储到左操作数中。下表给出了复合赋值运算符以及其作用：</p>
<table>
<thead>
<tr>
<th>复合赋值运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>+=</code></td>
<td>将两个操作数进行加法运算，并将结果赋给左操作数</td>
</tr>
<tr>
<td><code>-=</code></td>
<td>使用左左操作数减去右操作数，并将结果赋给左操作数</td>
</tr>
<tr>
<td><code>*=</code></td>
<td>将两个操作数进行乘法运算，并将结果赋给左操作数</td>
</tr>
<tr>
<td><code>/=</code></td>
<td>将左操作数除以右操作数，并将结果赋给左操作数</td>
</tr>
<tr>
<td><code>%=</code></td>
<td>对两个操作数执行取余除法，并将除法结果赋给左操作数</td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td>对左操作数执行左移操作，移位右操作数指定的位数，并将移位结果赋给左操作数</td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td>对左操作数执行右移操作，移位右操作数指定的位数，并将移位结果赋给左操作数</td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td>对两个操作数执行按位与操作，并将操作结果分配给左操作数</td>
</tr>
<tr>
<td><code>&#124;=</code></td>
<td>对两个操作数执行按位或操作，并将操作结果赋给左操作数</td>
</tr>
<tr>
<td><code>^=</code></td>
<td>对两个操作数执行按位异或操作，并将操作结果赋给左操作数</td>
</tr>
</tbody></table>
<h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p>自增运算符 (<code>++</code>) 是将操作数自加 <code>1</code> 的运算符。操作数必须是原始类型、指针或枚举类型变量之一。你可以在操作数之前或之后使用自增运算符。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> w = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> y = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="keyword">float</span> z = <span class="number">5.2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;x;</span><br><span class="line"></span><br><span class="line">++w;   <span class="comment">/* w 现在是字符 ‘2’ (而不是值 2) */</span></span><br><span class="line">x++;   <span class="comment">/* x 现在是 6 */</span></span><br><span class="line">++y;   <span class="comment">/* y 现在是 ‘C’ (在 ASCII 系统上) */</span></span><br><span class="line">z++;   <span class="comment">/* z 现在是 6.2 */</span></span><br><span class="line">++p;   <span class="comment">/* p 现在是 &amp;x + sizeof(int) */</span></span><br></pre></td></tr></table></figure>

<p>指针自增操作自有在指针所指向的值是有效的内存空间时才有意义。</p>
<p>前缀自增运算符在计算操作数之前加 1，后缀自增运算符在计算操作数之后加 1。在前面的示例中更换自增运算符的位置没有任何影响。但是，在下面的情况下就有所不同了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d \n&quot;</span>, x++);    <span class="comment">/* 输出 x 的值，随后将 x 自增 1 */</span></span><br><span class="line"><span class="comment">/* x 现在等于 6 */</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d \n&quot;</span>, ++x);    <span class="comment">/* 先自增 1，随后输出 x 的值 */</span></span><br></pre></td></tr></table></figure>

<p>上面的示例输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>同样，您也可以使用自减运算符减去 1，其用法与自增运算符相同。</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>C 语言提供了标准的算术运算符，它包括加法、减法、乘法、除法、取模以及负号。这些算术运算符的使用相当简单，与我们平时接触到的算法大部分相同。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 加法 */</span></span><br><span class="line">x = <span class="number">5</span> + <span class="number">3</span>;</span><br><span class="line">y = <span class="number">10.23</span> + <span class="number">37.332</span>;</span><br><span class="line">quux_pointer = foo_pointer + bar_pointer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 减法 */</span></span><br><span class="line">x = <span class="number">5</span> - <span class="number">3</span>;</span><br><span class="line">y = <span class="number">57.223</span> - <span class="number">10.903</span>;</span><br><span class="line">quux_pointer = foo_pointer - bar_pointer;</span><br></pre></td></tr></table></figure>

<p>您可以在指针类型上使用加法和减法，但是不能使用乘法和除法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 乘法 */</span></span><br><span class="line">x = <span class="number">5</span> * <span class="number">3</span>;</span><br><span class="line">y = <span class="number">47.4</span> * <span class="number">1.001</span>;</span><br><span class="line"><span class="comment">/* 除法 */</span></span><br><span class="line">x = <span class="number">5</span> / <span class="number">3</span>;</span><br><span class="line">y = <span class="number">940.0</span> / <span class="number">20.2</span>;</span><br></pre></td></tr></table></figure>

<p>正数的正数除法向零取整，例如 <code>5/3</code> 的值为 1。但是，如果操作数包含负数，那么取整的方向有实现决定。</p>
<p>您可以使用取模运算符 <code>％</code> 来获得两个操作数产生的余数。您通过将两个操作数分别放置在运算符的两端来进行取模运算。<code>3 % 5</code> 与 <code>5 % 3</code> 有不同的结果。取模运算符的操作数必须是原始数据类型。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 取模运算 */</span></span><br><span class="line">x = <span class="number">5</span> % <span class="number">3</span>;</span><br><span class="line">y = <span class="number">74</span> % <span class="number">47</span>;</span><br></pre></td></tr></table></figure>

<p>负号运算符的使用如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 负号 */</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">-5</span>;</span><br><span class="line"><span class="keyword">float</span> y = <span class="number">-3.14159</span>;</span><br></pre></td></tr></table></figure>

<p>如果您在无符号数上使用负号运算符，其结果并不是其相反数，而是这个无符号数数据类型的最大值减去这个无符号数。</p>
<p>目前，大多数系统都使用二进制补码算法，因此在这类系统上，负数所能表示的范围总是比正数多。例如，在某些系统上，下面的程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    x = INT_MAX;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MAX  = %d\n&quot;</span>, x);</span><br><span class="line">    x = INT_MIN;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MIN  = %d\n&quot;</span>, x);</span><br><span class="line">    x = -x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-INT_MIN = %d\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INT_MAX  &#x3D; 2147483647</span><br><span class="line">INT_MIN  &#x3D; -2147483648</span><br><span class="line">-INT_MIN &#x3D; -2147483648</span><br></pre></td></tr></table></figure>

<p>当然，您还可以将正号应用于数值表达式，例如，<code>int x = +42;</code>。除非显式为负数，否则假定数值为正，因此该运算符对程序操作没有影响。</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>您可以使用比较运算符来确定两个操作数彼此之间的关系：它们是否相等、一个比另一个大或一个比另一个小等。当您使用任何比较运算符时，其结果不是 1 就是 0，分别代表 true 和 false。</p>
<p>在下面的代码示例中，变量 x 和 y 代表算术类型或指针的任何两个表达式。</p>
<p>相等运算符 (<code>==</code>) 用于测试两个操作数是否相等。如果它们相等，则返回 1；如果不想等，则返回 0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;x is equal to y&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;x is not equal to y&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不等号运算符 (<code>!=</code>) 用于测试两个操作数是否不相等。如果它们相等，则返回 0；如果不想等，则返回 1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;x is not equal to y&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;x is equal to y&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浮点数的相等或不想等比较运算符可能产生意想不到的结果。我们在之前介绍数据类型的时候已经有所提及。</p>
<p>您可以比较函数指针是否相等或不等；测试的结果表示两个函数指针是否指向同一个函数。</p>
<p>除了相等和不想等之外，您还可以比较两个操作数之间的小于 (<code>&lt;</code>)、小于等于 (<code>&lt;=</code>)、大于 (<code>&gt;</code>) 和大于等于 (<code>&gt;=</code>) 关系。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; y)</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is less than y&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (x &lt;= y)</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is less than or equal to y&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (x &gt; y)</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is greater than y&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (x &gt;= y)</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is greater than or equal to y&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符用于测试一组操作数的真假性。在 C 语言中，任何非零表达式都被视为真；而计算结果为零的表达式视为假。</p>
<p>逻辑与运算符 (<code>&amp;&amp;</code>) 用于测试两个操作数是否均为真 (true)。如果第一个表达式计算结果为假 (false)，则不会计算第二个表达式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((x == <span class="number">5</span>) &amp;&amp; (y == <span class="number">10</span>))</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;x is 5 and y is 10&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>逻辑或运算符 (<code>||</code>) 用于测试两个操作数中是否有为真的。如果第一个表达式计算结果为真，则不会计算第二个表达式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((x == <span class="number">5</span>) || (y == <span class="number">10</span>))</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;x is 5 or y is 10&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>逻辑非运算符 (<code>!</code>) 用于反转操作数的真假性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(x == <span class="number">5</span>))</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;x is not 5&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>由于逻辑运算符中的第二个表达式并不是必须被计算的，因此您可以用非常不直观的形式编写代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo &amp;&amp; x++)</span><br><span class="line">    bar();</span><br></pre></td></tr></table></figure>

<p>如果 <code>foo</code> 的值为 0，那么不仅函数 <code>bar()</code> 不会被调用，<code>x</code> 的值也不会增加。如果您想要无论在什么情况下都增加 <code>x</code> 的值，您应该将其写在逻辑运算符之外来做这件事。</p>
<h3 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h3><p>您可以使用左移运算符 (<code>&lt;&lt;</code>) 来将第一个操作数向左移动指定的比特位。第二个操作数表示要移位的位数。从值左侧移除的位被丢弃，而右侧移入的位则填充为 0。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = <span class="number">47</span>;    <span class="comment">/* 47 的二进制为 00101111 */</span></span><br><span class="line">x &lt;&lt; <span class="number">1</span>;    <span class="comment">/* 00101111 &lt;&lt; 1 为 01011110 */</span></span><br></pre></td></tr></table></figure>

<p>类似地，您可以使用右移运算符 (<code>&gt;&gt;</code>) 来将第一个操作数向右移动指定的比特位。从值右侧移除的位被丢弃，而左侧移入的位通常也由 0 来填充，但如果第一个操作数是带符号的负值，则添加的位将为 0 或先前位于最左位位置的任何值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = <span class="number">47</span>;   <span class="comment">/* 47 的二进制为 00101111 */</span></span><br><span class="line">x &gt;&gt; <span class="number">1</span>;   <span class="comment">/* 00101111 &gt;&gt; 1 为 00010111 */</span></span><br></pre></td></tr></table></figure>

<p>无论是左移还是右移运算符，如果第二个操作数大于第一个操作数的比特位时，或者第二个操作数是负数时，这都属于未定义的情况。</p>
<h3 id="按位逻辑运算符"><a href="#按位逻辑运算符" class="headerlink" title="按位逻辑运算符"></a>按位逻辑运算符</h3><p>C 语言提供了按位与 (<code>&amp;</code>)，按位或 (<code>|</code>)，按位取反 (<code>~</code>) 以及按位异或 (<code>^</code>) 运算符。(本节中的操作数均为二进制形式。)</p>
<p>按位与运算符将会检测两个操作数的每个位，仅当它们都为 1 时结果中的相应位才为 1，其它情况下均为 0。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">11001001</span> &amp; <span class="number">10011011</span> = <span class="number">10001001</span></span><br></pre></td></tr></table></figure>

<p>按位或则是在两个操作数中，相应位全为 0 时，其结果中对应的位才为 0，否则则为 1。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">11001001</span> ^ <span class="number">10011011</span> = <span class="number">01010010</span></span><br></pre></td></tr></table></figure>

<p>按位取反则是将操作数中的每个比特位进行反转，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">~<span class="number">11001001</span> = <span class="number">00110110</span></span><br></pre></td></tr></table></figure>

<p>在 C 语言中，您只能将这些运算符与整数（或字符）类型的操作数一起使用，并且为了最大程度的可移植性，您应该只使用带有无符号整数类型的按位取反运算符。</p>
<h3 id="指针运算符"><a href="#指针运算符" class="headerlink" title="指针运算符"></a>指针运算符</h3><p>您可以用取地址符 (<code>&amp;</code>) 来获取对象的内存地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *pointer_to_x = &amp;x;</span><br></pre></td></tr></table></figure>

<p>函数指针和数据指针是不兼容的，因此，您不能指望将函数的地址存储到数据指针中，然后将其复制到函数指针中并成功调用它。它可能适用于某些系统，但它并不具有可移植性。</p>
<p>作为 C89 的 GNU 扩展，您还可以使用标签地址运算符 (<code>&amp;&amp;</code>) 获取标签的地址。结果是一个 <code>void *</code> 类型的指针，它可以与 <code>goto</code> 一起使用。</p>
<p>给定存储在指针中的内存地址，您可以使用间接运算符 <code>*</code> 来获取存储在地址中的值。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = &amp;x;    <span class="comment">/* ptr 现在存储着 x 的地址 */</span></span><br><span class="line"></span><br><span class="line">y = *ptr;    <span class="comment">/* y 获取了存储在地址 ptr 中的值 */</span></span><br></pre></td></tr></table></figure>

<p>您需要避免在未初始化未确定的内存地址上使用解地址运算符。</p>
<h3 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a><code>sizeof</code> 运算符</h3><p>您可以使用 <code>sizeof</code> 运算符来获取数据类型的字节大小，其操作数可以是真实得到数据类型限定符（例如，int 和 float），也可以是有效的表达式。当操作数是数据类型时，它必须使用括号包裹起来。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> a = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">size_t</span> b = <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line"><span class="keyword">size_t</span> c = <span class="keyword">sizeof</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">size_t</span> d = <span class="keyword">sizeof</span>(<span class="number">5.143</span>);</span><br><span class="line"><span class="keyword">size_t</span> e = <span class="keyword">sizeof</span> a;</span><br></pre></td></tr></table></figure>

<p><code>sizeof</code> 运算符的返回值类型为 <code>size_t</code>，它定义在 <code>&lt;stddef.h&gt;</code> 头文件中。<code>size_t</code> 是无符号正数类型，可能为 <code>unsigned int</code> 或 <code>unsigned long int</code>；在不同的系统上可能有所不同。</p>
<p><code>size_t</code> 类型通常是循环索引的一种方便类型，因为它保证能够保存任何数组中的元素数量; 然而，<code>int</code> 则可能不满足这种情况。</p>
<p><code>sizeof</code> 运算符可以用来自动的计算数组的元素个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> values[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">48</span>, <span class="number">681</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAYSIZE(x) (sizeof x/sizeof x[0])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAYSIZE(values); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两种情况下可能不适用。第一种情况是在数组长度为 0 （GCC 的 GNU 扩展支持长度为 0 的数组）；第二种情况则是在数组作为函数的参数（此时数组将退化为指针）。</p>
<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>你可以使用逗号表达式来分割两个表达式。例如，第二个表达式可能会使用第一个表达式生成的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x++, y = x * x;</span><br></pre></td></tr></table></figure>

<p>通常，逗号表达式经常用于 <code>for</code> 语句中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>, y = <span class="number">10</span>;  x &lt;=<span class="number">10</span> &amp;&amp; y &gt;=<span class="number">1</span>;  x++, y--)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做可是很方便的在 <code>for</code> 语句中设置、监控以及修改表达式的值。</p>
<p>注意，逗号也用于分割函数参数，但这时它并不属于逗号运算符。</p>
<p>如果您想再函数中使用逗号运算符，您需要使用括号将其包裹起来。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">foo(x,  y=<span class="number">47</span>,  x,  z);</span><br></pre></td></tr></table></figure>

<p>上述示例将被解释为带有四个参数的函数调用。而下面的示例则表示三个参数的函数调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">foo(x,  (y=<span class="number">47</span>,  x),  z);</span><br></pre></td></tr></table></figure>

<p>其中，第二参数为 <code>(y=47, x)</code>。</p>
<h3 id="数组下标运算符"><a href="#数组下标运算符" class="headerlink" title="数组下标运算符"></a>数组下标运算符</h3><p>您可以使用下标运算符来获取数组元素。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_array[<span class="number">0</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>数组的下标运算符等于指针操作，例如 <code>A[i]</code> 等同于 <code>(*((A) + (i)))</code>。这就意味着大多数情况下使用数组名都等同于指针操作。这同样意味着您不能对使用 <code>register</code> 定义的数组使用下标运算符。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>您可以使用类型转换来将表达式转换为特定数据类型。类型转换由包裹在括号内的类型限定符以及后续的表达式组成。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> x;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">3</span>;</span><br><span class="line">x = (<span class="keyword">float</span>) (y / z);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>x</code> 和 <code>y</code> 均为整数类型，随后执行除法操作，最后将其结果转换为 <code>float</code> 类型，其结果为 <code>2</code>。我们显示地将除法的结果转换为 <code>float</code> 其实并没有任何作用，因为 <code>y/z</code> 的结果已经为 <code>2</code>。</p>
<p>要解决此问题，您需要在除法运算发生之前将其中一个操作数转换为浮点类型。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> x;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">3</span>;</span><br><span class="line">x = (y / (<span class="keyword">float</span>) z);</span><br></pre></td></tr></table></figure>

<p>类型转换仅适用于标量类型（例如，整型、浮点类型以及指针类型）。因此，下面的转换将失败：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fooTag</span> &#123;</span> <span class="comment">/* members ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fooTag</span> <span class="title">foo</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> byteArray[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">foo = (struct fooType) byteArray; <span class="comment">/* 失败 */</span></span><br></pre></td></tr></table></figure>

<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>当表达式包含多个运算符（例如 <code>a + b * f()</code>）时，将根据优先级规则对运算符进行分组。例如，该表达式的含义是调用不带参数的函数 <code>f</code>，将结果乘以 <code>b</code>，然后将结果添加到 <code>a</code>。这就是运算符优先级的 <code>C</code> 规则为此表达式确定的内容。</p>
<p>以下是表达式类型的列表，首先按最高优先级顺序显示。有时两个或多个运营商具有相同的优先权;除非另有说明，否则所有这些操作员都是从左到右应用的。</p>
<ol>
<li>函数调用、数组下标、成员访问运算符表达式。</li>
<li>一元运算符，包括逻辑非、按位取反、自增、自减、正负号、间接运算符、取地址运算符、类型转换、<code>sizeof</code> 表达式。当连续包含多个一元运算符时，后面的运算符嵌套在前面的运算符中：例如 <code>!-x</code> 表示 <code>!(-x)</code>。</li>
<li>乘法、除法以及取模表达式。</li>
<li>加法与减法表达式。</li>
<li>移位表达式。</li>
<li>大于、小于、大于等于、小于等于表达式。</li>
<li>等于、不等于表达式。</li>
<li>按位与表达式。</li>
<li>按位异或表达式。</li>
<li>按位或表达式。</li>
<li>逻辑与表达式。</li>
<li>逻辑或表达式。</li>
<li>条件表达式（使用<code>? :</code>）。当用作子表达式时，它们从右到左依次执行。</li>
<li>所有赋值表达式，包括复合赋值。当多个赋值语句在单个较大表达式中显示为子表达式时，它们将从右到左进行求值。</li>
<li>逗号运算符表达式。</li>
</ol>
<p>上面的列表看起来比较枯燥，但它其实非常简单之间，不过它也隐藏这一些陷阱。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">foo = *p++;</span><br></pre></td></tr></table></figure>

<p>这里 <code>p</code> 作为表达式的副作用递增，但是 <code>foo</code> 的取值为 <code>*(p++)</code> 而不是 <code>(*p)++</code>，因为一元运算符从右到左绑定。还有其他潜在的意外隐藏在 <code>C</code> 优先级表背后的例子。因此，如果读者误解了程序的含义，那么您应该使用括号来明确您的意思。</p>
<h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>在 C 语言中，您不能假设多个子表达式按照看似自然的顺序进行求值。例如，考虑表达式 <code>++a * f()</code> ，请问 <code>a</code> 的自增发生在函数 <code>f</code> 调用之前还是之后呢？编译器可以按任意顺序执行，因此您无法进行假设。</p>
<p>实际的编译器在将源代码转换为实际计算机中的特定动作时，为了提高效率可以重新排序这些操作。您编写的程序与计算机实际执行的操作之间的对应关系是根据副作用和序列点来指定的。</p>
<h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>副作用（_side effects_）包含一下几点：</p>
<ol>
<li>访问 <code>volatile</code> 对象；</li>
<li>修改一个对象；</li>
<li>修改文件；</li>
<li>调用一个执行了上述动作的函数。</li>
</ol>
<p>这些本质上是运行程序的外部可见效果。它们被称为副作用，因为它们是表达式评估的影响，超出了表达式的实际结果值。</p>
<p>编译器允许以与程序源码所暗示不同的顺序执行程序的操作，前提是最终实际发生了所有必要的副作用。 编译器也允许完全省略一些操作; 例如，如果可以确定该值未被使用并且求值表达式的该部分不会产生任何所需的副作用，则允许跳过求值表达式的一部分。</p>
<h3 id="序列点"><a href="#序列点" class="headerlink" title="序列点"></a>序列点</h3><p>编译器的另一个要求是副作用应该以正确的顺序发生。为了在不过度约束编译器的情况下提供此功能，C89 和 C90 标准指定了序列点列表。序列点（_sequence points_）是以下的其中之一：</p>
<ol>
<li>函数的调用（在对函数参数求值完成之后）；</li>
<li>与运算符 <code>&amp;&amp;</code> 的左侧操作数的结尾；</li>
<li>或运算符 <code>||</code> 的左侧操作数的结尾；</li>
<li>逗号运算符 <code>,</code> 的左侧操作数的结尾；</li>
<li>三元运算符的第一个操作数结尾 <code>a ? b : c</code>；</li>
<li>完整的声明结尾；</li>
<li>初始化表达式的结尾；</li>
<li>表达式语句的结尾（即，表达式后的 <code>;</code>）；</li>
<li><code>if</code> 或 <code>switch</code> 控制表达式的结尾；</li>
<li><code>while</code> 或 <code>do</code> 控制表达式的结尾；</li>
<li><code>for</code> 语句的三个控制表达式中的任何一个的结尾；</li>
<li><code>return</code> 语句的表达式结尾；</li>
<li>库函数返回之前；</li>
<li>在与格式化 <code>I/O</code> 项相关联的操作之后（例如，使用 <code>strftime</code> 或 <code>printf</code>和 <code>scanf</code> 函数）；</li>
<li>紧接在调用比较函数之前和之后（例如调用 <code>qsort</code> 函数）。</li>
</ol>
<p>在序列点，先前表达求值的所有副作用必须完整，并且可能没有发生后续求值的副作用。</p>
<p>这可能看起来有点难以理解，但还有另一种方法可以考虑这一点。想象一下，您编写了一个库（其中一些函数是外部的，也许不是其他函数）并编译它，允许其他人从他们的代码中调用您的一个函数。上面的定义确保在它们调用函数时，它们传入的数据具有与抽象机器指定的行为一致的值，并且函数返回的任何数据都具有与抽象一致的状态机。这包括通过指针访问的数据（即不仅仅是函数参数和带有外部链接的标识符）。</p>
<p>以上略微简化，因为存在在链接时执行整个程序优化的编译器。但重要的是，虽然它们可能会执行优化，但程序的可见副作用必须与抽象机器生成的副作用相同。</p>
<h3 id="序列点约束表达式"><a href="#序列点约束表达式" class="headerlink" title="序列点约束表达式"></a>序列点约束表达式</h3><p>下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>非常正常，且毫无疑问会在许多程序中出现。但是接下来的代码就有点难懂了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = ++i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><code>i</code> 最终的值为多少呢？C 语言标准（C89 和 C99）都禁止在符合规划的程序中使用该结构。</p>
<p>在两个序列点之间，您只允许做以下两件事：</p>
<ol>
<li>通过表达式的求值，对象可以将其存储值最多修改一次；</li>
<li>只读对象的先前值以确定要存储的值。</li>
</ol>
<p>这两个条件中的第一个禁止表达式如 <code>foo(x=2, ++x)</code>；第二个条件禁止像 <code>a[i++] = i</code> 这样的表达式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x&#x3D;0; bar(++x,++x)</span><br></pre></td></tr></table></figure>

<p>不符合规定的程序；在参数求值完成之前两次修改 <code>x</code> 的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>; bar((++x,++x))</span><br></pre></td></tr></table></figure>

<p>允许；函数仅有一个参数（传入的值为 <code>2</code>），逗号运算符有一个序列点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*p++ || *p++</span><br></pre></td></tr></table></figure>

<p>允许；在 <code>||</code> 处有一个序列点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p)), *q = p; *p = foo(); bar((*p)++, (*q)++);</span><br></pre></td></tr></table></figure>

<p>不允许；在对 <code>bar</code> 的参数的求值完成之前，<code>p</code> 对象被修改两次。事实上，这是通过 <code>p</code> 和 <code>q</code> 来完成的，这是无关紧要的，因为它们都指向同一个对象。</p>
<p>让我们回到我们用来介绍评估顺序问题的例子，<code>++a * f()</code>。假设代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a * f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码是否复合标准呢？尽管 <code>foo</code> 中的表达式两次修改 <code>a</code> 的值，但这不是问题。我们看看两种可能的情况：</p>
<ul>
<li>右操作数 <code>f()</code> 先执行 - 由于 <code>f()</code> 返回一个而不是 <code>void</code>，因此它必须包含一个 <code>return</code> 语句。因此，在 <code>return</code> 的末尾势必会有一个序列点，它介于 <code>f()</code> 修改 <code>a</code> 的值和左操作数修改 <code>a</code> 值之间。</li>
<li>左操作数 <code>++a</code> 先执行 - 首先，<code>a</code> 自增，然后对 <code>f()</code> 的参数（它们中有零）求值。在实际调用 <code>f()</code> 之前势必有一个序列点。</li>
</ul>
<p>因此，我们看到我们的程序复合标准。注意上述的讨论并不依赖于函数 <code>f()</code> 主体的具体细节，它仅取决于函数包含一个序列点，在我们的示例中它是一个 <code>return</code> 语句，但是表达式语句或完整的声明符也是可以的。</p>
<p>但是，上述代码的结果取决于运算符 <code>**</code> 的操作数的求值顺序（MacOS clang-1001.0.46.4 结果为 <code>6</code>，即属于第二种情况）。如果首先计算左操作数，则 <code>foo()</code> 返回 <code>6</code>，否则，返回 <code>303</code>。C 标准没有规定操作数的求值顺序，也不需要实现给出文档说明或者按照某一特定顺序实现。这段代码是不确定的（<em>unspecified</em>)，这就意味着它们可能是几种特定情况的一种，但是 C 标准并没有给出具体应该是那一种。</p>
<h3 id="序列点和信号传递"><a href="#序列点和信号传递" class="headerlink" title="序列点和信号传递"></a>序列点和信号传递</h3><p>当接收到信号时，这将在序列点之间发生。<code>volatile</code> 对象的副作用将先于序列点发生，而其它对象的更新可能不会发生（其实这个地方理解的不太清楚）。这甚至会出现在类似 <code>x = 0;</code> 这样的赋值语句中，因为代码生成器可能在为这条语句生成多个指令，这意味着它可以信号到来时被中途中断。</p>
<p>C 标准对信号处理程序中可能发生的数据访问非常严格。它们当然可以使用自动变量，但在读取或写入其他对象方面，它们必须是 <code>volatile sig_atomic_t</code> 类型。<code>volatile</code> 类型限定符确保对程序其他部分中的变量的访问不会跨越序列点，并且使用 <code>sig_atomic_t</code> 类型可确保变量的变化对于信号传递是原子的。</p>
<p>POSIX 标准还允许在信号处理程序调用少量库函数。这些功能称为异步信号安全(<em>async-signal-safe</em>)函数集。如果您的程序要在 POSIX 系统上运行而不在其他系统上运行，您也可以安全地在信号处理程序中调用它们。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Expressions-and-Operators">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Expressions-and-Operators</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 共享表</title>
    <url>/2020/08/postgresql-shared-relations/</url>
    <content><![CDATA[<p>PostgreSQL 数据库中提供的某些系统表是 Cluster 级别共享的，他们在数据库内部被称为 <code>shared_relation</code>，本文就介绍一下 PostgreSQL 是如何创建共享表的。</p>
<a id="more"></a>

<h2 id="SQL-查询"><a href="#SQL-查询" class="headerlink" title="SQL 查询"></a>SQL 查询</h2><p>我们可以通过下面的语句查看系统中提供的共享表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    c.oid</span><br><span class="line">    , c.relname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    pg_class c <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_tablespace t</span><br><span class="line">        <span class="keyword">ON</span> c.reltablespace = t.oid</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    c.relisshared = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">AND</span> c.relkind = <span class="string">&#x27;r&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.oid;</span><br><span class="line"> oid  |        relname</span><br><span class="line"><span class="comment">------+-----------------------</span></span><br><span class="line"> 1136 | pg_pltemplate</span><br><span class="line"> 1213 | pg_tablespace</span><br><span class="line"> 1214 | pg_shdepend</span><br><span class="line"> 1260 | pg_authid</span><br><span class="line"> 1261 | pg_auth_members</span><br><span class="line"> 1262 | pg_database</span><br><span class="line"> 2396 | pg_shdescription</span><br><span class="line"> 2964 | pg_db_role_setting</span><br><span class="line"> 3592 | pg_shseclabel</span><br><span class="line"> 6000 | pg_replication_origin</span><br><span class="line"> 6100 | pg_subscription</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>

<p>其实除了上述的基本表之外，这些表上的索引和 TOAST 也是共享的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    c.oid</span><br><span class="line">    , c.relname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    pg_class c <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_tablespace t</span><br><span class="line">        <span class="keyword">ON</span> c.reltablespace = t.oid</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    c.relisshared = <span class="literal">true</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.oid;</span><br><span class="line"> oid  |                 relname</span><br><span class="line"><span class="comment">------+-----------------------------------------</span></span><br><span class="line"> 1136 | pg_pltemplate</span><br><span class="line"> 1137 | pg_pltemplate_name_index</span><br><span class="line"> 1213 | pg_tablespace</span><br><span class="line"> 1214 | pg_shdepend</span><br><span class="line"> 1232 | pg_shdepend_depender_index</span><br><span class="line"> 1233 | pg_shdepend_reference_index</span><br><span class="line"> 1260 | pg_authid</span><br><span class="line"> 1261 | pg_auth_members</span><br><span class="line"> 1262 | pg_database</span><br><span class="line"> 2396 | pg_shdescription</span><br><span class="line"> 2397 | pg_shdescription_o_c_index</span><br><span class="line"> 2671 | pg_database_datname_index</span><br><span class="line"> 2672 | pg_database_oid_index</span><br><span class="line"> 2676 | pg_authid_rolname_index</span><br><span class="line"> 2677 | pg_authid_oid_index</span><br><span class="line"> 2694 | pg_auth_members_role_member_index</span><br><span class="line"> 2695 | pg_auth_members_member_role_index</span><br><span class="line"> 2697 | pg_tablespace_oid_index</span><br><span class="line"> 2698 | pg_tablespace_spcname_index</span><br><span class="line"> 2846 | pg_toast_2396</span><br><span class="line"> 2847 | pg_toast_2396_index</span><br><span class="line"> 2964 | pg_db_role_setting</span><br><span class="line"> 2965 | pg_db_role_setting_databaseid_rol_index</span><br><span class="line"> 2966 | pg_toast_2964</span><br><span class="line"> 2967 | pg_toast_2964_index</span><br><span class="line"> 3592 | pg_shseclabel</span><br><span class="line"> 3593 | pg_shseclabel_object_index</span><br><span class="line"> 4060 | pg_toast_3592</span><br><span class="line"> 4061 | pg_toast_3592_index</span><br><span class="line"> 6000 | pg_replication_origin</span><br><span class="line"> 6001 | pg_replication_origin_roiident_index</span><br><span class="line"> 6002 | pg_replication_origin_roname_index</span><br><span class="line"> 6100 | pg_subscription</span><br><span class="line"> 6114 | pg_subscription_oid_index</span><br><span class="line"> 6115 | pg_subscription_subname_index</span><br><span class="line">(35 rows)</span><br></pre></td></tr></table></figure>

<p>PostgreSQL 中共享表的都是存储在 pg_global 这个表空间中的。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>在源码中，PostgreSQL 通过 <code>IsSharedRelation()</code> 函数来判断表是否为共享表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">IsSharedRelation(Oid relationId)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* These are the shared catalogs (look for BKI_SHARED_RELATION) */</span></span><br><span class="line">    <span class="keyword">if</span> (relationId == AuthIdRelationId ||</span><br><span class="line">        relationId == AuthMemRelationId ||</span><br><span class="line">        relationId == DatabaseRelationId ||</span><br><span class="line">        relationId == PLTemplateRelationId ||</span><br><span class="line">        relationId == SharedDescriptionRelationId ||</span><br><span class="line">        relationId == SharedDependRelationId ||</span><br><span class="line">        relationId == SharedSecLabelRelationId ||</span><br><span class="line">        relationId == TableSpaceRelationId ||</span><br><span class="line">        relationId == DbRoleSettingRelationId ||</span><br><span class="line">        relationId == ReplicationOriginRelationId ||</span><br><span class="line">        relationId == SubscriptionRelationId)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* These are their indexes (see indexing.h) */</span></span><br><span class="line">    <span class="keyword">if</span> (relationId == AuthIdRolnameIndexId ||</span><br><span class="line">        relationId == AuthIdOidIndexId ||</span><br><span class="line">        relationId == AuthMemRoleMemIndexId ||</span><br><span class="line">        relationId == AuthMemMemRoleIndexId ||</span><br><span class="line">        relationId == DatabaseNameIndexId ||</span><br><span class="line">        relationId == DatabaseOidIndexId ||</span><br><span class="line">        relationId == PLTemplateNameIndexId ||</span><br><span class="line">        relationId == SharedDescriptionObjIndexId ||</span><br><span class="line">        relationId == SharedDependDependerIndexId ||</span><br><span class="line">        relationId == SharedDependReferenceIndexId ||</span><br><span class="line">        relationId == SharedSecLabelObjectIndexId ||</span><br><span class="line">        relationId == TablespaceOidIndexId ||</span><br><span class="line">        relationId == TablespaceNameIndexId ||</span><br><span class="line">        relationId == DbRoleSettingDatidRolidIndexId ||</span><br><span class="line">        relationId == ReplicationOriginIdentIndex ||</span><br><span class="line">        relationId == ReplicationOriginNameIndex ||</span><br><span class="line">        relationId == SubscriptionObjectIndexId ||</span><br><span class="line">        relationId == SubscriptionNameIndexId)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* These are their toast tables and toast indexes (see toasting.h) */</span></span><br><span class="line">    <span class="keyword">if</span> (relationId == PgAuthidToastTable ||</span><br><span class="line">        relationId == PgAuthidToastIndex ||</span><br><span class="line">        relationId == PgDatabaseToastTable ||</span><br><span class="line">        relationId == PgDatabaseToastIndex ||</span><br><span class="line">        relationId == PgDbRoleSettingToastTable ||</span><br><span class="line">        relationId == PgDbRoleSettingToastIndex ||</span><br><span class="line">        relationId == PgPlTemplateToastTable ||</span><br><span class="line">        relationId == PgPlTemplateToastIndex ||</span><br><span class="line">        relationId == PgReplicationOriginToastTable ||</span><br><span class="line">        relationId == PgReplicationOriginToastIndex ||</span><br><span class="line">        relationId == PgShdescriptionToastTable ||</span><br><span class="line">        relationId == PgShdescriptionToastIndex ||</span><br><span class="line">        relationId == PgShseclabelToastTable ||</span><br><span class="line">        relationId == PgShseclabelToastIndex ||</span><br><span class="line">        relationId == PgSubscriptionToastTable ||</span><br><span class="line">        relationId == PgSubscriptionToastIndex ||</span><br><span class="line">        relationId == PgTablespaceToastTable ||</span><br><span class="line">        relationId == PgTablespaceToastIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这和我们在上面看到的是一致的。</p>
<p>那么 PostgreSQL 是如何定义共享表的呢？我们知道 PostgreSQL 的系统表都是定义在 <code>src/include/catalog/</code> 目录下。那么我们看看 <code>pg_authid</code> 这个共享表是如何定义的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CATALOG(pg_authid,1260,AuthIdRelationId) BKI_SHARED_RELATION BKI_ROWTYPE_OID(2842,AuthIdRelation_Rowtype_Id) BKI_SCHEMA_MACRO</span><br><span class="line">&#123;</span><br><span class="line">    Oid         oid;            &#x2F;* oid *&#x2F;</span><br><span class="line">    NameData    rolname;        &#x2F;* name of role *&#x2F;</span><br><span class="line">    bool        rolsuper;       &#x2F;* read this field via superuser() only! *&#x2F;</span><br><span class="line">    bool        rolinherit;     &#x2F;* inherit privileges from other roles? *&#x2F;</span><br><span class="line">    bool        rolcreaterole;  &#x2F;* allowed to create more roles? *&#x2F;</span><br><span class="line">    bool        rolcreatedb;    &#x2F;* allowed to create databases? *&#x2F;</span><br><span class="line">    bool        rolcanlogin;    &#x2F;* allowed to log in as session user? *&#x2F;</span><br><span class="line">    bool        rolreplication; &#x2F;* role used for streaming replication *&#x2F;</span><br><span class="line">    bool        rolbypassrls;   &#x2F;* bypasses row level security? *&#x2F;</span><br><span class="line">    int32       rolconnlimit;   &#x2F;* max connections allowed (-1&#x3D;no limit) *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* remaining fields may be null; use heap_getattr to read them! *&#x2F;</span><br><span class="line">#ifdef CATALOG_VARLEN           &#x2F;* variable-length fields start here *&#x2F;</span><br><span class="line">    text        rolpassword;    &#x2F;* password, if any *&#x2F;</span><br><span class="line">    timestamptz rolvaliduntil;  &#x2F;* password expiration time, if any *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">&#125; FormData_pg_authid;</span><br></pre></td></tr></table></figure>

<p>我们可以看到这里有一个 <code>BKI_SHARED_RELATION</code> 宏，因此，我们推测只要加上这个宏，那么这个系统表就是共享的。我们可以通过对比其他系统表来进行验证。</p>
<p>所有的系统表定义都将通过 <code>Catalog.pm</code> 来转换为 Perl 中的数据结构，最后通过 <code>genbki.pl</code> 脚步转换为 <code>postgres.bki</code> 文件，而 BKI 文件则用于初始化 PostgreSQL 模版数据库。</p>
<p>例如，<code>pg_authid</code> 经过转换之后在 <code>postgres.bki</code> 中的内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create pg_authid 1260 shared_relation rowtype_oid 2842</span><br><span class="line"> (</span><br><span class="line"> oid &#x3D; oid ,</span><br><span class="line"> rolname &#x3D; name ,</span><br><span class="line"> rolsuper &#x3D; bool ,</span><br><span class="line"> rolinherit &#x3D; bool ,</span><br><span class="line"> rolcreaterole &#x3D; bool ,</span><br><span class="line"> rolcreatedb &#x3D; bool ,</span><br><span class="line"> rolcanlogin &#x3D; bool ,</span><br><span class="line"> rolreplication &#x3D; bool ,</span><br><span class="line"> rolbypassrls &#x3D; bool ,</span><br><span class="line"> rolconnlimit &#x3D; int4 ,</span><br><span class="line"> rolpassword &#x3D; text ,</span><br><span class="line"> rolvaliduntil &#x3D; timestamptz</span><br><span class="line"> )</span><br><span class="line">open pg_authid</span><br><span class="line">insert ( 10 POSTGRES t t t t t t t -1 _null_ _null_ )</span><br><span class="line">insert ( 3373 pg_monitor f t f f f f f -1 _null_ _null_ )</span><br><span class="line">insert ( 3374 pg_read_all_settings f t f f f f f -1 _null_ _null_ )</span><br><span class="line">insert ( 3375 pg_read_all_stats f t f f f f f -1 _null_ _null_ )</span><br><span class="line">insert ( 3377 pg_stat_scan_tables f t f f f f f -1 _null_ _null_ )</span><br><span class="line">insert ( 4569 pg_read_server_files f t f f f f f -1 _null_ _null_ )</span><br><span class="line">insert ( 4570 pg_write_server_files f t f f f f f -1 _null_ _null_ )</span><br><span class="line">insert ( 4571 pg_execute_server_program f t f f f f f -1 _null_ _null_ )</span><br><span class="line">insert ( 4200 pg_signal_backend f t f f f f f -1 _null_ _null_ )</span><br><span class="line">close pg_authid</span><br></pre></td></tr></table></figure>

<p>当我们使用 initdb 初始化数据库时，<code>setup_data_file_paths()</code> 函数将会设置 <code>postgres.bki</code> 文件路径，随后通过 <code>initialize_data_directory()</code> 函数调用 <code>bootstrap_template1()</code> 函数来读取 <code>postgres.bki</code> 文件中的内容初始化模版数据库。</p>
<p>最后通过 <code>postgres --boot -x1 -X 16777216 -F</code> 命令来初始化 <code>template1</code> 数据库，在 src/backend/main/main.c 文件中，我们可以看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--boot&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        AuxiliaryProcessMain(argc, argv);   <span class="comment">/* does not return */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--describe-config&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        GucInfoMain();          <span class="comment">/* does not return */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--single&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        PostgresMain(argc, argv,</span><br><span class="line">                     <span class="literal">NULL</span>,      <span class="comment">/* no dbname */</span></span><br><span class="line">                     strdup(get_user_name_or_exit(progname)));  <span class="comment">/* does not return */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PostmasterMain(argc, argv); <span class="comment">/* does not return */</span></span><br><span class="line">    <span class="built_in">abort</span>();                    <span class="comment">/* should not get here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，在 initdb 的时候执行的是 <code>AuxiliaryProcessMain()</code> 函数，该函数可以用于创建多种类型的辅助进程，例如，Checkpointer、WAL writer 和 WAL receiver 等进程，该函数通过参数 <code>-x num</code> 来创建不同的进程，有如下辅助进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Auxiliary-process type identifiers.  These used to be in bootstrap.h</span></span><br><span class="line"><span class="comment"> * but it seems saner to have them here, with the ProcessingMode stuff.</span></span><br><span class="line"><span class="comment"> * The MyAuxProcType global is defined and set in bootstrap.c.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    NotAnAuxProcess = <span class="number">-1</span>,</span><br><span class="line">    CheckerProcess = <span class="number">0</span>,</span><br><span class="line">    BootstrapProcess,</span><br><span class="line">    StartupProcess,</span><br><span class="line">    BgWriterProcess,</span><br><span class="line">    CheckpointerProcess,</span><br><span class="line">    WalWriterProcess,</span><br><span class="line">    WalReceiverProcess,</span><br><span class="line"></span><br><span class="line">    NUM_AUXPROCTYPES            <span class="comment">/* Must be last! */</span></span><br><span class="line">&#125; AuxProcType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> AuxProcType MyAuxProcType;</span><br></pre></td></tr></table></figure>

<p>从 <code>initdb</code> 中传递过来的参数可以看到，我们的辅助进程类型为 <code>BootstrapProcess</code>，最后执行下面的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AuxiliaryProcessMain(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (MyAuxProcType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CheckerProcess:</span><br><span class="line">            <span class="comment">/* don&#x27;t set signals, they&#x27;re useless here */</span></span><br><span class="line">            CheckerModeMain();</span><br><span class="line">            proc_exit(<span class="number">1</span>);       <span class="comment">/* should never return */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BootstrapProcess:</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * There was a brief instant during which mode was Normal; this is</span></span><br><span class="line"><span class="comment">             * okay.  We need to be in bootstrap mode during BootStrapXLOG for</span></span><br><span class="line"><span class="comment">             * the sake of multixact initialization.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            SetProcessingMode(BootstrapProcessing);</span><br><span class="line">            bootstrap_signals();</span><br><span class="line">            BootStrapXLOG();</span><br><span class="line">            BootstrapModeMain();</span><br><span class="line">            proc_exit(<span class="number">1</span>);       <span class="comment">/* should never return */</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们关注一下 <code>BootStrapXLOG()</code> 函数，在<a href="/2020/06/postgresql-system-identifier/" title="PostgreSQL 数据库系统标识符">PostgreSQL 数据库系统标识符</a>的文章中我们介绍了这个函数将会创建数据库标识符，此外，他还将创建 <code>pg_control</code> 文件，XLOG 日志文件以及 CLOG 文件。</p>
<p>接着我们看看 <code>BootstrapModeMain()</code> 函数，该函数以 <code>bootstrap</code> 模式运行，并且处理 PostgreSQL 提供的特殊的 <code>bootstrap</code> 语法，即 <code>postgres.bki</code> 文件中的内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   The main entry point for running the backend in bootstrap mode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The bootstrap mode is used to initialize the template database.</span></span><br><span class="line"><span class="comment"> *   The bootstrap backend doesn&#x27;t speak SQL, but instead expects</span></span><br><span class="line"><span class="comment"> *   commands in a special bootstrap language.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">BootstrapModeMain(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>         i;</span><br><span class="line"></span><br><span class="line">    Assert(!IsUnderPostmaster);</span><br><span class="line">    Assert(IsBootstrapProcessingMode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * To ensure that src/common/link-canary.c is linked into the backend, we</span></span><br><span class="line"><span class="comment">     * must call it from somewhere.  Here is as good as anywhere.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (pg_link_canary_is_frontend())</span><br><span class="line">        elog(ERROR, <span class="string">&quot;backend is incorrectly linked to frontend functions&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Do backend-like initialization for bootstrap mode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    InitProcess();</span><br><span class="line"></span><br><span class="line">    InitPostgres(<span class="literal">NULL</span>, InvalidOid, <span class="literal">NULL</span>, InvalidOid, <span class="literal">NULL</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize stuff for bootstrap-file processing */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXATTR; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        attrtypes[i] = <span class="literal">NULL</span>;</span><br><span class="line">        Nulls[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Process bootstrap input.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    StartTransactionCommand();</span><br><span class="line">    boot_yyparse();</span><br><span class="line">    CommitTransactionCommand();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We should now know about all mapped relations, so it&#x27;s okay to write</span></span><br><span class="line"><span class="comment">     * out the initial relation mapping files.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RelationMapFinishBootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up and exit */</span></span><br><span class="line">    cleanup();</span><br><span class="line">    proc_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码的注释我们可以看到整个 <code>postgres.bki</code> 文件的处理是通过 <code>boot_yyparse()</code> 函数来进行的，这个函数是由 <code>bootparse.y</code> 文件提供的，其实就是处理有关 <code>postgres.bki</code> 文件的语法，并将其转化为不同的对象进而调用 PostgreSQL 内部提供的函数。例如，创建 <code>pg_authid</code> 这个系统表，将会执行以下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Boot_CreateStmt:</span><br><span class="line">          XCREATE boot_ident oidspec optbootstrap optsharedrelation optrowtypeoid LPAREN</span><br><span class="line">                &#123;</span><br><span class="line">                    do_start();</span><br><span class="line">                    numattr = <span class="number">0</span>;</span><br><span class="line">                    elog(DEBUG4, <span class="string">&quot;creating%s%s relation %s %u&quot;</span>,</span><br><span class="line">                         $<span class="number">4</span> ? <span class="string">&quot; bootstrap&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                         $<span class="number">5</span> ? <span class="string">&quot; shared&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                         $<span class="number">2</span>,</span><br><span class="line">                         $<span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">          boot_column_list</span><br><span class="line">                &#123;</span><br><span class="line">                    do_end();</span><br><span class="line">                &#125;</span><br><span class="line">          RPAREN</span><br><span class="line">                &#123;</span><br><span class="line">                    TupleDesc tupdesc;</span><br><span class="line">                    <span class="keyword">bool</span>    shared_relation;</span><br><span class="line">                    <span class="keyword">bool</span>    mapped_relation;</span><br><span class="line"></span><br><span class="line">                    do_start();</span><br><span class="line"></span><br><span class="line">                    tupdesc = CreateTupleDesc(numattr, attrtypes);</span><br><span class="line"></span><br><span class="line">                    shared_relation = $<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * The catalogs that use the relation mapper are the</span></span><br><span class="line"><span class="comment">                     * bootstrap catalogs plus the shared catalogs.  If this</span></span><br><span class="line"><span class="comment">                     * ever gets more complicated, we should invent a BKI</span></span><br><span class="line"><span class="comment">                     * keyword to mark the mapped catalogs, but for now a</span></span><br><span class="line"><span class="comment">                     * quick hack seems the most appropriate thing.  Note in</span></span><br><span class="line"><span class="comment">                     * particular that all &quot;nailed&quot; heap rels (see formrdesc</span></span><br><span class="line"><span class="comment">                     * in relcache.c) must be mapped.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    mapped_relation = ($<span class="number">4</span> || shared_relation);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ($<span class="number">4</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        TransactionId relfrozenxid;</span><br><span class="line">                        MultiXactId relminmxid;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (boot_reldesc)</span><br><span class="line">                        &#123;</span><br><span class="line">                            elog(DEBUG4, <span class="string">&quot;create bootstrap: warning, open relation exists, closing first&quot;</span>);</span><br><span class="line">                            closerel(<span class="literal">NULL</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        boot_reldesc = heap_create($<span class="number">2</span>,</span><br><span class="line">                                                   PG_CATALOG_NAMESPACE,</span><br><span class="line">                                                   shared_relation ? GLOBALTABLESPACE_OID : <span class="number">0</span>,</span><br><span class="line">                                                   $<span class="number">3</span>,</span><br><span class="line">                                                   InvalidOid,</span><br><span class="line">                                                   HEAP_TABLE_AM_OID,</span><br><span class="line">                                                   tupdesc,</span><br><span class="line">                                                   RELKIND_RELATION,</span><br><span class="line">                                                   RELPERSISTENCE_PERMANENT,</span><br><span class="line">                                                   shared_relation,</span><br><span class="line">                                                   mapped_relation,</span><br><span class="line">                                                   <span class="literal">true</span>,</span><br><span class="line">                                                   &amp;relfrozenxid,</span><br><span class="line">                                                   &amp;relminmxid);</span><br><span class="line">                        elog(DEBUG4, <span class="string">&quot;bootstrap relation created&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Oid id;</span><br><span class="line"></span><br><span class="line">                        id = heap_create_with_catalog($<span class="number">2</span>,</span><br><span class="line">                                                      PG_CATALOG_NAMESPACE,</span><br><span class="line">                                                      shared_relation ? GLOBALTABLESPACE_OID : <span class="number">0</span>,</span><br><span class="line">                                                      $<span class="number">3</span>,</span><br><span class="line">                                                      $<span class="number">6</span>,</span><br><span class="line">                                                      InvalidOid,</span><br><span class="line">                                                      BOOTSTRAP_SUPERUSERID,</span><br><span class="line">                                                      HEAP_TABLE_AM_OID,</span><br><span class="line">                                                      tupdesc,</span><br><span class="line">                                                      NIL,</span><br><span class="line">                                                      RELKIND_RELATION,</span><br><span class="line">                                                      RELPERSISTENCE_PERMANENT,</span><br><span class="line">                                                      shared_relation,</span><br><span class="line">                                                      mapped_relation,</span><br><span class="line">                                                      ONCOMMIT_NOOP,</span><br><span class="line">                                                      (Datum) <span class="number">0</span>,</span><br><span class="line">                                                      <span class="literal">false</span>,</span><br><span class="line">                                                      <span class="literal">true</span>,</span><br><span class="line">                                                      <span class="literal">false</span>,</span><br><span class="line">                                                      InvalidOid,</span><br><span class="line">                                                      <span class="literal">NULL</span>);</span><br><span class="line">                        elog(DEBUG4, <span class="string">&quot;relation created with OID %u&quot;</span>, id);</span><br><span class="line">                    &#125;</span><br><span class="line">                    do_end();</span><br><span class="line">                &#125;</span><br><span class="line">        ;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到 <code>postgres.bki</code> 中的表也是通过 <code>heap_create_with_catalog()</code> 函数来创建的。需要注意的是，我们在通过 SQL 创建表的时候虽然也是通过 <code>heap_create_with_catalog()</code> 来新建表的，但是其参数 <code>shared_relation</code> 始终为 <code>false</code>。</p>
<p>PostgreSQL 的 BKI 文件提供了一下几种基本都命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create - 创建一个表</span><br><span class="line">open - 打开一个表</span><br><span class="line">close - 关闭一个表</span><br><span class="line">declare toast - 创建 TOAST 表</span><br><span class="line">insert - 向表中插入数据</span><br><span class="line">declare index - 声明索引</span><br><span class="line">declare unique index - 声明唯一性索引</span><br><span class="line">build indices - 创建索引</span><br></pre></td></tr></table></figure>
<p>关于各个命令的语法这里就不详细介绍了，感兴趣的朋友可以去看 <code>postgres.bki</code> 和 <code>bootstrap.y</code> 文件。至此，我们对 PostgreSQL 中的共享表的创建有了一个粗略的认识。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
</search>
